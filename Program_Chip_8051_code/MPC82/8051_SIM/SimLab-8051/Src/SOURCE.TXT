
@{
BuildIn
{
REGEQU
REG
}
Franklin
{
REGEQU
EQU
}
2500AD
{
REGEQU
REG
}
@}


%{access1.a51
;
;   存取內部資料記憶體(位址為0,8,40h,90h)的各種方法;   The methods to access internal data memory(address  at 0,8,40h,90h)
;
;
;   將內部記憶體位址0載入到ACC(三種) ;   three methods to load from internal data memory 0 to ACC
	MOV	A,R0
	CLR	A

	MOV	A,00
	CLR	A

	MOV	R1,#00
	MOV	A,@R1

;   將內部記憶體位址8載入到ACC(三種) ;   three methods to load from internal data memory 8 to ACC
	SETB	RS0
	MOV	A,R0
	CLR	RS0
	CLR	A

	MOV	A,08
	CLR	A

	MOV	R1,#08
	MOV	A,@R1
	CLR	A

;   將內部記憶體位址40h載入到ACC(二種) ;   two methods to load from internal data memory 40h to ACC

	MOV	A,40h
	CLR	A

	MOV	R1,#40h
	MOV	A,@R1
	CLR	A

;   將內部記憶體位址90h載入到ACC(一種) ;   only one  method to load from internal data memory 90h to ACC

	MOV	A,90h     ; 錯誤結果(存取到特殊暫存器) ; error(access special function register)
	CLR	A

	MOV	R1,#90h
	MOV	A,@R1
	CLR	A

	END
%}


%{access2.a51
;
;   存取位元資料(位址為3)的各種方法;   The methods to access bit data (address at 3)
;
;
	SETB	3
	CLR	3
	SETB	20h.3
	CLR	20h.3

	MOV	A,20h
	ORL	A,#008H
	MOV	20h,A

	MOV	A,20h
	ANL	A,#0F7h
	MOV	20h,A


	END
%}


%{adc1.a51
;
; 配合"ADC0804實習板";   Read analog voltage from ADC0804(synchronize by delay method),
;   讀取ADC0804的類比電壓值(採用延遲方式來同步),並將之顯示於8個LED上;       then display voltage on 8 pieces of LED
;
ADCRD	REGEQU	P1.0
ADCWR	REGEQU	P1.1

START:
	CLR	ADCWR
	SETB	ADCWR
	ACALL	DELAY150US
	CLR	ADCRD
	MOV	P2,P0
	SETB	ADCRD
	SJMP	START
DELAY150US:
	MOV	R1,#74
	DJNZ	R1,$
	RET
	END
%}


@1
%{adc1.c
//
//  配合"ADC0804實習板"//   Read analog voltage from ADC0804(synchronize by delay method),
//   讀取ADC0804的類比電壓值(採用延遲方式來同步),並將之顯示於8個LED上//     then display voltage on 8 pieces of LED 
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit ADCRD=P1 ^0 ;
sbit ADCWR=P1 ^1 ;
void delay150us()
{
	int i=0 ;
	for(i=0 ; i < 18 ; i++) ;
}
main()
{
	for(;;){
	    // start ADC
	    ADCWR=0 ; ADCWR= 1 ;
	    delay150us() ;
	    ADCRD=0 ;
	    P2=P0 ;
	    ADCRD=1 ;
	}
}
%}


%{adc2.a51
;
; 配合"ADC0804實習板";   Read analog voltage from ADC0804 (synchronize by polling method),
;   讀取ADC0804的類比電壓值(採用查詢方式來同步),並將之顯示於8個LED上;     then display voltage on 8 pieces of LED
;
ADCRD	REGEQU	P1.0
ADCWR	REGEQU	P1.1
ADCINTR	REGEQU	P3.2

START:
	CLR	ADCWR
	SETB	ADCWR
	JB	ADCINTR,$
	CLR	ADCRD
	MOV	P2,P0
	SETB	ADCRD
	SJMP	START
	END
%}


@1
%{adc2.c
//
//  配合"ADC0804實習板"//   Read analog voltage from ADC0804 (synchronize by polling method),
//   讀取ADC0804的類比電壓值(採用查詢方式來同步),並將之顯示於8個LED上//     then display voltage on 8 pieces of LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit ADCRD=P1 ^0 ;
sbit ADCWR=P1 ^1 ;
sbit ADCINTR=P3^2 ;
main()
{
	for(;;){
	    // start ADC
	    ADCWR=0 ; ADCWR= 1 ;
	    while(ADCINTR) ;
	    ADCRD=0 ;
	    P2=P0 ;
	    ADCRD=1 ;
	}
}
%}


%{adc3.a51
;
; 配合"ADC0804實習板";   Read analog voltage from ADC0804 (synchronize by interrupt method),
;   讀取ADC0804的類比電壓值(採用中斷方式來同步),並將之顯示於8個LED上;     then display voltage on 8 pieces of LED
;
ADCRD	REGEQU	P1.0
ADCWR	REGEQU	P1.1

	LJMP	START
	LJMP	EXTERNAL0
START:
	SETB	EA
	SETB	IT0
	SETB	EX0
; Start First ADC
	CLR	ADCWR
	SETB	ADCWR
	SJMP	$
EXTERNAL0:
	CLR	ADCRD
	MOV	P2,P0
	SETB	ADCRD
; Start Next ADC
	CLR	ADCWR
	SETB	ADCWR
	RETI
	END
%}


@1
%{adc3.c
//
//  配合"ADC0804實習板"//   Read analog voltage from ADC0804 (synchronize by interrupt method),
//   讀取ADC0804的類比電壓值(採用中斷方式來同步),並將之顯示於8個LED上//     then display voltage on 8 pieces of LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit ADCRD=P1 ^0 ;
sbit ADCWR=P1 ^1 ;
main()
{
	EA=1 ;
	IT0=1 ; // 偵測負緣觸發動作// detect negative edge trigger
	EX0=1 ; // 啟動INT0// active INT0
	// start first ADC
	ADCWR=0 ; ADCWR= 1 ;
	for(;;) ;
}
void external0(void ) interrupt 0
{
	ADCRD=0 ;
	P2=P0 ;
	ADCRD=1 ;
	// start next ADC
	ADCWR=0 ; ADCWR= 1 ;
}
%}


%{am.a51
;
;   各種定址法範例;   Addressing Mode Examples
;
TT	EQU	012H
ADDR	EQU	030H
;暫存器定址法; register Addressing Mode
	MOV	A,R7
	ANL	A,R0
	INC	A
	INC	DPTR
	MUL	AB
	DIV	AB
;立即定址法; Immediate Addressing Mode
	MOV	R5,#012H
	MOV	R5,#18
	MOV	R5,#22O
	MOV	R5,#010010B
	MOV	R5,TT
	MOV	DPTR,#1234H
;直接定址法; Direct Addressing Mode
	MOV	30H,A
	MOV	ADDR,A
	MOV	30H,#12H
	MOV	P0,A
	MOV	P0,#12H
	MOV	P1,#12H
	ANL	C,40H
	ANL	C,ACC.6
	SETB	40H
	SETB	P0.2
	CLR	P0.2
	MOV	C,P0.2
;暫存器間接定址法; Register Indirect Addressing Mode
	MOV	@R0,#79H
	MOV	A,@R1
	MOVX	@DPTR,A
	MOVX	A,@DPTR
;索引定址法(讀取程式記憶體) ; Index Addressing Mode(Read Program Memory)
	MOVC	A,@A+DPTR
	MOVC	A,@A+PC
	END
%}


%{basic1a.a51
;
; 兩個8位元數的相加; The addition of two 8-bit numbers
;
%0,2 VAL1:	EQU	40H
%0,2 VAL2:	EQU	VAL1+1
%0,2 RES:	EQU	VAL2+1
%1 	DSEG	AT 40H
%1 VAL1:	DS	1
%1 VAL2:	DS	1
%1 RES:	DS	1

%1 	CSEG
START:
	MOV	A,VAL1
	ADD	A,VAL2
	MOV	RES,A
	AJMP	$
	END
%}


%{basic1b.a51
;
; 兩個8位元數的相加; The addition of two 8-bit numbers
;
%0,2 VAL1:	EQU	40H
%1 	DSEG	AT 40H
%1 VAL1:	DS	1
%1 	DS	1
%1 	DS	1
%1 	CSEG
START:
	MOV	A,VAL1
	ADD	A,VAL1+1
	MOV	VAL1+2,A
	AJMP	$
	END
%}


%{basic1c.a51
;
; 兩個8位元數的相加; The addition of two 8-bit numbers
;
%0,2 VAL1:	EQU	40H
%1 	DSEG	AT 40H
%1 VAL1:	DS	3

%0,2 	ORG	0
%1 	CSEG
START:
	MOV	A,VAL1
	ADD	A,VAL1+1
	MOV	VAL1+2,A
	AJMP	$
	END
%}


%{basic1d.a51
;
; 兩個8位元數的相加; The addition of two 8-bit numbers
;
VAL1	EQU	40H
VAL2	EQU	41H
RES	EQU	42H
;
START:
	MOV	A,VAL1
	ADD	A,VAL2
	MOV	RES,A
	AJMP	$
	END
%}


%{basic1e.a51
;
; 兩個8位元數的相加; The addition of two 8-bit numbers
;
VAL1	EQU	40H
VAL2	EQU	41H
RES	EQU	42H
;
START:
	MOV	R0,#VAL1
	MOV	R1,#VAL2
	MOV	A,@R0
	ADD	A,@R1
	MOV	R0,#RES
	MOV	@R0,A
	AJMP	$
	END
%}


%{basic1f.a51
;
; 兩個8位元數的相加; The addition of two 8-bit numbers
;
VAL1	EQU	40H
;
START:
	MOV	R0,#VAL1
 	MOV	A,@R0
	INC	R0
	ADD	A,@R0
	INC	R0
	MOV	@R0,A
 	AJMP	$
	END
%}


%{basic1g.a51
;
; 兩個8位元數的相加(BCD) ; The addition of two 8-bit numbers (BCD)
;
%0,2 VAL1:	EQU	40H
%0,2 VAL2:	EQU	VAL1+1
%0,2 RES:	EQU	VAL2+1
%1 	DSEG	AT 40H
%1 VAL1:	DS	1
%1 VAL2:	DS	1
%1 RES:	DS	1

%1 	CSEG
START:
	MOV	A,VAL1
	ADD	A,VAL2
	DA	A
	MOV	RES,A
	AJMP	$
	END
%}


@1
%{basic1a.c
//
// 兩個8位元數的相加// The addition of two 8-bit numbers
//
#pragma oe db pw(80) SM SB CD
#include    <reg51.h>
unsigned char val1,val2,res;
main()
{
	res=val1+val2 ;
	for(;;);
}
%}


@1
%{basic1b.c
//
// 兩個8位元數的相加// The addition of two 8-bit numbers
//
#pragma oe db pw(80) SM SB CD
unsigned char data *val1;
unsigned char data *val2;
unsigned char data *res;
main()
{
	val1= 0x40 ;
	val2= 0x41 ;
	res= 0x42 ;
	*res=*val1+*val2 ;
	for(;;);
}
%}


@1
%{basic1c.c
//
// 兩個8位元數的相加// The addition of two 8-bit numbers
//
#pragma oe db pw(80) SM SB CD
unsigned char data *val1;
main()
{
	val1= 0x40 ;
	*(val1+2)=*val1+*(val1+1) ;
	for(;;);
}
%}


@1
%{basic1d.c
//
// 兩個8位元數的相加// The addition of two 8-bit numbers
//
#pragma oe db pw(80) SM SB CD
unsigned char val1,val2,res;
unsigned char  data * pval1 ;
unsigned char  data * pval2 ;
unsigned char  data * pres ;
main()
{
	pval1= &val1 ;
	pval2= &val2 ;
	pres= &res ;
	*pres= *pval1+*pval2 ;
	for(;;);
}
%}


@1
%{basic1e.c
//
// 兩個8位元數的相加// The addition of two 8-bit numbers
//
#pragma oe db pw(80) SM SB CD
unsigned char val1[3];
unsigned char data  * pval1 ;
main()
{
	pval1= val1 ;
	*(pval1+2)= *pval1+*(pval1+1) ;
	for(;;);
}
%}


@1
%{basic1f.c
//
// 兩個8位元數的相加// The addition of two 8-bit numbers
//
#pragma oe db pw(80) SM SB CD
unsigned char val1[3];
unsigned char data  * pval1 ;
main()
{
	pval1= val1 ;
	pval1[2]= pval1[0]+pval1[1] ;
	for(;;);
}
%}


@1
%{basic1g.c
//
// 兩個8位元數的相加(BCD) // The addition of two 8-bit numbers (BCD)
//
#pragma oe db pw(80) SM SB CD
#include    <reg51.h>
unsigned char val1,val2,res;
main()
{
	unsigned char low4,high4 ,carry ;
	F0=1 ;
	low4=(val1&0xf)+(val2&0xf) ;
	carry=0 ;
	if(low4 >= 10){
	    carry=0x1 ;
	    low4-= 10 ;
	}
	high4=(val1 >> 4)+(val2 >> 4)+carry ;
	carry=0 ;
	if(high4 >=10){
	    carry=1 ;
	    high4-= 10 ;
	}
	res = (high4 << 4)+low4 ;
	for(;;);
}
%}


%{basic2a.a51
;
; 兩個16位元數的相加; The addition of two 16-bit numbers
;
%0,2 VAL1:	EQU	40H ;低位址放數值的高位元組; low address store high byte of 16-bit value
%0,2 VAL2:	EQU	VAL1+2
%0,2 RES:	EQU	VAL2+2
%1 	DSEG	AT 40H
%1 VAL1:	DS	2 ;低位址放數值的高位元組; low address store high byte of 16-bit value
%1 VAL2:	DS	2
%1 RES:	DS	2

%1 	CSEG
START:
	MOV	A,VAL1+1
	ADD	A,VAL2+1
	MOV	RES+1,A

	MOV	A,VAL1
	ADDC	A,VAL2
	MOV	RES,A

	AJMP	$
	END
%}


@1
%{basic2a.c
//
// 兩個16位元數的相加// The addition of two 16-bit numbers
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned int val1,val2,res;
main()
{
	F0=1 ;
	res=val1+val2 ;
	for(;;);
}
%}


@1
%{basic2b.c
//
// 兩個16位元數的相加// The addition of two 16-bit numbers
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
unsigned int val1,val2,res;
unsigned char data *pval1 ;
unsigned char data *pval2 ;
unsigned char data *pres ;
main()
{
	unsigned char carry ;

	F0=1 ;
	pval1= (unsigned char *)&val1 ;
	pval2= (unsigned char *)&val2 ;
	pres = (unsigned char *)&res ;
	*(pres+1)=*(pval1+1)+*(pval2+1) ;
	carry = (*(pres+1) < *(pval1+1)) ? 1:0 ;
	*pres= pval1[0]+pval2[0]+carry ;
	for(;;);
}
%}


%{basic3a.a51
;
; 找出兩個8位元數中的較大值(unsigned view) ; Find the maximum from two 8-bit numbers (unsigned view)
;
%0,2 VAL1:	EQU	40H
%0,2 VAL2:	EQU	VAL1+1
%0,2 RES:	EQU	VAL2+1
%1 	DSEG	AT 40H
%1 VAL1:	DS	1
%1 VAL2:	DS	1
%1 RES:	DS	1

%1 	CSEG
START:
	CLR	C
	MOV	A,VAL1
	SUBB	A,VAL2
	JNC	VAL1G
	MOV	A,VAL2
	MOV	RES,A
	AJMP	CON
VAL1G:
	MOV	A,VAL1
	MOV	RES,A
CON:
	AJMP	$
	END
%}


@1
%{basic3a.c
//
// 找出兩個8位元數中的較大值(unsigned view) // Find the maximum from two 8-bit numbers (unsigned view)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned char val1,val2,res;
main()
{
	if(val1 >val2){
	    res= val1 ;
	}
	else{
	    res=val2 ;
	}
	for(;;);
}
%}


@1
%{basic3b.c
//
// 找出兩個8位元數中的較大值(unsigned view) // Find the maximum from two 8-bit numbers (unsigned view)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned char val1,val2,res;
main()
{
	res= (val1 >val2)? val1 : val2 ;
	for(;;);
}
%}


%{basic4a.a51
;
; 找出兩個8位元數中的較大值(signed view) ; Find the maximum from two 8-bit numbers (signed view)
;
%0,2 VAL1:	EQU	40H
%0,2 VAL2:	EQU	VAL1+1
%0,2 RES:	EQU	VAL2+1
%1 	DSEG	AT 40H
%1 VAL1:	DS	1
%1 VAL2:	DS	1
%1 RES:	DS	1

%1 	CSEG
START:
	MOV	A,VAL1
	JB	ACC.7,VAL1N
; VAL1 is 正數; VAL1 is plus
	MOV	A,VAL2
	JB	ACC.7,VAL1G
; VAL1和VAL2同號; VAL1和VAL2 same sign
VAL12SS:
	MOV	A,VAL1
	CLR	C
	SUBB	A,VAL2
	JB	ACC.7,VAL2G
VAL1G:
	MOV	A,VAL1
	MOV	RES,A
	AJMP	CON
VAL1N:
	MOV	A,VAL2
	JB	ACC.7,VAL12SS
VAL2G:
	MOV	A,VAL2
	MOV	RES,A
CON:
	AJMP	$
	END
%}


%{basic4b.a51
;
; 找出兩個8位元數中的較大值(signed view) ; Find the maximum from two 8-bit numbers (signed view)
;
VAL1:	EQU	40H
VAL2:	EQU	VAL1+1
RES:	EQU	VAL2+1
;
START:
	CLR	C
	MOV	A,VAL2
	XRL	A,#080H
	MOV	R0,A
	MOV	A,VAL1
	XRL	A,#080H
	SUBB	A,R0
	JNC	VAL1G
	MOV	A,VAL2
	MOV	RES,A
	AJMP	CON
VAL1G:
	MOV	A,VAL1
	MOV	RES,A
CON:
	AJMP	$
	END
%}


@1
%{basic4a.c
//
// 找出兩個8位元數中的較大值(signed view) // Find the maximum from two 8-bit numbers (signed view)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char val1,val2,res;
main()
{
	if(val1 >val2){
	    res= val1 ;
	}
	else{
	    res=val2 ;
	}
	for(;;);
}
%}


%{basic5a.a51
;
; 字元分割; Word disassembly
;
%0,2 VAL1:	EQU	40H
%0,2 HIGH4:	EQU	VAL1+1
%0,2 LOW4:	EQU	HIGH4+1
%1 	DSEG	AT 40H
%1 VAL1:	DS	1
%1 HIGH4:	DS	1
%1 LOW4:	DS	1

%1 	CSEG
START:
	MOV	A,VAL1
	RR	A
	RR	A
	RR	A
	RR	A
	ANL	A,#0FH
	MOV	HIGH4,A
	MOV	A,VAL1
	ANL	A,#0FH
	MOV	LOW4,A

	AJMP	$
	END
%}


%{basic5b.a51
;
; 字元分割; Word disassembly
;
%0,2 VAL1:	EQU	40H
%0,2 HIGH4:	EQU	VAL1+1
%0,2 LOW4:	EQU	HIGH4+1
%1 	DSEG	AT 40H
%1 VAL1:	DS	1
%1 HIGH4:	DS	1
%1 LOW4:	DS	1

%1 	CSEG
START:
	MOV	A,VAL1
	SWAP	A
	ANL	A,#0FH
	MOV	HIGH4,A
	MOV	A,VAL1
	ANL	A,#0FH
	MOV	LOW4,A

	AJMP	$
	END
%}


@1
%{basic5a.c
//
// 字元分割// Word disassembly
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char val1,high4,low4;
main()
{
	high4= (val1 >> 4 ) &0xf ;
	low4= val1 & 0xf ;
	for(;;);
}
%}


%{basic6a.a51
;
; 許多8位元數的相加(和為8位元) ; The sum of 8-bit numbers (the sum is 8-bit)
;
%0,2 VAL:	EQU	40H ;第一位元組為數值的個數; first byte is NO. of values
%0,2 SUM:	EQU	VAL+10
%1 	DSEG	AT 40H
%1 VAL:	DS	10   ;第一位元組為數值的個數; first byte is NO. of values
%1 SUM:	DS	1

%1 	CSEG
START:
	MOV	R0,VAL
	MOV	R1,#VAL+1
	MOV	A,#0
NEXT1:
	ADD	A,@R1
	INC	R1
	DJNZ	R0,NEXT1
	MOV	SUM,A
	AJMP	$
	END
%}


@1
%{basic6a.c
//
// 許多8位元數的相加(和為8位元) // The sum of 8-bit numbers (the sum is 8-bit)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned char val[10],sum;
main()
{
	unsigned char i ;
	F0=1 ;
	sum=0 ;
	for(i=0 ; i < val[0];i++){
	    sum += val[1+i] ;
	}
	for(;;);
}
%}


%{basic7a.a51
;
; 許多8位元數的相加(和為16位元) ; The sum of 8-bit numbers (the sum is 16-bit)
;
%0,2 VAL:	EQU	40H   ;第一位元組為數值的個數; first byte is NO. of values
%0,2 SUM:	EQU	VAL+10
%1 	DSEG	AT 40H
%1 VAL:	DS	10   ;第一位元組為數值的個數; first byte is NO. of values
%1 SUM:	DS	2

%1 	CSEG
START:
	MOV	R0,VAL
	MOV	R1,#VAL+1
	MOV	A,#0
	MOV	B,A
NEXT1:
	ADD	A,@R1
	INC	R1
	JNC	CON1
	INC	B
CON1:
	DJNZ	R0,NEXT1
	MOV	SUM,B
	MOV	SUM+1,A
	AJMP	$
	END
%}


@1
%{basic7a.c
//
// 許多8位元數的相加(和為16位元) // The sum of 8-bit numbers (the sum is 16-bit)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned char val[10];
unsigned int sum;
main()
{
	unsigned char i ;
	F0=1 ;
	sum=0 ;
	for(i=0 ; i < val[0];i++){
	    sum += val[1+i] ;
	}
	for(;;);
}
%}


%{delay1.a51
;
; 配合"F0"計算延遲時間-----8051工作頻率12Mhz; setting "F0" to compute delay time-----8051 working frequence =12Mhz
;
START:
	LCALL	DELAY1MS
	SETB	F0
	AJMP	$
DELAY1MS:
	MOV	R1,#255
	DJNZ	R1,$
	MOV	R1,#242
	DJNZ R1,$
	RET
DELAY10MS:
	MOV	R0,#9
T1DLY10MS:
	ACALL	DELAY1MS
	DJNZ	R0,T1DLY10MS
	MOV	R1,#255
	DJNZ	R1,$
	MOV	R1,#232
	DJNZ	R1,$
	NOP
	RET


DELAY10MS1:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	MOV	R1,#255
	DJNZ	R1,$
	MOV	R1,#242
	DJNZ	R1,$
	RET

DELAY10MS2:
	MOV	R0,#19
T1DLY10MS2:
	MOV	R1,#255
	DJNZ	R1,$
	DJNZ	R0,T1DLY10MS2
	MOV	R1,#123
	DJNZ	R1,$
	NOP
	RET

DELAY100MS:
	MOV	R0,#194    ;延遲時間;delay time
T1DLY100MS:
	MOV	R1,#255
	DJNZ	R1,$
	DJNZ	R0,T1DLY100MS
	RET

DELAY1S:
	MOV	R2,#10
T2DLY1S:
 	MOV	R0,#194
T1DLY1S:
	MOV	R1,#255
	DJNZ	R1,$
	DJNZ	R0,T1DLY1S
	MOV	R1,#236
	DJNZ	R1,$
	DJNZ	R2,T2DLY1S
	MOV	R1,#7
	DJNZ	R1,$
	RET
TT:	MOV	R6,#250
S1:	MOV	R7,#200
	DJNZ	R7,$
	DJNZ	R6,S1
	RET
	END
%}


@1
%{delay1.c
//
//   配合"F0"計算延遲時間-----8051工作頻率12Mhz//   setting "F0" to compute delay time-----8051 working frequence =12Mhz
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
void delay1s() ;
void delay1ms() ;
void delay10ms() ;
void delay10ms1() ;
void delay10ms2() ;
void delay100ms() ;
main()
{
	F0=1 ;
	delay100ms() ;
	F0=1 ;
}
void delay1ms()
{
	int i ;
	char  j;
	for(i=0 ; i < 124 ;i++) ;
	j++ ;
}
void delay10ms()
{
	int i ;
	char j ;
	for(i=0 ; i < 9 ; i++){
         delay1ms() ;
	}
	for(i=0 ; i < 114;i++) ;
	j++ ;
	j++ ;
	j++ ;
	j++ ;
	j++ ;
	j++ ;
}
void delay10ms1()
{
	int i ;
	char j;
	delay1ms() ;	
	delay1ms() ;	
	delay1ms() ;	
	delay1ms() ;	
	delay1ms() ;	
	delay1ms() ;	
	delay1ms() ;	
	delay1ms() ;	
	delay1ms() ;	
	for(i=0 ; i < 124 ;i++) ;
	j++ ;
}
void delay10ms2()
{
	int i ;
	char j ;
	for(i=0 ; i < 1938 ;i++) ;
	j++ ;
	j++ ;
}
void delay100ms()
{
	long i ;
	char j ;
	for(i=0 ; i < 709 ; i++) ;  
	for(j=0 ; j < 5 ;j++) ;
	j++ ;
	j++ ;
}
void delay1s()
{
	long i ;
	char j ;
	for(i=0 ; i < 7092 ; i++) ;  //延遲時間// delay time
	for(j=0 ; j < 4 ;j++) ;
	j++ ;
	j++ ;
}
%}


%{mul16a.a51
;
; 兩個16位元數的相乘(binary unsigned view) ; A(16bit)*B(16bit) Binary unsigned view
;
%0,2 MA:      EQU	40H
%0,2 MB:      EQU	MA+2
%0,2 MP:      EQU	MB+2
%1 	CSEG
%1 	DSEG	AT 40H
%1 MA:      DS	2
%1 MB:      DS	2
%1 MP:      DS	4
%1 	CSEG
DOUBLET	MACRO
	MOV	A,R4
	CLR	C
	RLC	A
	MOV	R4,A
	MOV	A,R3
	RLC	A
	MOV	R3,A
	MOV	A,R2
	RLC	A
	MOV	R2,A
	MOV	A,R1
	RLC	A
	MOV	R1,A
	ENDM
ADDPT	MACRO
	MOV	A,R4
	ADD	A,MP+3
	MOV	MP+3,A
	MOV	A,R3
	ADDC	A,MP+2
	MOV	MP+2,A
	MOV	A,R2
	ADDC	A,MP+1
	MOV	MP+1,A
	MOV	A,R1
	ADDC	A,MP+0
	MOV	MP+0,A
	ENDM


START:
; 測試資料  1234H*5678H=? (6260060H) ; test data  1234H*5678H=? (6260060H)
	MOV	MA,#12H
	MOV	MA+1,#34H
	MOV	MB,#56H
	MOV	MB+1,#78H

	SETB	F0

	MOV	R1,#0
	MOV	R2,#0
	MOV	R3,MA
	MOV	R4,MA+1

	MOV	A,MB+1
	JNB	ACC.0,NEXT0
	MOV	MP,R1
	MOV	MP+1,R2
	MOV	MP+2,R3
	MOV	MP+3,R4
	SJMP	NEXT01
NEXT0:
	MOV	MP,#0
	MOV	MP+1,#0
	MOV	MP+2,#0
	MOV	MP+3,#0
NEXT01:
	DOUBLET
	MOV	A,MB+1
	JNB	ACC.1,NEXT1
	ADDPT
NEXT1:
	DOUBLET
	MOV	A,MB+1
	JNB	ACC.2,NEXT2
	ADDPT
NEXT2:
	DOUBLET
	MOV	A,MB+1
	JNB	ACC.3,NEXT3
 	ADDPT
NEXT3:
	DOUBLET
	MOV	A,MB+1
	JNB	ACC.4,NEXT4
	ADDPT
NEXT4:
	DOUBLET
	MOV	A,MB+1
	JNB	ACC.5,NEXT5
	ADDPT
NEXT5:
	DOUBLET
	MOV	A,MB+1
	JNB	ACC.6,NEXT6
	ADDPT
NEXT6:
	DOUBLET
	MOV	A,MB+1
	JNB	ACC.7,NEXT7
	ADDPT
NEXT7:
	DOUBLET
	MOV	A,MB
	JNB	ACC.0,NEXT8
	ADDPT
NEXT8:
	DOUBLET
	MOV	A,MB
	JNB	ACC.1,NEXT9
	ADDPT
NEXT9:
	DOUBLET
	MOV	A,MB
	JNB	ACC.2,NEXT10
	ADDPT
NEXT10:
	DOUBLET
	MOV	A,MB
	JNB	ACC.3,NEXT11
	ADDPT
NEXT11:
	DOUBLET
	MOV	A,MB
	JNB	ACC.4,NEXT12
	ADDPT
NEXT12:
	DOUBLET
	MOV	A,MB
	JNB	ACC.5,NEXT13
	ADDPT
NEXT13:
	DOUBLET
	MOV	A,MB
	JNB	ACC.6,NEXT14
	ADDPT
NEXT14:
	DOUBLET
	MOV	A,MB
	JNB	ACC.7,NEXT15
	ADDPT
NEXT15:

	SETB	F0
	AJMP	$
	END
%}


%{mul16b.a51
;
; 兩個16位元數的相乘(binary unsigned view) ; A(16bit)*B(16bit) Binary unsigned view
;
%0,2 MA:	EQU	40H
%0,2 MB:	EQU	MA+2
%0,2 MP:	EQU	MB+2
%0,2 MT:	EQU	MP+4
%1 	CSEG
%1 	DSEG	AT 40H
%1 MA:	DS	2
%1 MB:	DS	2
%1 MP:	DS	4
%1 MT:	DS	4
%1 	CSEG

START:
; 測試資料  1234H*5678H=? (6260060H) ; test data  1234H*5678H=? (6260060H)

	MOV	MA,#12H
	MOV	MA+1,#34H
	MOV	MB,#56H
	MOV	MB+1,#78H
	SETB	F0
;   t <- A
	MOV	MT,#0
	MOV	MT+1,#0
	MOV	MT+2,MA
	MOV	MT+3,MA+1
;   P <--B0*t
	MOV	A,MB+1
	JNB	ACC.0,NEXT1
;   P<----t
	MOV	MP,MT
	MOV	MP+1,MT+1
	MOV	MP+2,MT+2
	MOV	MP+3,MT+3
	AJMP	NEXT2
NEXT1:
;   P<----0
	MOV	MP,#0
	MOV	MP+1,#0
	MOV	MP+2,#0
	MOV	MP+3,#0
NEXT2:
	MOV	R7,#15     ; 重覆15次; repeat 15 times
LOOP1:
;   t <-t*2
	CLR	C
	MOV	A,MT+3
	RLC	A
	MOV	MT+3,A
	MOV	A,MT+2
	RLC	A
	MOV	MT+2,A
	MOV	A,MT+1
	RLC	A
	MOV	MT+1,A
	MOV	A,MT
	RLC	A
	MOV	MT,A
; B <-- shr B
	MOV	A,MB
	RRC	A
	MOV	MB,A
	MOV	A,MB+1
	RRC	A
	MOV	MB+1,A
;   check B0
	MOV	A,MB+1
	JNB	ACC.0,NEXT3
;   P<----P+t
	MOV	A,MT+3
	ADD	A,MP+3
	MOV	MP+3,A
	MOV	A,MT+2
	ADDC	A,MP+2
	MOV	MP+2,A
	MOV	A,MT+1
	ADDC	A,MP+1
	MOV	MP+1,A
	MOV	A,MT+0
	ADDC	A,MP+0
	MOV	MP+0,A
NEXT3:
	DJNZ	R7,LOOP1

	SETB	F0
	AJMP	$
	END
%}


%{mul16c.a51
;
; 兩個16位元數的相乘(binary unsigned view) ; A(16bit)*B(16bit) Binary unsigned view
;
%0,2 MA:	EQU	40H
%0,2 MB:	EQU	MA+2
%0,2 MP:	EQU	MB+2
%1 	DSEG	AT 40H
%1 MA:	DS	2
%1 MB:	DS	2
%1 MP:	DS	4
%1 	CSEG

START:
; 測試資料  1234H*5678H=? (6260060H) ; test data  1234H*5678H=? (6260060H)

	MOV	MA,#12H
	MOV	MA+1,#34H
	MOV	MB,#56H
	MOV	MB+1,#78H
	SETB	F0
;   P<----0
	MOV	MP,#0
	MOV	MP+1,#0
	MOV	MP+2,#0
	MOV	MP+3,#0

	MOV	R7,#16     ; 重覆16次; repeat 16 times
LOOP1:
;   t <-t*2
	CLR	C
	MOV	A,MP+3
	RLC	A
	MOV	MP+3,A
	MOV	A,MP+2
	RLC	A
	MOV	 MP+2,A
	MOV	A,MP+1
	RLC	A
	MOV	MP+1,A
	MOV	A,MP
	RLC	A
	MOV	MP,A
; B <-- shl B
	MOV	A,MB+1
	RLC	A
	MOV	MB+1,A
	MOV	A,MB
	RLC	A
	MOV	MB,A

	JNC	NEXT3
;   P<----P+A
	MOV	A,MA+1
	ADD	A,MP+3
	MOV	MP+3,A
	MOV	A,MA+0
	ADDC	A,MP+2
	MOV	MP+2,A
	MOV	A,#0
	ADDC	A,MP+1
	MOV	MP+1,A
	MOV	A,#0
	ADDC	A,MP+0
	MOV	MP+0,A
NEXT3:
	DJNZ	R7,LOOP1

	SETB	F0

	AJMP	$
	END
%}


%{mul16d.a51
;
; 兩個16位元數的相乘(binary unsigned view) ; A(16bit)*B(16bit) Binary unsigned view
;
%0,2 MA:	EQU	40H
%0,2 MB:	EQU	MA+2
%0,2 MP:	EQU	MB+2
%0,2 ALBL:	EQU	MP+4
%0,2 AHBL:	EQU	ALBL+2
%0,2 ALBH:	EQU	AHBL+2
%0,2 AHBH:	EQU	ALBH+2
%1 	DSEG	AT 40H
%1 MA:	DS	2
%1 MB:	DS	2
%1 MP:	DS	4
%1 ALBL:	DS	2
%1 AHBL:	DS	2
%1 ALBH:	DS	2
%1 AHBH:	DS	2
%1 	CSEG

START:
; 測試資料  1234H*5678H=? (6260060H) ; test data  1234H*5678H=? (6260060H)

	MOV	MA,#12H
	MOV	MA+1,#34H
	MOV	MB,#56H
	MOV	MB+1,#78H

	SETB	F0
;   AL*BL
	MOV	A,MA+1
	MOV	B,MB+1
	MUL	AB
	MOV	ALBL,B
	MOV	ALBL+1,A
;   AH*BL
	MOV	A,MA
	MOV	B,MB+1
	MUL	AB
	MOV	AHBL,B
	MOV	AHBL+1,A
;   AL*BH
	MOV	A,MA+1
	MOV	B,MB
	MUL	AB
	MOV	ALBH,B
	MOV	ALBH+1,A
;   AH*BH
	MOV	A,MA
	MOV	B,MB
	MUL	AB
	MOV	AHBH,B
	MOV	AHBH+1,A
;
	MOV	MP+3,ALBL+1
;計算MP+2;compute MP+2
	MOV	A,ALBL
	ADD	A,AHBL+1
	MOV	R6,A
	CLR	A
	ADDC	A,#0
	MOV	R7,A

	MOV	A,R6
	ADD	A,ALBH+1
	MOV	MP+2,A
	CLR	A
	ADDC	A,R7
;計算MP+1;compute MP+1
	ADD	A,AHBL
	MOV	R6,A
	CLR	A
	ADDC	A,#0
	MOV	R7,A

	MOV	A,R6
	ADD	A,ALBH
	MOV	R6,A
	CLR	A
	ADDC	A,R7
	MOV	R7,A

	MOV	A,R6
	ADD	A,AHBH+1
	MOV	MP+1,A
	CLR	A
	ADDC	A,R7

;計算MP;compute MP
	ADD	A,AHBH
	MOV	MP,A

	SETB	F0
	AJMP	$
	END
%}


@1
%{mul16a.c
//
//  兩個16位元數的相乘(binary unsigned view) //  A(16bit)*B(16bit) Binary unsigned view
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned int MA,MB;
unsigned long MP ;
main()
{
//  測試資料  0x1234*0x5678=? (0x6260060) //  test data  0x1234*0x5678=? (0x6260060)
	MA=0x1234;
	MB=0x5678 ;
	
	F0=1 ;
	if(MB&0x1){
	    MP=MA ;
	}
	else{
	    MP=0 ;
	}
	if(MB&0x2){
	    MP= MP+((unsigned long)MA << 1) ;
	}
	if(MB&0x4){
	    MP= MP+((unsigned long)MA << 2) ;
	}
	if(MB&0x8){
	    MP= MP+((unsigned long)MA << 3) ;
	}
	if(MB&0x10){
	    MP= MP+((unsigned long)MA << 4) ;
	}
	if(MB&0x20){
	    MP= MP+((unsigned long)MA << 5) ;
	}
	if(MB&0x40){
	    MP= MP+((unsigned long)MA << 6) ;
	}
	if(MB&0x80){
	    MP= MP+((unsigned long)MA << 7) ;
	}
	if(MB&0x100){
	    MP= MP+((unsigned long)MA << 8) ;
	}
	if(MB&0x200){
	    MP= MP+((unsigned long)MA << 9) ;
	}
	if(MB&0x400){
	    MP= MP+((unsigned long)MA << 10) ;
	}
	if(MB&0x800){
	    MP= MP+((unsigned long)MA << 11) ;
	}
	if(MB&0x1000){
	    MP= MP+((unsigned long)MA << 12) ;
	}
	if(MB&0x2000){
	    MP= MP+((unsigned long)MA << 13) ;
	}
	if(MB&0x4000){
	    MP= MP+((unsigned long)MA << 14) ;
	}
	if(MB&0x8000){
	    MP= MP+((unsigned long)MA << 15) ;
	}
	F0=1 ;
	for(;;);
}
%}


@1
%{mul16b.c
//
//  兩個16位元數的相乘(binary unsigned view) //  A(16bit)*B(16bit) Binary unsigned view
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned int MA,MB;
unsigned long MP ;
main()
{
	unsigned int AL,AH,BL,BH ;
	unsigned int ALBL,AHBL,ALBH,AHBH ;
//  測試資料  0x1234*0x5678=? (0x6260060) //  test data  0x1234*0x5678=? (0x6260060)
	MA=0x1234;
	MB=0x5678 ;
	F0=1 ;
	AL=MA&0xff ;
	AH=MA >> 8 ;
	BL=MB&0xff ;
	BH=MB >> 8 ;
	ALBL=AL*BL ;
	AHBL=AH*BL ;
	ALBH=AL*BH ;
	AHBH=AH*BH ;
	MP=(unsigned long)(ALBL)+((unsigned long)(AHBL) << 8)+((unsigned long)(ALBH) << 8)+((unsigned long)(AHBH) << 16) ;
	F0=1 ;
	for(;;);
}
%}


@1
%{mul16c.c
//
//  兩個16位元數的相乘(binary unsigned view) //  A(16bit)*B(16bit) Binary unsigned view
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned int MA,MB;
unsigned long MP ;
main()
{
//  測試資料  0x1234*0x5678=? (0x6260060) //  test data  0x1234*0x5678=? (0x6260060)
	MA=0x1234;
	MB=0x5678 ;
	F0=1 ;
	MP=(unsigned long)MA*(unsigned long)MB ;
	F0=1 ;
	for(;;);
}
%}


%{div32a.a51
;
; M(32位元)/N(16位元)=Q(32位元)...R(16位元)(binary unsigned view) ; M(32bit)/N(16bit)=Q(32bit)...R(16bit) Binary unsigned view
;
%0,2 MM:	EQU	40H
%0,2 MN:	EQU	MM+4
%0,2 MQ:	EQU	MN+2
%0,2 MR:	EQU	MQ+4
%0,2 MT:	EQU	MR+2
%1 	DSEG	AT 40H
%1 MM:	DS	4
%1 MN:	DS	2
%1 MQ:	DS	4
%1 MR:	DS	2
%1 MT:	DS	6

%1 	CSEG
START:
; 測試資料(12345678H/234H)=? (84354H....168H) ; test data(12345678H/234H)=? (84354H....168H)

	MOV	MM,#12H
	MOV	MM+1,#34H
	MOV	MM+2,#56H
	MOV	MM+3,#78H
	MOV	MN,#02H
	MOV	MN+1,#34H

	SETB  F0
; T<--2**32*N
	MOV	MT,MN
	MOV	MT+1,MN+1
	MOV	MT+2,#0
	MOV	MT+3,#0
	MOV	MT+4,#0
	MOV	MT+5,#0

	MOV	R0,#32
LOOP1:
;  T <-T/2
	MOV	A,MT
	CLR	C
	RRC	A
	MOV	MT,A
	MOV	A,MT+1
	RRC	A
	MOV	MT+1,A
	MOV	A,MT+2
	RRC	A
	MOV	MT+2,A
	MOV	A,MT+3
	RRC	A
	MOV	MT+3,A
	MOV	A,MT+4
	RRC	A
	MOV	MT+4,A
	MOV	A,MT+5
	RRC	A
	MOV	MT+5,A
;      M >=T
	MOV	A,MT
	ORL	A,MT+1
	JNZ	LESS1
	MOV	A,MM
	CJNE	A,MT+2,NEXT2
	MOV	A,MM+1
	CJNE	A,MT+3,NEXT2
	MOV	A,MM+2
	CJNE	A,MT+4,NEXT2
	MOV	A,MM+3
	CJNE	A,MT+5,NEXT2
	SJMP	GREATER

NEXT2:
	JC	LESS1
GREATER:
; M<-M-T
	MOV	A,MM+3
	CLR	C
	SUBB	A,MT+5
	MOV	MM+3,A
	MOV	A,MM+2
	SUBB	A,MT+4
	MOV	MM+2,A
	MOV	A,MM+1
	SUBB	A,MT+3
	MOV	MM+1,A
	MOV	A,MM+0
	SUBB	A,MT+2
	MOV	MM+0,A
	SETB	C
	SJMP	CON1
LESS1:
	CLR	C
CON1:
	MOV	A,MQ+3
	RLC	A
	MOV	MQ+3,A
	MOV	A,MQ+2
	RLC	A
	MOV	MQ+2,A
	MOV	A,MQ+1
	RLC	A
	MOV	MQ+1,A
	MOV	A,MQ+0
	RLC	A
	MOV	MQ+0,A
	DJNZ	R0,LOOP1

	MOV	MR,MM+2
	MOV	MR+1,MM+3

	SETB	F0
	AJMP	$
	END
%}


%{div32b.a51
;
; M(32位元)/N(16位元)=Q(32位元)...R(16位元)(binary unsigned view) ; M(32bit)/N(16bit)=Q(32bit)...R(16bit) Binary unsigned view
;
%0,2 MM:	EQU	40H
%0,2 MN:	EQU	MM+4
%0,2 MQ:	EQU	MN+2
%0,2 MR:	EQU	MQ+4
%0,2 MT:	EQU	MR+2
%1 	DSEG	AT 40H
%1 MM:	DS	4
%1 MN:	DS	2
%1 MQ:	DS	4
%1 MR:	DS	2
%1 MT:	DS	3
%1 	CSEG
START:
; 測試資料(12345678H/234H)=? (84354H....168H) ; test data (12345678H/234H)=? (84354H....168H)

	MOV	MM,#12H
	MOV	MM+1,#34H
	MOV	MM+2,#56H
	MOV	MM+3,#78H
	MOV	MN,#02H
	MOV	MN+1,#34H

	SETB	F0
; T<--0
	MOV	MT,#0
	MOV	MT+1,#0
	MOV	MT+2,#0

	MOV	R0,#32
LOOP1:
;  T <- T*2
	MOV	A,MT+2
	CLR	C
	RLC	A
	MOV	MT+2,A
	MOV	A,MT+1
	RLC	A
	MOV	MT+1,A
	MOV	A,MT+0
	RLC	A
	MOV	MT+0,A
; C,M <-shl M
	MOV	A,MM+3
	CLR	C
	RLC	A
	MOV	MM+3,A
	MOV	A,MM+2
	RLC	A
	MOV	MM+2,A
	MOV	A,MM+1
	RLC	A
	MOV	MM+1,A
	MOV	A,MM+0
	RLC	A
	MOV	MM+0,A
;    T <- T+C
	JNC	NEXT1
	INC	MT+2
NEXT1:
;      T >=N
	MOV	A,MT
	JNZ	GREATER
	CLR	C
	MOV	A,MT+2
	SUBB	A,MN+1
	MOV	A,MT+1
	SUBB	A,MN
	JC	LESS1
GREATER:
	MOV	A,MT+2
	SUBB	A,MN+1
	MOV	MT+2,A
	MOV	A,MT+1
	SUBB	A,MN
	MOV	MT+1,A
	MOV	A,MT
	SUBB	A,#0
	MOV	MT,A
	SETB	C
	SJMP	CON1
LESS1:
	CLR	C
CON1:
	MOV	A,MQ+3
	RLC	A
	MOV	MQ+3,A
	MOV	A,MQ+2
	RLC	A
	MOV	MQ+2,A
	MOV	A,MQ+1
	RLC	A
	MOV	MQ+1,A
	MOV	A,MQ+0
	RLC	A
	MOV	MQ+0,A
	DJNZ	R0,LOOP1

	MOV	MR,MT+1
	MOV	MR+1,MT+2

	SETB	F0
	AJMP	$
	END
%}


%{div32c.a51
;
; M(32位元)/N(16位元)=Q(32位元)...R(16位元)(binary unsigned view) ; M(32bit)/N(16bit)=Q(32bit)...R(16bit) Binary unsigned view
;
%0,2 MM:	EQU	40H
%0,2 MN:	EQU	MM+4
%0,2 MQ:	EQU	MN+2
%0,2 MR:	EQU	MQ+4
%0,2 MT:	EQU	MR+2
%1 	DSEG	AT 40H
%1 MM:	DS	4
%1 MN:	DS	2
%1 MQ:	DS	4
%1 MR:	DS	2
%1 MT:	DS	3
%1 	 CSEG
START:
; 測試資料(12345678H/234H)=? (84354H....168H) ; test data (12345678H/234H)=? (84354H....168H)

	MOV	MM,#12H
	MOV	MM+1,#34H
	MOV	MM+2,#56H
	MOV	MM+3,#78H
	MOV	MN,#02H
	MOV	MN+1,#34H

	SETB	F0
; T<--0
	MOV	MT,#0
	MOV	MT+1,#0
	MOV	MT+2,#0

	MOV	R0,#32
LOOP1:
;  T <- T*2
	MOV	A,MT+2
	CLR	C
	RLC	A
	MOV	MT+2,A
	MOV	A,MT+1
	RLC	A
	MOV	MT+1,A
	MOV	A,MT+0
	RLC	A
	MOV	MT+0,A
; C,M <-shl M
	MOV	A,MM+3
	CLR	C
	RLC	A
	MOV	MM+3,A
	MOV	A,MM+2
	RLC	A
	MOV	MM+2,A
	MOV	A,MM+1
	RLC	A
	MOV	MM+1,A
	MOV	A,MM+0
	RLC	A
	MOV	MM+0,A
;    T <- T+C
	JNC	NEXT1
	INC	MT+2
NEXT1:
;      T >=N
	MOV	A,MT
	JNZ	GREATER
	CLR	C
	MOV	A,MT+2
	SUBB	A,MN+1
	MOV	A,MT+1
	SUBB	A,MN
	JC	LESS1
GREATER:
	MOV	A,MT+2
	SUBB	A,MN+1
	MOV	MT+2,A
	MOV	A,MT+1
	SUBB	A,MN
	MOV	MT+1,A
	MOV	A,MT
	SUBB	A,#0
	MOV	MT,A
	INC	MM+3
LESS1:
	DJNZ	R0,LOOP1

	MOV	MQ,MM
	MOV	MQ+1,MM+1
	MOV	MQ+2,MM+2
	MOV	MQ+3,MM+3

	MOV	MR,MT+1
	MOV	MR+1,MT+2

	SETB	F0
	AJMP	$
	END
%}


@1
%{div32a.c
//
//  M(32bit)/N(16bit)=Q(32bit)....R(16bit)(binary unsigned view) //  M(32bit)/N(16bit)=Q(32bit)...R(16bit) Binary unsigned view
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned long MM,MQ;
unsigned int MN,MR ;
unsigned int MTH ;
unsigned long MTL ;
main()
{
	unsigned char i ;
	//  測試資料(0x12345678/0x234)=?  (0x84354....0x168) //  test data (0x12345678/0x234)=?  (0x84354....0x168)

	MM=0x12345678;
	MN=0x234 ;
	
	F0=1 ;
	MTH=MN ;
	MTL=0 ;
	for(i=0 ; i < 32 ; i++){
	    // T <=T /2 
	    MTL >>= 1 ;
	    if(MTH&0x1){
		MTL |=0x80000000 ;
	    }
	    MTH >>=1 ;
	    MQ <<=1 ;
	    if((MTH ==0) && (MM >=  MTL)){
		MQ++ ;
		MM-=MTL ;
	    }
	}
	MR=MM ;
	F0=1 ;
	for(;;);
}
%}


@1
%{div32b.c
//
//  M(32bit)/N(16bit)=Q(32bit)....R(16bit)(binary unsigned view) //  M(32bit)/N(16bit)=Q(32bit)...R(16bit) Binary unsigned view
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned long MM,MQ;
unsigned int MN,MR ;
unsigned long MT ;
main()
{
	unsigned char i ;
	//  測試資料(0x12345678/0x234)=?  (0x84354....0x168) //  test data (0x12345678/0x234)=?  (0x84354....0x168)

	MM=0x12345678;
	MN=0x234 ;
	
	F0=1 ;
	MT=0 ;
	for(i=0 ; i < 32 ; i++){
	    // T <=T *2 
	    MT <<= 1 ;
	    if(MM&0x80000000){
		MT++ ;
	    }
	    MM <<=1 ;

	    MQ <<=1 ;
	    if(MT >=MN){
		MT-=MN ;
		MQ++ ;
	    }
	}
	MR=MT ;
	F0=1 ;
	for(;;);
}
%}


@1
%{div32c.c
//
//  M(32bit)/N(16bit)=Q(32bit)....R(16bit)(binary unsigned view) //  M(32bit)/N(16bit)=Q(32bit)...R(16bit) Binary unsigned view
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned long MM,MQ;
unsigned int MN,MR ;
main()
{
	//  測試資料(0x12345678/0x234)=?  (0x84354....0x168) //  test data (0x12345678/0x234)=?  (0x84354....0x168)

	MM=0x12345678;
	MN=0x234 ;
	
	F0=1 ;
	MQ=MM/MN ;
	MR=MM-MQ*MN ;
	F0=1 ;
	for(;;);
}
%}


@1
%{bz.c
//
//   配合"揚聲器實習板"//       P0.0 control ON/OFF Speaker operation 
//       P0.0所接的揚聲器順序發出Do~Si的音, 各音持續1秒鐘. //        Sequence sound Do~Si, each sound continue 1 sec..
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"

char code tbl1[]={19,17,15,14,12,11,10,9};
int code  tbl2[]={523,587,659,698,785,880,988,1047};
main()
{
	char j, t1;
	int  i, k, t2;

	P0 =0;
	
	for(i=0; i<8; i++){
	    t2=tbl2[i];
	    t1=tbl1[i];	
	    for(k=0; k<t2; k++){
		for(j=0; j<t1; j++){
		    Delay100us();
		}
		P0 = ~P0;
	    }
	}
	for(;;);
}
%}


@1
%{dac1.c
//
//  配合"DAC0800實習板"//
//   將指撥開關的設定值,送到DAC0800//   Read  the value setting in DIP Switch ,then send to the DAC0800
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
main()
{
	for(;;){
	    P0=~P1 ;
	}
}
%}


@1
%{dac2.c
//
//  配合"DAC0800實習板"//
//   由DAC0800送出SIN波形//   The DAC0800 send out SIN wave
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code sintbl[]= {
	128,167,203,231,249,
	255,249,231,203,167,
	127,88 , 52, 24,  6,
	0  ,6  , 24, 52, 88
} ;
main()
{
	char i ;
	for(;;){
	    for(i=0;i < 20;i++){
		P0=sintbl[i];
		Delay1ms() ;
	    }
	}
}
%}


%{dipsw1.a51
;
; 配合"指撥開關/8個LED實習板";
;   指撥開關的ON/OFF分別控制8個LED的亮/熄;   ON/OFF setting in DIP Switch control Light/Dark of 8 pieces of LED
;
START:
	MOV	A,P1
	CPL	A	;將Switch讀到的值做反相(0->1,1->0) ;complement switch setting value (0->1,1->0)
	MOV	P0,A
	AJMP	START
	END
%}


@1
%{dipsw1.c
//
//   配合"指撥開關/8個LED實習板"//
//    指撥開關的ON/OFF分別控制8個LED的亮/熄//    ON/OFF setting in DIP Switch control Light/Dark of 8 pieces of LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
main()
{
	for(;;){
	    P0=~P1 ;  //將Switch讀到的值做反相(0->1,1->0) //complement switch setting value(0->1,1->0)
	}
}
%}


%{dipsw2.a51
;
; 配合"指撥開關/8個LED實習板";
;   指撥開關所代表的數值控制8個LED計數的速度;   The value setting in DIP Switch control  8 pieces of LED counting speed
;
START:
	INC	P0
	MOV	A,P1
	CPL	A
	JZ	START
DLY1:
	ACALL	DELAY10MS
	DEC	A
	JNZ	DLY1
	AJMP	START

	$include (delay.inc)

	END
%}


@1
%{dipsw2.c
//
//   配合"指撥開關/8個LED實習板"//
//     指撥開關所代表的數值控制8個LED計數的速度//   The value setting in DIP Switch control  8 pieces of LED counting speed
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
main()
{
	unsigned char i;
	for(;;){
	    P0++ ;
	    for(i=0 ; i < ~P1 ; i++){
		Delay10ms() ;
	    }
	}
}
%}


%{dt1.a51
;
;   各種組譯指引(Directive);   Assembler Directive
%0,2 ;    配合EQU,示範內部資料記憶體的安置及位址設定;    using EQU
%1 ;    配合DSEG,DS或EQU,示範內部資料記憶體的安置及位址設定;    using DSEG,DS或EQU
;;  Demonstrate the assembler directive of reserved internal data memory
;
%1 	DSEG	AT 30H
%1 DT1:	DS	2
%1 DT2:	DS	1

TDT1	EQU	30H
TDT2	EQU	32H

%0,2 	ORG	0
%1 	CSEG

%1 	MOV	A,DT1
	MOV	A,TDT1
%1 	MOV	A,DT2
	MOV	A,TDT2
	END
%}


%{dt2.a51
;
;   各種組譯指引(Directive);   Assembler Directive
%0,2 ;       配合EQU,示範位元的安置及位址設定;       using EQU
%1 ;       配合BSEG,EQU,DBIT,示範位元的安置及位址設定;       using BSEG,EQU,DBIT
;;  Demonstrate the assembler directive of reserved bit data  memory
;
%1 	BSEG	AT 30H
%1 DT1:	DBIT	3
%1 DT2:	DBIT	1
TDT1	EQU	30H
%0,2 ADT1	REG	26h.0
%1 ADT1	EQU	26h.0
TDT2	EQU	33H
%0,2 ADT2	REG	26h.3
%1 ADT2	EQU	26h.3

%0,2 	ORG 0
%1 	CSEG
%1 	MOV	C,DT1
	MOV	C,TDT1
	MOV	C,ADT1
	MOV	C,26h.0
%1 	MOV	C,DT2
	MOV	C,TDT2
	MOV	C,ADT2
	MOV	C,26h.3
	END
%}


%{dt3.a51
;
;   各種組譯指引(Directive);   Assembler Directive
%0,2 ;       配合ORG,EQU,DB,DW,示範程式記憶體的安置及位址設定;       using ORG,EQU,DB,DW
%1 ;       配合CSEG,EQU,DB,DW,示範程式記憶體的安置及位址設定;       using CSEG,EQU,DB,DW
;; Demonstrate the assembler directive of  reserved program  memory
;
%0,2 	ORG	0
%1 	CSEG
	MOV	DPTR,#DT1
	MOV	DPTR,#TDT1
	MOV	DPTR,#DT2
	MOV	DPTR,#TDT2
TDT1	EQU	$
DT1:	DB	1,2,3,4
TDT2	EQU	$
DT2:	DW	1,2,3,4
	END
%}


%{dt4a.a51
;
;   各種組譯指引(Directive);   Assembler Directive
;       配合MACRO,MEND示範巨指令程式設計;       using MACRO,MEND
; ;   Demonstrate the assembler directive of MACRO design
;
%1 $GEN   ; generate macro list
ADD3	MACRO	T1,T2,T3
	MOV	A,T1
	ADD	A,T2
	ADD	A,T3
	ENDM

%0,2 	ORG	0
%1 	CSEG

	ADD3	10,11,12
	END
%}
%{dt4b.a51
;
;   各種組譯指引(Directive);   Assembler Directive
;       示範巨指令定義TM1內有標記LOOP, 由於TM1被呼叫兩次, ;       Demonstrate  the assembler directive of Local label in Macro design(error)
;       將使LOOP在程式內出現兩次造成標記LOOP重覆定義的錯誤;  because macro call TM1 2 times , so generate two label name LOOP
;
%1 $GEN   ; generate macro list

TM1	MACRO
LOOP:	NOP
	AJMP	LOOP
	ENDM


%0,2 	ORG	0
%1 	CSEG

	TM1
	TM1
	END
%}
%{dt4c.a51
;
;   各種組譯指引(Directive);   Assembler Directive
%0 ;       配合區域標記$n,示範包括有標記的巨指令程式設計;       local label $n
%1 ;       配合區域標記組譯指引LOCAL,示範包括有標記的巨指令程式設計;       using LOCAL
%2 ;       配合區域標記後加上#,示範包括有標記的巨指令程式設計;       local label suffix with #
; ;  Demonstrate  the assembler directive of Local label in Macro design
;
%1 $GEN   ; generate macro list

TM2	MACRO
%0 $1:	NOP
%0 	AJMP	$1
%1 	LOCAL	LOOP
%1 LOOP:	NOP
%1 	AJMP	LOOP
%2  LOOP#:	NOP
%2 	AJMP	LOOP#
	ENDM

%0,2 	ORG	0
%1 	CSEG

	TM2
	TM2
	END
%}


%{dt5.a51
;
;   各種組譯指引(Directive);   Assembler Directive
%0,2 ;       配合INCLUDE,示範含入檔案功能;       using INCLUDE
%1 ;       配合$INCLUDE,示範含入檔案功能;        using $INCLUDE
;;    Demonstrate  the assembler directive of include file
;
%1 $GEN  ; generate macro list
%0,2 	INCLUDE	dt5a.a51
%1 	$INCLUDE	(dt5a.a51)
%0,2 	ORG	0
%1 	CSEG
	ADD3	10,11,12
	END
%}


%{dt5a.a51
ADD3	MACRO	T1,T2,T3
	MOV	A,T1
	ADD	A,T2
	ADD	A,T3
	ENDM
%}


%{dt6a.a51
;
;   各種組譯指引(Directive);   Assembler Directive
;       配合PUBLIC,EXTRN,示範多檔案連結功能;       using PUBLIC,EXTRN
;;    Demonstrate  the assembler directive of linking  Multiple files
%0,2 ;      此組譯程式不提供此能力;      no such function for  this assembler
;
%1 	DSEG	AT	30H
%1 	PUBLIC   DT1
%1 DT1:	DS	1
%1 	CSEG	AT 200H
%1 	PUBLIC	SUB1,SUB2
%1 SUB1:
%1 	NOP
%1 	RET
%1 SUB2: NOP
%1 	RET
%1 	END
%}


%{dt6b.a51
;
;   各種組譯指引(Directive);   Assembler Directive
;       示範PUBLIC,EXTRN;       using PUBLIC,EXTRN
;;    Demonstrate  the assembler directive of linking  Multiple files
%0,2 ;      此組譯程式不提供此能力;      no such function for  this assembler
;
%1 	CSEG	AT   0
%1 	EXTRN	CODE(SUB1),CODE(SUB2),DATA(DT1)
%1 	LCALL	SUB1
%1 	LCALL	SUB2
%1 	MOV	A,DT1
%1 	END
%}


@1
%{dism1.c
//
//  配合"反組譯程式實習"//
//   鍵盤掃瞄所得到的按鍵顯示在LCD字幕上//   Get keycode from keyboard ,then display on Text LCD
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
void delay20ms() ;
unsigned char code IdxCol[]= {
	0 , 1 , 0 , 2 ,
	0 , 1 , 0 , 3 ,
	0 , 1 , 0 , 2 ,
	0 , 1 , 0 , 4
} ;
char code *keycode[]= {
	"0","1","2","3" ,
	"4","5","6","7" ,
	"8","9","A","B" ,
	"C","D","E","F" ,
	"F1","F2","F3","CR" ,
} ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0設定為輸入埠// P0 set to input port
	do{
	    RS=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0
}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
main()
{
	unsigned char row ;
	char keyflag ;
	char tP1 ;
	char key ;
	char code *ptr ;

	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // 採用8位元資料存取/雙列字/5*10點矩陣字型// 8 bits data length/2 lines/5*10 dots
	Command(0xe) ;     //顯示器ON/游標被顯示在位址計數器// display ON
	Command(0x1) ;     // 清除全螢幕// clear display
	Command(0x80) ;    // 設定DD RAM位址為0---->第一行的第一位置// DD RAM address  is  0
	for(;;){
	    do{
		for(P1=tP1=0xf7,row=0 ,keyflag=0 ; (row < 5);row++){
		    if((P2&0xf) != 0xf){
			keyflag=1 ;
			break ;
		    }
		    tP1 <<=1 ;
		    tP1 |=0x7 ;
		    P1=tP1 ;
		}
		if(keyflag== 1){
		    delay20ms() ;
		    if((P2&0xf) ==0xf){
			keyflag= 0 ;
		    }
		}
	    }
	    while(keyflag==0) ;
	    key=row*4+IdxCol[P2&0xf];
	    do{
		while((P2&0xf) != 0xf) ;
		delay20ms() ;
	    }
	    while((P2 &  0xf) != 0xf) ;
	    ptr= keycode[key] ;
	    while(*ptr !=0){
		Data(*ptr++);
	    }
	}
}
void delay20ms()
{
	char i ;
	for(i=0 ; i < 2 ;i++) Delay10ms();
}
%}


%{dotmtx1a.a51
;
; 配合"8*8單色點矩陣LED實習板";
;   在8*8單色點矩陣LED上顯示中文字---"大";   Display Chinese word "da" on 8*8 Mono Dot-matrix LED
;
START:
	MOV	R2,#0
	MOV	R4,#080H
	MOV	DPTR,#DAI
LOOP:
	MOV	P1,#0FFH   ;  關閉共陽;  OFF common anode
	MOV	A,R2
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R2

	MOV	A,R4
	XRL	A,#0FFH
	MOV	P1,A

	MOV	A,R4
	RR	A
	MOV	R4,A

	CJNE	R2,#8,DELAY
	MOV	R2,#0
;	MOV	R4,#080H

DELAY:
	MOV	R3,#3
NEXT2:
	ACALL	DELAY1MS
	DJNZ	R3,NEXT2

	AJMP  	LOOP

%0,2 	include	delay.inc
%1 	$include	(delay.inc)

DAI:
	DB	0FDH,0DBH,0D7H,00FH,0D7H
	DB	0DBH,0DDH,0FFH
	END

%}


%{dotmtx1b.a51
;
; 配合"8*8單色點矩陣LED實習板";
;   在8*8單色點矩陣LED上顯示中文字---"大";   Display Chinese word "da" on 8*8 Mono Dot-matrix LED
;
START:
	MOV	R2,#0
	MOV	R4,#07FH
	MOV	DPTR,#DAI
LOOP:
	MOV	P1,#0FFH   ;  關閉共陽;  OFF common anode
	MOV	A,R2
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R2

	MOV	A,R4
	MOV	P1,A

	RR	A
	MOV	R4,A

	CJNE	R2,#8,DELAY
	MOV	R2,#0

DELAY:
	MOV	R3,#3
NEXT2:
	ACALL	DELAY1MS
	DJNZ	R3,NEXT2

	AJMP  LOOP

%0,2 	include	delay.inc
%1 	$include	(delay.inc)

DAI:
	DB	0FDH,0DBH,0D7H,00FH,0D7H
	DB	0DBH,0DDH,0FFH
	END
%}


%{dotmtx1c.a51
;
; 配合"8*8單色點矩陣LED實習板";
;   在8*8單色點矩陣LED上顯示中文字---"大";   Display Chinese word "da" on 8*8 Mono Dot-matrix LED
;
START:
	MOV	R4,#07FH
	MOV	DPTR,#DAI
LOOP:
	MOV	P1,#0FFH   ;  關閉共陽;  OFF common anode
	CLR	A
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	DPTR

	MOV	A,R4
	MOV	P1,A

	RR	A
	MOV	R4,A

	CJNE	A,#07FH,DELAY
	MOV	DPTR,#DAI

DELAY:
	MOV	R3,#3
NEXT2:
	ACALL 	DELAY1MS
	DJNZ	R3,NEXT2

	AJMP	LOOP

%0,2 	include	delay.inc
%1 	$include	(delay.inc)

DAI:
	DB	0FDH,0DBH,0D7H,00FH,0D7H
	DB	0DBH,0DDH,0FFH
	END
%}


@1
%{dotmtx1a.c
//
//  配合"8*8單色點矩陣LED實習板"//
//   在8*8單色點矩陣LED上顯示中文字---"大"//   Display Chinese word "da" on 8*8 Mono Dot-matrix LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code dai[]= { 0xfd,0xdb,0xd7,0x0f,0xd7,0xdb,0xdd,0xff} ;
delay3ms()
{
	Delay1ms() ;
	Delay1ms() ;
	Delay1ms() ;
}
main()
{
	unsigned char com ,idx;

	com=0x80 ;
	idx=0 ;
	for( ;;){
	    P1=0xff ;
	    P0=dai[idx++] ;
	    P1=~com ;
	    com >>=1 ;
	    if(idx==8){
   		idx=0;
		com=0x80 ;
	    }
	    delay3ms() ;
	}
}
%}


@1
%{dotmtx1b.c
//
//  配合"8*8單色點矩陣LED實習板"//
//   在8*8單色點矩陣LED上顯示中文字---"大"//   Display Chinese word "da" on 8*8 Mono Dot-matrix LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code dai[]= { 0xfd,0xdb,0xd7,0x0f,0xd7,0xdb,0xdd,0xff} ;
delay3ms()
{
	Delay1ms() ;
	Delay1ms() ;
	Delay1ms() ;
}
main()
{
	unsigned char com ;
	unsigned char code *ptr =dai;


	com=0x80 ;
	for( ;;){
	    P1=0xff ;
	    P0=*ptr++ ;
	    P1=~com ;
	    com >>=1 ;
	    if(com==0){
		com=0x80 ;
		ptr= dai ;
	    }
	    delay3ms() ;
	}
}
%}


%{dotmtx2a.a51
;
; 配合"8*8彩色點矩陣LED實習板"//
;   在8*8彩色點矩陣LED上依序顯示三種顏色的中文字---"大";   Display Chinese word "da" (three color) on 8*8 Color Dot-matrix LED
;
INTERVAL	EQU	25
INTERVAL1	EQU	INTERVAL*1
INTERVAL2	EQU	INTERVAL*2
INTERVAL3	EQU	INTERVAL*3

START:
	MOV	R2,#0      ;idx
	MOV	R4,#07FH   ;com
	MOV	R5,#0      ;interval
	MOV	R6,#0      ;color
	MOV	DPTR,#DAI
LOOP:
	MOV	P1,#0FFH   ;  關閉共陽;  OFF common anode
	CJNE	R6,#0,CHKCOLOR1
	SJMP	CHKCOLOR2
CHKCOLOR1:
	CJNE	R6,#2,CHKCOLOR3
CHKCOLOR2:
	MOV	A,R2
	MOVC	A,@A+DPTR
	MOV	P0,A
	SJMP	CHKCOLOR4
CHKCOLOR3:
	MOV	P0,#0FFH
CHKCOLOR4:

	CJNE	R6,#1,CHKCOLOR5
	SJMP	CHKCOLOR6
CHKCOLOR5:
	CJNE	R6,#2,CHKCOLOR7
CHKCOLOR6:
	MOV	A,R2
	MOVC	A,@A+DPTR
	MOV	P2,A
	SJMP	CHKCOLOR8
CHKCOLOR7:
	MOV	P2,#0FFH
CHKCOLOR8:
	INC	R2

	MOV	A,R4
	MOV	P1,A

	RR	A
	MOV	R4,A



	CJNE	R2,#8,CHKINTERVAL
	MOV	R2,#0
	INC	R5

CHKINTERVAL:
	CJNE	R5,#INTERVAL1,CHKINTERVAL1
	MOV	R6,#1
	SJMP	DELAY
CHKINTERVAL1:
	CJNE	R5,#INTERVAL2,CHKINTERVAL2
	MOV	R6,#2
	SJMP	DELAY
CHKINTERVAL2:
	CJNE	R5,#INTERVAL3,DELAY
	MOV	R5,#0
	MOV	R6,#0

DELAY:
	MOV	R3,#3
NEXT2:
	ACALL	DELAY1MS
	DJNZ	R3,NEXT2

	AJMP	LOOP
%0,2 	include	delay.inc
%1 	$include	(delay.inc)

DAI:
	DB	0FDH,0DBH,0D7H,00FH,0D7H
	DB	0DBH,0DDH,0FFH
	END
%}


%{dotmtx2b.a51
;
; 配合"8*8彩色點矩陣LED實習板";
;   在8*8彩色點矩陣LED上依序顯示三種顏色的中文字---"大";   Display Chinese word "da" (three color) on 8*8 Color Dot-matrix LED
;
BASEINT	EQU	25
INTERVAL1	EQU	BASEINT*1
INTERVAL2	EQU	BASEINT*2
INTERVAL3	EQU	BASEINT*3
IDX	REGEQU	R2
COM	REGEQU	R4
INTERVAL	REGEQU	R5
COLOR	REGEQU	R6
DELAYCNT	REGEQU	R3

START:
	MOV	IDX,#0
	MOV	COM,#07FH
	MOV	INTERVAL,#0
	MOV	COLOR,#0
	MOV	DPTR,#DAI
LOOP:
	MOV	P1,#0FFH   ;  關閉共陽;  OFF common anode
	CJNE	COLOR,#0,CHKCOLOR1
	SJMP	CHKCOLOR2
CHKCOLOR1:
	CJNE	COLOR,#2,CHKCOLOR3
CHKCOLOR2:
	MOV	A,IDX
	MOVC	A,@A+DPTR
	MOV	P0,A
	SJMP	CHKCOLOR4
CHKCOLOR3:
	 MOV	P0,#0FFH
CHKCOLOR4:

	CJNE	COLOR,#1,CHKCOLOR5
	SJMP	CHKCOLOR6
CHKCOLOR5:
	CJNE	COLOR,#2,CHKCOLOR7
CHKCOLOR6:
	MOV	A,IDX
	MOVC	A,@A+DPTR
	MOV	P2,A
	SJMP	CHKCOLOR8
CHKCOLOR7:
	MOV	P2,#0FFH
CHKCOLOR8:
	INC	IDX

	MOV	A,COM
	MOV	P1,A

	RR	A
	MOV	COM,A



	CJNE	IDX,#8,CHKINTERVAL
	MOV	IDX,#0
	INC	INTERVAL

CHKINTERVAL:
	CJNE	INTERVAL,#INTERVAL1,CHKINTERVAL1
	MOV	COLOR,#1
	SJMP	DELAY
CHKINTERVAL1:
	CJNE	INTERVAL,#INTERVAL2,CHKINTERVAL2
	MOV	COLOR,#2
	SJMP	DELAY
CHKINTERVAL2:
	CJNE	INTERVAL,#INTERVAL3,DELAY
	MOV	INTERVAL,#0
	MOV	COLOR,#0

DELAY:
	MOV	DELAYCNT,#3
NEXT2:
	ACALL	DELAY1MS
	DJNZ	DELAYCNT,NEXT2

	AJMP	LOOP

%0,2 	include	delay.inc
%1 	$include	(delay.inc)

DAI:
	DB	0FDH,0DBH,0D7H,00FH,0D7H
	DB	0DBH,0DDH,0FFH
	END
%}


@1
%{dotmtx2.c
//
//  配合"8*8彩色點矩陣LED實習板"//
//   在8*8彩色點矩陣LED上依序顯示三種顏色的中文字---"大"//   Display Chinese word "da" (three color) on 8*8 Color Dot-matrix LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code dai[]= { 0xfd,0xdb,0xd7,0x0f,0xd7,0xdb,0xdd,0xff} ;
#define BASEINT	25
#define INTERVAL1	BASEINT*1
#define INTERVAL2	BASEINT*2
#define INTERVAL3	BASEINT*3
delay3ms()
{
	Delay1ms() ;
	Delay1ms() ;
	Delay1ms() ;
}
main()
{
	char idx ;
	unsigned char com ;
	unsigned int interval ;
	unsigned char color ;
	idx=0 ;
	com=0x80 ;
	interval=0 ;
	color=0 ;
	for( ; ;){
	    P1=0xff ;
	    if((color== 0) || (color== 2)){
 		P0=dai[idx] ;
	    }
	    else{
		P0=0xff ;
	    }
	    if((color == 1) || (color== 2)){
		P2=dai[idx] ;
	    }
	    else{
		P2=0xff ;
	    }
	    idx++ ;
	    P1=~com ;
	    com >>=1 ;
	    if(idx >=8){
		interval++ ;
		idx=0 ;
		com=0x80 ;
	    }
	    if(interval ==  INTERVAL1){
		color=1 ;
	    }
	    else if(interval == INTERVAL2){
		color=2 ;
	    }
	    else if(interval == INTERVAL3){
		interval=0 ;
		color=0 ;
	    }
	    delay3ms() ;
	}
}
%}


%{dotmtx3.a51
;
; 配合"4個8*8彩色點矩陣LED實習板";
;   在16*16彩色點矩陣LED上依序顯示三種顏色的中文字---"歡";   Display Chinese word "huan" (three color) on 16*16 Color Dot-matrix LED
;
BASEINT	EQU	25
INTERVAL1	EQU	BASEINT*1
INTERVAL2	EQU	BASEINT*2
INTERVAL3	EQU	BASEINT*3

IDX	REGEQU	R2
INTERVAL	REGEQU	R5
COLOR	REGEQU	R6
CTRLLED	REGEQU	P2.0
LRED1	REGEQU	P1.4
LGREEN1	REGEQU	P1.5
LRED2	REGEQU	P1.6
LGREEN2	REGEQU	P1.7

START:
	MOV	IDX,#0
	MOV	INTERVAL,#0
	MOV	COLOR,#0
	MOV	DPTR,#HWAN
LOOP:
	SETB	CTRLLED
	CJNE	COLOR,#0,CHKCOLOR1
	SJMP	CHKCOLOR2
CHKCOLOR1:
	CJNE	COLOR,#2,CHKCOLOR3
CHKCOLOR2:
	MOV	A,IDX
	ADD	A,ACC
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	LRED1
	SETB	LRED1

	MOV	A,IDX
	ADD	A,ACC
	INC	A
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	LRED2
	SETB	LRED2
	SJMP	CHKCOLOR4
CHKCOLOR3:
	MOV	P0,#0FFH
	CLR	LRED1
	SETB	LRED1
	CLR	LRED2
	SETB	LRED2
CHKCOLOR4:

	CJNE	COLOR,#1,CHKCOLOR5
	SJMP	CHKCOLOR6
CHKCOLOR5:
	CJNE	COLOR,#2,CHKCOLOR7
CHKCOLOR6:
	MOV	A,IDX
	ADD	A,ACC
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	LGREEN1
	SETB	LGREEN1

	MOV	A,IDX
	ADD	A,ACC
	INC	A
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	LGREEN2
	SETB	LGREEN2
	SJMP	CHKCOLOR8
CHKCOLOR7:
	MOV	P0,#0FFH
	CLR	LGREEN1
	SETB	LGREEN1
	CLR	LGREEN2
	SETB	LGREEN2
CHKCOLOR8:
	MOV	A,P1
	ANL	A,#0F0H
	ORL	A,IDX
	MOV	P1,A
	CLR	CTRLLED

	INC	IDX

	CJNE	IDX,#16,CHKINTERVAL
	MOV	IDX,#0
	INC	INTERVAL

CHKINTERVAL:
	CJNE	INTERVAL,#INTERVAL1,CHKINTERVAL1
	MOV	COLOR,#1
	SJMP	DELAY
CHKINTERVAL1:
	CJNE	INTERVAL,#INTERVAL2,CHKINTERVAL2
	MOV	COLOR,#2
	SJMP	DELAY
CHKINTERVAL2:
	CJNE	INTERVAL,#INTERVAL3,DELAY
	MOV	INTERVAL,#0
	MOV	COLOR,#0

DELAY:
	ACALL	DELAY1MS

	AJMP	LOOP

%0,2 	include	delay.inc
%1 	$include	(delay.inc)

HWAN:
	DB	0FFH,0FFH
	DB	0DFH,0EFH
	DB	0D1H,09FH
	DB	084H,000H
	DB	0D1H,055H
	DB	0DEH,055H
	DB	0D1H,001H
	DB	085H,055H
	DB	0D1H,055H
	DB	0DEH,0FEH
	DB	0F9H,0F9H
	DB	087H,0E7H
	DB	0B4H,01FH
	DB	0F7H,0E7H
	DB	0F5H,0F9H
	DB	0E3H,0FEH
	END
%}


@1
%{dotmtx3.c
//
//  配合"4個8*8彩色點矩陣LED實習板"//
//   在16*16彩色點矩陣LED上依序顯示三種顏色的中文字---"歡"//   Display Chinese word "huan" (three color) on 16*16 Color Dot-matrix LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code hwan[]= {
	0xFF,0xFF,
	0xDF,0xEF,
	0xD1,0x9F,
	0x84,0x00,
	0xD1,0x55,
	0xDE,0x55,
	0xD1,0x01,
	0x85,0x55,
	0xD1,0x55,
	0xDE,0xFE,
	0xF9,0xF9,
	0x87,0xE7,
	0xB4,0x1F,
	0xF7,0xE7,
	0xF5,0xF9,
	0xE3,0xFE,
} ;
sbit CTRLLED= P2^0 ;
sbit LRED1=P1^4 ;
sbit LGREEN1=P1^5 ;
sbit LRED2=P1^6 ;
sbit LGREEN2=P1^7 ;
#define BASEINT	25
#define INTERVAL1	BASEINT*1
#define INTERVAL2	BASEINT*2
#define INTERVAL3	BASEINT*3
main()
{
	char idx ;
	unsigned int interval ;
	unsigned char color ;
	idx=0 ;
	interval=0 ;
	color=0 ;
	for( ; ;){
	    CTRLLED=1 ;
	    if((color== 0) || (color== 2)){
 		P0=hwan[idx*2] ;
		LRED1=0 ;
		LRED1=1 ;
		P0=hwan[idx*2+1] ;
		LRED2=0 ;
		LRED2=1 ;
	    }
	    else{
		P0=0xff ;
		LRED1=0 ;
		LRED1=1 ;
		LRED2=0 ;
		LRED2=1 ;
	    }
	    if((color == 1) || (color== 2)){
 		P0=hwan[idx*2] ;
		LGREEN1=0 ;
		LGREEN1=1 ;
		P0=hwan[idx*2+1] ;
		LGREEN2=0 ;
		LGREEN2=1 ;
	    }
	    else{
		P0=0xff ;
		LGREEN1=0 ;
		LGREEN1=1 ;
		LGREEN2=0 ;
		LGREEN2=1 ;
	    }
	    P1 &=0xf0 ;
	    P1 |=idx ;
	    CTRLLED=0 ;
	    idx++ ;
	    if(idx >=16){
		interval++ ;
		idx=0 ;
	    }
	    if(interval ==  INTERVAL3){
		interval=0 ;
		color=0 ;
	    }
	    else if(interval == INTERVAL2){
		color=2 ;
	    }
	    else if(interval == INTERVAL1){
		color=1 ;
	    }
 	    Delay1ms() ;
	}
}
%}


%{dotmtx4.a51
;
; 配合"4個8*8彩色點矩陣LED實習板";   Display Chinese word on 16*16 Color Dot-matrix LED,
;   在16*16彩色點矩陣LED上依序顯示紅色的"歡",綠色的"迎",橙色的"參"紅色的"觀"; sequence by Chinese word "huan"(red),Chinese word "ying"(green),
; ;    Chinese word "can"(orange) , Chinese word "guan"(red)
;
BASEINT	EQU	25
INTERVAL1	EQU	BASEINT*1
INTERVAL2	EQU	BASEINT*2
INTERVAL3	EQU	BASEINT*3
INTERVAL4	EQU	BASEINT*4

IDX	REGEQU	R2
INTERVAL	REGEQU	R5
COLOR	REGEQU	R6
WOFFSET	REGEQU	R4
CTRLLED	REGEQU	P2.0
LRED1	REGEQU	P1.4
LGREEN1	REGEQU	P1.5
LRED2	REGEQU	P1.6
LGREEN2	REGEQU	P1.7

START:
	MOV	IDX,#0
	MOV	WOFFSET,#0
	MOV	INTERVAL,#0
	MOV	COLOR,#0
	MOV	DPTR,#HWAN
LOOP:
	SETB	CTRLLED
	CJNE	COLOR,#0,CHKCOLOR1
	SJMP	CHKCOLOR2
CHKCOLOR1:
	CJNE	COLOR,#2,CHKCOLOR3
CHKCOLOR2:
	MOV	A,IDX
	ADD	A,ACC
	ADD	A,WOFFSET
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	   LRED1
	SETB	LRED1

	MOV	A,IDX
	ADD	A,ACC
	ADD	A,WOFFSET
	INC	A
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	LRED2
	SETB	LRED2
	SJMP	CHKCOLOR4
CHKCOLOR3:
	MOV	P0,#0FFH
	CLR	LRED1
	SETB	LRED1
	CLR	LRED2
	SETB	LRED2
CHKCOLOR4:

	CJNE	COLOR,#1,CHKCOLOR5
	SJMP	CHKCOLOR6
CHKCOLOR5:
	CJNE	COLOR,#2,CHKCOLOR7
CHKCOLOR6:
	MOV	A,IDX
	ADD	A,ACC
	ADD	A,WOFFSET
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	LGREEN1
	SETB	LGREEN1

	MOV	A,IDX
	ADD	A,ACC
	ADD	A,WOFFSET
	INC	A
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	LGREEN2
	SETB	LGREEN2
	SJMP	CHKCOLOR8
CHKCOLOR7:
	MOV	P0,#0FFH
	CLR	LGREEN1
	SETB	LGREEN1
	CLR	LGREEN2
	SETB	LGREEN2
CHKCOLOR8:
	MOV	A,P1
	ANL	A,#0F0H
	ORL	A,IDX
	MOV	P1,A
	CLR	CTRLLED

	INC	IDX

	CJNE	IDX,#16,CHKINTERVAL
	MOV	IDX,#0
	INC	INTERVAL

CHKINTERVAL:
	CJNE	INTERVAL,#INTERVAL1,CHKINTERVAL1
	MOV	COLOR,#1
	MOV	WOFFSET,#1*32
	SJMP	DELAY
CHKINTERVAL1:
	CJNE	INTERVAL,#INTERVAL2,CHKINTERVAL2
	MOV	COLOR,#2
	MOV	WOFFSET,#2*32
	SJMP	DELAY
CHKINTERVAL2:
	CJNE	INTERVAL,#INTERVAL3,CHKINTERVAL3
	MOV	COLOR,#0
	MOV	WOFFSET,#3*32
	SJMP	DELAY
CHKINTERVAL3:
	CJNE	INTERVAL,#INTERVAL4,DELAY
	MOV	INTERVAL,#0
	MOV	COLOR,#0
	MOV	WOFFSET,#0

DELAY:
	ACALL	DELAY1MS
	AJMP	LOOP

%0,2 	include	delay.inc
%1 	$include	(delay.inc)

HWAN:
	DB	0FFH,0FFH         ;歡;'huan'
	DB	0DFH,0EFH
	DB	0D1H,09FH
	DB	084H,000H
	DB	0D1H,055H
	DB	0DEH,055H
	DB	0D1H,001H
	DB	085H,055H
	DB	0D1H,055H
	DB	0DEH,0FEH
	DB	0F9H,0F9H
	DB	087H,0E7H
	DB	0B4H,01FH
	DB	0F7H,0E7H
	DB	0F5H,0F9H
	DB	0E3H,0FEH

	DB	0FFH,0FFH             ;迎;'ying'
	DB	0F7H,0BEH
	DB	0BBH,0B9H
	DB	0DBH,007H
	DB	0DFH,0BBH
	DB	0FFH,0DDH
	DB	080H,00DH
	DB	0DFH,0DEH
	DB	0BFH,0BEH
	DB	0BFH,07EH
	DB	0FFH,0FEH
	DB	080H,002H
	DB	0DFH,0DEH
	DB	0DFH,0CEH
	DB	080H,01DH
	DB	0DFH,0FDH


	DB	0FFH,0FFH             ;參;'can'
	DB	0FDH,0BFH
	DB	0FCH,0ABH
	DB	0E9H,0AAH
	DB	0E5H,06AH
	DB	0EDH,056H
	DB	08BH,055H
	DB	0ACH,0B5H
	DB	0EEH,0ADH
	DB	0ADH,06BH
	DB	0D9H,05BH
	DB	0E5H,057H
	DB	0FDH,0B7H
	DB	0FBH,0BFH
	DB	0FCH,0BFH
	DB	0FFH,0BFH


	DB	0FFH,0FFH       ;觀;'guan'
	DB	0D1H,0DFH
	DB	085H,000H
	DB	0D0H,055H
	DB	0DFH,055H
	DB	0D1H,001H
	DB	084H,055H
	DB	0D1H,055H
	DB	0FFH,0FEH
	DB	080H,01DH
	DB	0D6H,0C3H
	DB	0D6H,0DFH
	DB	0D6H,0C1H
	DB	080H,01EH
	DB	0DFH,0F0H
	DB	0FFH,0FDH


	END
%}


@1
%{dotmtx4.c
//
//  配合"4個8*8彩色點矩陣LED實習板"//   Display Chinese word on 16*16 Color Dot-matrix LED,
//   在16*16彩色點矩陣LED上依序顯示紅色的"歡",綠色的"迎",橙色的"參"紅色的"觀"//  sequence by Chinese word "huan"(red),Chinese word "ying"(green),
////    Chinese word "can"(orange) , Chinese word "guan"(red)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code hwan[]= {
	0xFF,0xFF,              //歡//'huan'
	0xDF,0xEF,
	0xD1,0x9F,
	0x84,0x00,
	0xD1,0x55,
	0xDE,0x55,
	0xD1,0x01,
	0x85,0x55,
	0xD1,0x55,
	0xDE,0xFE,
	0xF9,0xF9,
	0x87,0xE7,
	0xB4,0x1F,
	0xF7,0xE7,
	0xF5,0xF9,
	0xE3,0xFE,

	0xFF,0xFF,              //迎//'ying'
	0xF7,0xBE,
	0xBB,0xB9,
	0xDB,0x07,
	0xDF,0xBB,
	0xFF,0xDD,
	0x80,0x0D,
	0xDF,0xDE,
	0xBF,0xBE,
	0xBF,0x7E,
	0xFF,0xFE,
	0x80,0x02,
	0xDF,0xDE,
	0xDF,0xCE,
	0x80,0x1D,
	0xDF,0xFD,


	0xFF,0xFF,              //參//'can'
	0xFD,0xBF,
	0xFC,0xAB,
	0xE9,0xAA,
	0xE5,0x6A,
	0xED,0x56,
	0x8B,0x55,
	0xAC,0xB5,
	0xEE,0xAD,
	0xAD,0x6B,
	0xD9,0x5B,
	0xE5,0x57,
	0xFD,0xB7,
	0xFB,0xBF,
	0xFC,0xBF,
	0xFF,0xBF,


	0xFF,0xFF,        //觀//'guan'
	0xD1,0xDF,
	0x85,0x00,
	0xD0,0x55,
	0xDF,0x55,
	0xD1,0x01,
	0x84,0x55,
	0xD1,0x55,
	0xFF,0xFE,
	0x80,0x1D,
	0xD6,0xC3,
	0xD6,0xDF,
	0xD6,0xC1,
	0x80,0x1E,
	0xDF,0xF0,
	0xFF,0xFD,

} ;
sbit CTRLLED= P2^0 ;
sbit LRED1=P1^4 ;
sbit LGREEN1=P1^5 ;
sbit LRED2=P1^6 ;
sbit LGREEN2=P1^7 ;
#define BASEINT	25
#define INTERVAL1	BASEINT*1
#define INTERVAL2	BASEINT*2
#define INTERVAL3	BASEINT*3
#define INTERVAL4	BASEINT*4
main()
{
	char idx ;
	unsigned int interval ;
	unsigned char color ;
	unsigned char woffset ;
	idx=0 ;
	woffset=0 ;
	interval=0 ;
	color=0 ;
	for( ; ;){
	    CTRLLED=1 ;
	    if((color== 0) || (color== 2)){
 		P0=hwan[woffset+idx*2] ;
		LRED1=0 ;
		LRED1=1 ;
		P0=hwan[woffset+idx*2+1] ;
		LRED2=0 ;
		LRED2=1 ;
	    }
	    else{
		P0=0xff ;
		LRED1=0 ;
		LRED1=1 ;
		LRED2=0 ;
		LRED2=1 ;
	    }
	    if((color == 1) || (color== 2)){
 		P0=hwan[woffset+idx*2] ;
		 LGREEN1=0 ;
		LGREEN1=1 ;
		P0=hwan[woffset+idx*2+1] ;
		LGREEN2=0 ;
		LGREEN2=1 ;
	    }
	    else{
		P0=0xff ;
		LGREEN1=0 ;
		LGREEN1=1 ;
		LGREEN2=0 ;
		LGREEN2=1 ;
	    }

	    P1 &=0xf0 ;
	    P1 |=(idx &0xf);
	    CTRLLED=0 ;
	    idx++ ;
	    if(idx ==16){
		interval++ ;
		idx=0 ;
	    }
	    if(interval ==  INTERVAL1){
		color=1 ;
		woffset=1*32 ;
	    }
	    else if(interval == INTERVAL2){
		color=2 ;
		woffset=2*32 ;
	    }
	    else if(interval == INTERVAL3){
		color=0 ;
		woffset=3*32 ;
	    }
	    else if(interval == INTERVAL4){
		interval=0 ;
		color=0 ;
		woffset=0 ;
	    }
	    Delay1ms() ;
	}
}
%}


@1
%{dotmtx71.c
//
//  配合"5*7單色點矩陣LED實習板"//
//   在5*7單色點矩陣LED上顯示中文字---"大"//   Display Chinese word "da" on 5*7 Mono Dot-matrix LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code dai[]= { 0x6d,0x6b,0x07,0x6b,0x6d} ;
delay3ms()
{
	Delay1ms() ;
	Delay1ms() ;
	Delay1ms() ;
}
main()
{
	unsigned char com ,idx;

	com=0x10 ;
	idx=0 ;
	for( ;;){
	    P1=0xff ;
	    P0=dai[idx++] ;
	    P1=~com ;
	    com >>=1 ;
	    if(idx==5){
		idx=0;
		com=0x10 ;
	    }
	    delay3ms() ;
	}
}
%}


@1
%{e93c461.c
//
//  配合"EEPROM 93C46實習板"//
//   讀取93C46位址00的內容//   Read the content of 93C46 at address 00
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit EEPROMCS=P0 ^0 ;
sbit EEPROMSK=P0 ^1 ;
sbit EEPROMDI=P0 ^2 ;
sbit EEPROMDO=P0 ^3 ;
#define CLOCK  EEPROMSK=0 ; EEPROMSK=1 ;
#define SEND(DI)   EEPROMDI=DI ;CLOCK ;
main()
{
	unsigned int Data ;
	unsigned char i ;

	P0=0xff ;
	//  設定 CS,SK 到初值//  Setting CS,SK to initial state
EEPROMCS=0 ;
EEPROMSK=0 ;

	EEPROMCS=1 ;
	// 啟始位元// start bit
	SEND(1) ;
	// 指令  10// command  10
	SEND(1) ; SEND(0) ;
	// 位址 000000// address 000000
	for(i=0 ; i < 6 ; i++){
	    SEND(0) ;
	}
	if(EEPROMDO==0){
	    Data=0 ;
	    for(i=0 ; i < 16 ; i++){
		CLOCK ;
		Data <<=1 ;
		if(EEPROMDO== 1){
		    Data++ ;
		}
	    }
	}
	EEPROMCS=0 ;
	for(;;) ;
}
%}


@1
%{e93c462.c
//
//  配合"EEPROM 93C46實習板"//
//   寫入一數值(5678h)到93C46的位址00//   Write the value (5678h) to  93C46 at address 00
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit EEPROMCS=P0 ^0 ;
sbit EEPROMSK=P0 ^1 ;
sbit EEPROMDI=P0 ^2 ;
sbit EEPROMDO=P0 ^3 ;
#define CLOCK  EEPROMSK=0 ; EEPROMSK=1 ;
#define SEND(DI)   EEPROMDI=DI ;CLOCK ;
main()
{
	unsigned int Data ;
	unsigned char i ;

	P0=0xff ;
	//  設定 CS,SK 到初值//  Setting CS,SK to initial state
EEPROMCS=0 ;
EEPROMSK=0 ;
	// 使寫入致能// write enable
	EEPROMCS=1 ;
	// 啟始位元// start bit
	SEND(1) ;
	// 指令  00// command  00
	SEND(0) ; SEND(0) ;
	// 次指令 11// sub-command 11
	SEND(1) ; SEND(1) ;
	// 4-'X' Bit
	for(i=0 ; i < 4 ; i++){
	    SEND(0) ;
	}
	EEPROMCS=0 ;


	//  寫入一數值(5678h)到93C46的位址(00) //  Write the value (5678h) to  93C46 at address 00
	EEPROMCS=1 ;
	// 啟始位元// start bit
	SEND(1) ;
	// 指令  01// command  01
	SEND(0) ; SEND(1) ;
	// 位址 000000// address 000000
	for(i=0 ; i < 6 ; i++){
	    SEND(0) ;
	}
	// 送出資料// send out data
	Data=0x5678 ;
	for(i=0 ; i < 16 ; i++){
	    if(Data & 0x8000){
		SEND(1) ;
	    }
	    else{
		SEND(0) ;
	    }
	    Data <<=1 ;
	}
	EEPROMCS=0 ;
	// 等待備用// wait ready
	EEPROMCS=1 ;
	while(!EEPROMDO){
	    CLOCK ;
	}

	// 使寫入除能//write disable
	EEPROMCS=1 ;
	// 啟始位元//Start bit
	SEND(1) ;
	// 指令  00// command 00
	SEND(0) ; SEND(0) ;
	// 次指令 00// sub-command 00
	SEND(0) ; SEND(0) ;
	for(i=0 ; i < 4 ; i++){
	    SEND(0) ;
	}
	EEPROMCS=0 ;

	for(;;) ;
}
%}


@1
%{e93c661.c
//
//  配合"EEPROM 93C66實習板"//
//   讀取93C66位址00的內容//   Read the content of 93C66 at address 00
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit EEPROMCS=P0 ^0 ;
sbit EEPROMSK=P0 ^1 ;
sbit EEPROMDI=P0 ^2 ;
sbit EEPROMDO=P0 ^3 ;
#define CLOCK  EEPROMSK=0 ; EEPROMSK=1 ;
#define SEND(DI)   EEPROMDI=DI ;CLOCK ;
main()
{
	unsigned int Data ;
	unsigned char i ;

	P0=0xff ;
	//  設定 CS,SK 到初值//  Setting CS,SK to initial state
EEPROMCS=0 ;
EEPROMSK=0 ;

	EEPROMCS=1 ;
	// 啟始位元// start bit
	SEND(1) ;
	// 指令  10// command  10
	SEND(1) ; SEND(0) ;
	// 位址 00000000// address 00000000
	for(i=0 ; i < 8 ; i++){
	    SEND(0) ;
	}
	if(EEPROMDO==0){
	    Data=0 ;
	    for(i=0 ; i < 16 ; i++){
		CLOCK ;
		Data <<=1 ;
		if(EEPROMDO== 1){
		    Data++ ;
		}
	    }
	}
	EEPROMCS=0 ;
	for(;;) ;
}
%}


@1
%{e93c662.c
//
//  配合"EEPROM 93C66實習板"//
//   寫入一數值(5678h)到93C66的位址00//   Write the value (5678h) to  93C66 at address 00
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit EEPROMCS=P0 ^0 ;
sbit EEPROMSK=P0 ^1 ;
sbit EEPROMDI=P0 ^2 ;
sbit EEPROMDO=P0 ^3 ;
#define CLOCK  EEPROMSK=0 ; EEPROMSK=1 ;
#define SEND(DI)   EEPROMDI=DI ;CLOCK ;
main()
{
	unsigned int Data ;
	unsigned char i ;

	P0=0xff ;
	//  設定 CS,SK 到初值//  Setting CS,SK to initial state
	EEPROMCS=0 ;
	EEPROMSK=0 ;

	// 使寫入致能// write enable
	EEPROMCS=1 ;
	// 啟始位元// start bit
	SEND(1) ;
	// 指令  00// command  00
	SEND(0) ; SEND(0) ;
	// 次指令 11// sub-command 11
	SEND(1) ; SEND(1) ;
	// 6-'X' Bit
	for(i=0 ; i < 6 ; i++){
	    SEND(0) ;
	}
	EEPROMCS=0 ;


	//  寫入一數值(5678h)到93C66的位址(00) //  Write the value (5678h) to  93C66 at address 00
	EEPROMCS=1 ;
	// 啟始位元// start bit
	SEND(1) ;
	// 指令  01// command  01
	SEND(0) ; SEND(1) ;
	// 位址 00000000// address 00000000
	for(i=0 ; i < 8 ; i++){
	    SEND(0) ;
	}
	// 送出資料// send out data
	Data=0x5678 ;
	for(i=0 ; i < 16 ; i++){
	    if(Data & 0x8000){
		SEND(1) ;
	    }
	    else{
		SEND(0) ;
	    }
	    Data <<=1 ;
	}
	EEPROMCS=0 ;
	// 等待備用// wait ready
	EEPROMCS=1 ;
	while(!EEPROMDO){
	    CLOCK ;
	}
	for(;;) ;
}
%}


%{glcd1.a51
;
; 配合"繪圖型LCD(橫排)實習板";
;   在繪圖型LCD上方顯示一橫線;   Display a horizontal line (at top)  on Graphic LCD
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
DI	REGEQU	P1.0
CS1	REGEQU	P1.3
CS2	REGEQU	P1.4

START:
	SETB	CS1
	SETB	CS2
	ACALL	DELAY5MS
	MOV	A,#0111111B  ; wait for LCD Power-on Ready & Display ON
	ACALL	COMMAND

	MOV	A,#010111000B   ;設定X addr=0;setting X addr=0
	ACALL	COMMAND
	MOV	A,#001000000B   ;設定Y addr=0;setting Y addr=0
	ACALL	COMMAND
	MOV	R0,#64
LOOP:
	MOV	A,#01H
	ACALL	SDATA
	DJNZ	R0,LOOP
	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	DI
	CLR	E
	SETB	RW
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	DI
	CLR	E
	SETB	RW
WAITLCD:
	MOV	P0,#0FFH  ; P0設定為輸入埠; P0 set to input port
WAITLCD1:
	CLR	DI
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


@1
%{glcd1.c
//
//  配合"繪圖型LCD(橫排)實習板"//
//   在繪圖型LCD上方顯示一橫線//   Display a horizontal line (at top)  on Graphic LCD
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit DI=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
sbit CS1=P1^3 ;
sbit CS2=P1^4 ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0設定為輸入埠// P0 set to input port
	do{
  	    DI=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0

}
void Command(cmd){
	P0=cmd ;
	DI=0 ;RW=0; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	DI=1 ;RW=0; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
main()
{
	unsigned char i ;

	CS1=CS2=1 ;
	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // DISPLAY ON

	Command(0xb8+0) ; // X addr = 0 ;
	Command(0x40+0) ; // Y Addr= 0 ;

	for(i=0; i< 64  ;i++){
	    Data(0x01);
	}
	for(;;) ;
}
%}


%{glcd2.a51
;
; 配合"繪圖型LCD(橫排)實習板";
;   在繪圖型LCD上顯示"歡迎參觀";   Display Chinese word "huan ying can guan" on Graphic LCD
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
DI	REGEQU	P1.0
CS1	REGEQU	P1.3
CS2	REGEQU	P1.4
Y	REGEQU	R0
SPAGE	REGEQU	R1
IDX	REGEQU	R2

START:
	SETB	CS1
	SETB	CS2
	ACALL	DELAY5MS
	MOV	A,#0111111B  ; wait for LCD Power-on Ready & Display ON
	ACALL	COMMAND

	SETB	CS1
	CLR	CS2
	MOV	DPTR,#HWAN
	ACALL	FILLHWAN
	CLR	CS1
	SETB	CS2
	ACALL	FILLHWAN
	SJMP	$
FILLHWAN:
	MOV	Y,#0
NEXT3:
	MOV	SPAGE,#0
NEXT2:
	MOV	A,#010111000b
	ORL	A,SPAGE
	ACALL	COMMAND
	MOV	A,#001000000B
	ORL	A,Y
	ACALL	COMMAND
	MOV	IDX,#32
NEXT1:
	CLR	A
	MOVC	A,@A+DPTR
	ACALL	SDATA
	INC	DPTR
	DJNZ	IDX,NEXT1
	INC	SPAGE
	CJNE	SPAGE,#8,NEXT2
	MOV	A,Y
	ADD	A,#32
	MOV	Y,A
	CJNE	A,#64,NEXT3
	RET
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	DI
	CLR	E
	SETB	RW
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	DI
	CLR	E
	SETB	RW
WAITLCD:
	MOV	P0,#0FFH  ; P0設定為輸入埠; P0 set to input port
WAITLCD1:
	CLR	DI
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

HWAN:
                                                      ;歡(新細明體) ;'huan'(font 1)
      DB    000H,008H,048H,088H,088H,088H,0FEH,0BEH
      DB    0CAH,088H,0C8H,088H,0BEH,0BEH,08AH,088H
      DB    0CCH,08CH,088H,000H,0E0H,0FEH,086H,086H
      DB    080H,080H,080H,080H,0C0H,0C0H,080H,000H
      DB    000H,000H,000H,01FH,01FH,0E8H,068H,068H
      DB    01FH,00FH,080H,0FFH,06FH,048H,008H,088H
      DB    09FH,01FH,018H,006H,001H,000H,0FCH,0FCH
      DB    004H,000H,010H,00EH,003H,000H,000H,000H
      DB    010H,008H,00CH,006H,0FFH,0FFH,089H,089H
      DB    089H,089H,0FFH,0FFH,089H,089H,0CDH,0CDH
      DB    089H,001H,000H,000H,080H,0F0H,03FH,003H
      DB    00FH,070H,0C0H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,03FH,03FH,008H,008H
      DB    008H,008H,00FH,00FH,008H,008H,008H,02CH
      DB    01CH,018H,00CH,006H,003H,000H,000H,000H
      DB    000H,000H,001H,007H,00EH,01CH,018H,010H
                                                      ;迎(新細明體) ;'ying' (font 1)
      DB    000H,080H,080H,002H,004H,004H,00CH,018H
      DB    010H,000H,004H,0F8H,0F8H,008H,008H,00CH
      DB    006H,006H,004H,000H,0FCH,0F8H,008H,008H
      DB    008H,008H,008H,008H,0FCH,0FCH,00CH,000H
      DB    000H,000H,000H,001H,003H,006H,086H,080H
      DB    000H,000H,000H,0FFH,0FFH,000H,000H,000H
      DB    000H,000H,000H,000H,0FFH,0FFH,000H,000H
      DB    000H,000H,000H,000H,0FFH,0FFH,000H,000H
      DB    000H,001H,001H,001H,001H,001H,0FFH,0FFH
      DB    001H,060H,0E0H,07FH,03FH,010H,018H,008H
      DB    004H,004H,002H,000H,0FFH,0FFH,000H,010H
      DB    010H,010H,070H,030H,03FH,01FH,000H,000H
      DB    000H,008H,038H,00CH,006H,002H,001H,002H
      DB    004H,004H,008H,008H,008H,018H,018H,010H
      DB    010H,010H,010H,010H,013H,013H,010H,010H
      DB    010H,010H,018H,018H,018H,018H,008H,000H
                                                      ;參(新細明體) ;'can' (font 1)
      DB    000H,000H,000H,000H,000H,0E0H,060H,060H
      DB    060H,020H,030H,038H,02CH,027H,022H,022H
      DB    020H,020H,020H,028H,024H,018H,098H,0B0H
      DB    070H,060H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,070H,030H,030H,038H,01EH,017H
      DB    013H,012H,094H,0CCH,078H,030H,038H,01CH
      DB    08CH,018H,030H,070H,050H,09CH,097H,013H
      DB    011H,008H,00AH,00CH,038H,010H,000H,000H
      DB    000H,010H,008H,008H,044H,044H,026H,022H
      DB    023H,031H,010H,018H,088H,08CH,086H,043H
      DB    063H,021H,031H,018H,01CH,008H,009H,081H
      DB    0E3H,0C2H,0C6H,006H,00CH,004H,004H,000H
      DB    000H,000H,000H,020H,022H,022H,022H,022H
      DB    022H,023H,011H,011H,011H,010H,008H,008H
      DB    008H,004H,004H,006H,002H,003H,001H,001H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
                                                      ;觀(新細明體) ;'guan' (font 1)
      DB    000H,010H,090H,090H,010H,07EH,07EH,096H
      DB    090H,090H,090H,07EH,03EH,016H,090H,098H
      DB    010H,002H,0FCH,0FCH,004H,004H,004H,004H
      DB    004H,004H,004H,0FCH,0FEH,00CH,000H,000H
      DB    000H,000H,01FH,01FH,009H,0E9H,049H,05FH
      DB    01FH,01FH,0DFH,049H,049H,009H,01FH,01FH
      DB    001H,000H,0FFH,0FFH,021H,021H,021H,021H
      DB    021H,021H,021H,0FFH,0FFH,000H,000H,000H
      DB    000H,010H,008H,006H,0FFH,0FFH,092H,092H
      DB    092H,0FEH,0FFH,092H,092H,0DBH,0DBH,092H
      DB    000H,000H,01FH,01FH,0C4H,0FCH,00CH,004H
      DB    0FCH,0FCH,004H,01FH,01FH,080H,000H,000H
      DB    000H,000H,000H,000H,03FH,03FH,008H,008H
      DB    008H,00FH,00FH,008H,008H,008H,00CH,02CH
      DB    030H,010H,00CH,006H,003H,000H,000H,000H
      DB    01FH,01FH,010H,010H,010H,01FH,010H,000H
                                                      ;歡(標楷體) ;'huan' (font 2)
      DB    000H,000H,000H,000H,080H,080H,080H,090H
      DB    0F0H,080H,000H,000H,000H,0FCH,07CH,068H
      DB    020H,020H,000H,000H,0C0H,0F8H,078H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,008H,078H,0C8H
      DB    0A6H,03DH,00CH,084H,0BCH,025H,024H,03EH
      DB    02EH,044H,030H,01EH,007H,0CDH,0C4H,004H
      DB    026H,01EH,01EH,00CH,004H,000H,000H,000H
      DB    000H,000H,020H,020H,010H,008H,006H,0FFH
      DB    093H,092H,0D2H,0FEH,0FFH,04AH,04BH,04BH
      DB    000H,000H,000H,0C0H,0F8H,01FH,00DH,030H
      DB    0E0H,080H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,00CH,01FH
      DB    004H,006H,002H,003H,003H,002H,002H,002H
      DB    006H,006H,003H,001H,000H,000H,000H,000H
      DB    000H,003H,007H,006H,006H,004H,004H,000H
                                                      ;迎(標楷體) ;'ying' (font 2)
      DB    000H,000H,000H,000H,000H,020H,060H,0C0H
      DB    0C0H,080H,000H,000H,000H,000H,000H,000H
      DB    080H,0E0H,078H,038H,010H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,020H,020H,030H,030H,0F8H
      DB    071H,031H,000H,000H,000H,0FFH,0FFH,001H
      DB    000H,080H,080H,000H,0FEH,0FEH,002H,081H
      DB    001H,001H,0FFH,0FFH,000H,000H,000H,000H
      DB    000H,000H,000H,0C0H,0C0H,0C0H,041H,046H
      DB    07CH,058H,0C0H,080H,080H,08FH,007H,003H
      DB    001H,000H,000H,000H,0FFH,03FH,000H,000H
      DB    003H,003H,003H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,001H,001H,003H
      DB    003H,003H,006H,006H,00FH,00EH,00EH,01EH
      DB    00EH,00EH,00EH,006H,006H,006H,002H,000H
                                                      ;參(標楷體) ;'can' (font 2)
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,080H,080H,060H,060H,070H,07CH,02EH
      DB    024H,028H,0F8H,0F8H,030H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,038H,018H
      DB    01EH,01BH,009H,008H,08AH,0CEH,07CH,070H
      DB    07CH,0CEH,08FH,08DH,004H,005H,006H,00EH
      DB    00CH,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,020H,020H,010H,018H
      DB    008H,004H,026H,013H,011H,088H,0CCH,067H
      DB    033H,098H,0D0H,0C1H,003H,007H,006H,00EH
      DB    00EH,00CH,00CH,00CH,00CH,004H,004H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    020H,020H,010H,011H,009H,008H,00CH,006H
      DB    003H,003H,001H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
                                                      ;觀(標楷體) ;'guan' (font 2)
      DB    000H,000H,080H,080H,080H,0C0H,070H,0F0H
      DB    000H,000H,000H,0E0H,07CH,048H,060H,020H
      DB    000H,080H,080H,080H,080H,080H,080H,040H
      DB    0C0H,0C0H,080H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,038H,028H,0E4H,0B5H
      DB    01CH,024H,0C3H,0DCH,012H,092H,09EH,096H
      DB    000H,0FFH,04BH,048H,04CH,044H,064H,064H
      DB    04FH,0FFH,001H,000H,000H,000H,000H,000H
      DB    000H,020H,010H,018H,00CH,0FEH,0FBH,029H
      DB    029H,029H,0FFH,0FFH,0A5H,0A5H,0A4H,080H
      DB    000H,0CFH,0F2H,03EH,00AH,006H,0FEH,00EH
      DB    002H,007H,000H,000H,000H,080H,000H,000H
      DB    000H,000H,000H,000H,000H,01FH,01FH,003H
      DB    001H,001H,001H,001H,001H,009H,005H,007H
      DB    003H,001H,000H,000H,000H,000H,00FH,018H
      DB    018H,018H,018H,018H,018H,01FH,00EH,000H
	END
%}


@1
%{glcd2a.c
//
//  配合"繪圖型LCD(橫排)實習板"//
//   在繪圖型LCD上顯示"歡迎參觀"//   Display Chinese word "huan ying can guan" on Graphic LCD
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit DI=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
sbit CS1=P1^3 ;
sbit CS2=P1^4 ;
unsigned char code hwan[]={
//歡(新細明體) //'huan' (font 1)
0x00,0x08,0x48,0x88,0x88,0x88,0xFE,0xBE,
0xCA,0x88,0xC8,0x88,0xBE,0xBE,0x8A,0x88,
0xCC,0x8C,0x88,0x00,0xE0,0xFE,0x86,0x86,
0x80,0x80,0x80,0x80,0xC0,0xC0,0x80,0x00,
0x00,0x00,0x00,0x1F,0x1F,0xE8,0x68,0x68,
0x1F,0x0F,0x80,0xFF,0x6F,0x48,0x08,0x88,
0x9F,0x1F,0x18,0x06,0x01,0x00,0xFC,0xFC,
0x04,0x00,0x10,0x0E,0x03,0x00,0x00,0x00,
0x10,0x08,0x0C,0x06,0xFF,0xFF,0x89,0x89,
0x89,0x89,0xFF,0xFF,0x89,0x89,0xCD,0xCD,
0x89,0x01,0x00,0x00,0x80,0xF0,0x3F,0x03,
0x0F,0x70,0xC0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x3F,0x3F,0x08,0x08,
0x08,0x08,0x0F,0x0F,0x08,0x08,0x08,0x2C,
0x1C,0x18,0x0C,0x06,0x03,0x00,0x00,0x00,
0x00,0x00,0x01,0x07,0x0E,0x1C,0x18,0x10,
//迎(新細明體) //'ying' (font 1)
0x00,0x80,0x80,0x02,0x04,0x04,0x0C,0x18,
0x10,0x00,0x04,0xF8,0xF8,0x08,0x08,0x0C,
0x06,0x06,0x04,0x00,0xFC,0xF8,0x08,0x08,
0x08,0x08,0x08,0x08,0xFC,0xFC,0x0C,0x00,
0x00,0x00,0x00,0x01,0x03,0x06,0x86,0x80,
0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,
0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,
0x00,0x01,0x01,0x01,0x01,0x01,0xFF,0xFF,
0x01,0x60,0xE0,0x7F,0x3F,0x10,0x18,0x08,
0x04,0x04,0x02,0x00,0xFF,0xFF,0x00,0x10,
0x10,0x10,0x70,0x30,0x3F,0x1F,0x00,0x00,
0x00,0x08,0x38,0x0C,0x06,0x02,0x01,0x02,
0x04,0x04,0x08,0x08,0x08,0x18,0x18,0x10,
0x10,0x10,0x10,0x10,0x13,0x13,0x10,0x10,
0x10,0x10,0x18,0x18,0x18,0x18,0x08,0x00,
//參(新細明體) //'can' (font 1)
0x00,0x00,0x00,0x00,0x00,0xE0,0x60,0x60,
0x60,0x20,0x30,0x38,0x2C,0x27,0x22,0x22,
0x20,0x20,0x20,0x28,0x24,0x18,0x98,0xB0,
0x70,0x60,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x70,0x30,0x30,0x38,0x1E,0x17,
0x13,0x12,0x94,0xCC,0x78,0x30,0x38,0x1C,
0x8C,0x18,0x30,0x70,0x50,0x9C,0x97,0x13,
0x11,0x08,0x0A,0x0C,0x38,0x10,0x00,0x00,
0x00,0x10,0x08,0x08,0x44,0x44,0x26,0x22,
0x23,0x31,0x10,0x18,0x88,0x8C,0x86,0x43,
0x63,0x21,0x31,0x18,0x1C,0x08,0x09,0x81,
0xE3,0xC2,0xC6,0x06,0x0C,0x04,0x04,0x00,
0x00,0x00,0x00,0x20,0x22,0x22,0x22,0x22,
0x22,0x23,0x11,0x11,0x11,0x10,0x08,0x08,
0x08,0x04,0x04,0x06,0x02,0x03,0x01,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//觀(新細明體) //'guan' (font 1)
0x00,0x10,0x90,0x90,0x10,0x7E,0x7E,0x96,
0x90,0x90,0x90,0x7E,0x3E,0x16,0x90,0x98,
0x10,0x02,0xFC,0xFC,0x04,0x04,0x04,0x04,
0x04,0x04,0x04,0xFC,0xFE,0x0C,0x00,0x00,
0x00,0x00,0x1F,0x1F,0x09,0xE9,0x49,0x5F,
0x1F,0x1F,0xDF,0x49,0x49,0x09,0x1F,0x1F,
0x01,0x00,0xFF,0xFF,0x21,0x21,0x21,0x21,
0x21,0x21,0x21,0xFF,0xFF,0x00,0x00,0x00,
0x00,0x10,0x08,0x06,0xFF,0xFF,0x92,0x92,
0x92,0xFE,0xFF,0x92,0x92,0xDB,0xDB,0x92,
0x00,0x00,0x1F,0x1F,0xC4,0xFC,0x0C,0x04,
0xFC,0xFC,0x04,0x1F,0x1F,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x3F,0x3F,0x08,0x08,
0x08,0x0F,0x0F,0x08,0x08,0x08,0x0C,0x2C,
0x30,0x10,0x0C,0x06,0x03,0x00,0x00,0x00,
0x1F,0x1F,0x10,0x10,0x10,0x1F,0x10,0x00,
//歡(標楷體) //'huan' (font 2)
0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x90,
0xF0,0x80,0x00,0x00,0x00,0xFC,0x7C,0x68,
0x20,0x20,0x00,0x00,0xC0,0xF8,0x78,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x08,0x78,0xC8,
0xA6,0x3D,0x0C,0x84,0xBC,0x25,0x24,0x3E,
0x2E,0x44,0x30,0x1E,0x07,0xCD,0xC4,0x04,
0x26,0x1E,0x1E,0x0C,0x04,0x00,0x00,0x00,
0x00,0x00,0x20,0x20,0x10,0x08,0x06,0xFF,
0x93,0x92,0xD2,0xFE,0xFF,0x4A,0x4B,0x4B,
0x00,0x00,0x00,0xC0,0xF8,0x1F,0x0D,0x30,
0xE0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x1F,
0x04,0x06,0x02,0x03,0x03,0x02,0x02,0x02,
0x06,0x06,0x03,0x01,0x00,0x00,0x00,0x00,
0x00,0x03,0x07,0x06,0x06,0x04,0x04,0x00,
//迎(標楷體) //'ying' (font 2)
0x00,0x00,0x00,0x00,0x00,0x20,0x60,0xC0,
0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x80,0xE0,0x78,0x38,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x20,0x20,0x30,0x30,0xF8,
0x71,0x31,0x00,0x00,0x00,0xFF,0xFF,0x01,
0x00,0x80,0x80,0x00,0xFE,0xFE,0x02,0x81,
0x01,0x01,0xFF,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xC0,0xC0,0xC0,0x41,0x46,
0x7C,0x58,0xC0,0x80,0x80,0x8F,0x07,0x03,
0x01,0x00,0x00,0x00,0xFF,0x3F,0x00,0x00,
0x03,0x03,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x03,
0x03,0x03,0x06,0x06,0x0F,0x0E,0x0E,0x1E,
0x0E,0x0E,0x0E,0x06,0x06,0x06,0x02,0x00,
//參(標楷體) //'can' (font 2)
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x80,0x60,0x60,0x70,0x7C,0x2E,
0x24,0x28,0xF8,0xF8,0x30,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x18,
0x1E,0x1B,0x09,0x08,0x8A,0xCE,0x7C,0x70,
0x7C,0xCE,0x8F,0x8D,0x04,0x05,0x06,0x0E,
0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x20,0x20,0x10,0x18,
0x08,0x04,0x26,0x13,0x11,0x88,0xCC,0x67,
0x33,0x98,0xD0,0xC1,0x03,0x07,0x06,0x0E,
0x0E,0x0C,0x0C,0x0C,0x0C,0x04,0x04,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x20,0x20,0x10,0x11,0x09,0x08,0x0C,0x06,
0x03,0x03,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//觀(標楷體) //'guan' (font 2)
0x00,0x00,0x80,0x80,0x80,0xC0,0x70,0xF0,
0x00,0x00,0x00,0xE0,0x7C,0x48,0x60,0x20,
0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x40,
0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x38,0x28,0xE4,0xB5,
0x1C,0x24,0xC3,0xDC,0x12,0x92,0x9E,0x96,
0x00,0xFF,0x4B,0x48,0x4C,0x44,0x64,0x64,
0x4F,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x20,0x10,0x18,0x0C,0xFE,0xFB,0x29,
0x29,0x29,0xFF,0xFF,0xA5,0xA5,0xA4,0x80,
0x00,0xCF,0xF2,0x3E,0x0A,0x06,0xFE,0x0E,
0x02,0x07,0x00,0x00,0x00,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x1F,0x1F,0x03,
0x01,0x01,0x01,0x01,0x01,0x09,0x05,0x07,
0x03,0x01,0x00,0x00,0x00,0x00,0x0F,0x18,
0x18,0x18,0x18,0x18,0x18,0x1F,0x0E,0x00,


} ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++)  Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0設定為輸入埠// P0 set to input port
	do{
	    DI=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0

}
void Command(cmd){
	P0=cmd ;
	DI=0 ;RW=0; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	DI=1 ;RW=0; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
void FillHWAN(unsigned int pidx)
{
	char i ,page,y;
	for(y=0 ; y < 64 ; y+=32){
	    for(page=0 ; page < 8 ; page++){
		Command(0xb8+page) ; // X addr  ;
		Command(0x40+y) ;    // Y Addr ;
		for(i=0; i< 32  ;i++){
		    Data(hwan[pidx++]);
		}
	    }
	}
}
main()
{

	CS1=CS2=1 ;
	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // DISPLAY ON

	CS1=1; CS2=0 ;
	FillHWAN(0) ;
	CS1=0 ; CS2=1 ;
	FillHWAN(128*4) ;
	for(;;) ;
}
%}


@1
%{glcd2b.c
//
//  配合"繪圖型LCD(橫排)實習板"//
//   在繪圖型LCD上顯示"歡迎參觀"//   Display Chinese word "huan ying can guan" on Graphic LCD
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit DI=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
sbit CS1=P1^3 ;
sbit CS2=P1^4 ;
unsigned char code hwan[]={
//歡(新細明體) //'huan' (font 1)
0x00,0x08,0x48,0x88,0x88,0x88,0xFE,0xBE,
0xCA,0x88,0xC8,0x88,0xBE,0xBE,0x8A,0x88,
0xCC,0x8C,0x88,0x00,0xE0,0xFE,0x86,0x86,
0x80,0x80,0x80,0x80,0xC0,0xC0,0x80,0x00,
0x00,0x00,0x00,0x1F,0x1F,0xE8,0x68,0x68,
0x1F,0x0F,0x80,0xFF,0x6F,0x48,0x08,0x88,
0x9F,0x1F,0x18,0x06,0x01,0x00,0xFC,0xFC,
0x04,0x00,0x10,0x0E,0x03,0x00,0x00,0x00,
0x10,0x08,0x0C,0x06,0xFF,0xFF,0x89,0x89,
0x89,0x89,0xFF,0xFF,0x89,0x89,0xCD,0xCD,
0x89,0x01,0x00,0x00,0x80,0xF0,0x3F,0x03,
0x0F,0x70,0xC0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x3F,0x3F,0x08,0x08,
0x08,0x08,0x0F,0x0F,0x08,0x08,0x08,0x2C,
0x1C,0x18,0x0C,0x06,0x03,0x00,0x00,0x00,
0x00,0x00,0x01,0x07,0x0E,0x1C,0x18,0x10,
//迎(新細明體) //'ying' (font 1)
0x00,0x80,0x80,0x02,0x04,0x04,0x0C,0x18,
0x10,0x00,0x04,0xF8,0xF8,0x08,0x08,0x0C,
0x06,0x06,0x04,0x00,0xFC,0xF8,0x08,0x08,
0x08,0x08,0x08,0x08,0xFC,0xFC,0x0C,0x00,
0x00,0x00,0x00,0x01,0x03,0x06,0x86,0x80,
0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,
0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,
0x00,0x01,0x01,0x01,0x01,0x01,0xFF,0xFF,
0x01,0x60,0xE0,0x7F,0x3F,0x10,0x18,0x08,
0x04,0x04,0x02,0x00,0xFF,0xFF,0x00,0x10,
0x10,0x10,0x70,0x30,0x3F,0x1F,0x00,0x00,
0x00,0x08,0x38,0x0C,0x06,0x02,0x01,0x02,
0x04,0x04,0x08,0x08,0x08,0x18,0x18,0x10,
0x10,0x10,0x10,0x10,0x13,0x13,0x10,0x10,
0x10,0x10,0x18,0x18,0x18,0x18,0x08,0x00,
//參(新細明體) //'can' (font 1)
0x00,0x00,0x00,0x00,0x00,0xE0,0x60,0x60,
0x60,0x20,0x30,0x38,0x2C,0x27,0x22,0x22,
0x20,0x20,0x20,0x28,0x24,0x18,0x98,0xB0,
0x70,0x60,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x70,0x30,0x30,0x38,0x1E,0x17,
0x13,0x12,0x94,0xCC,0x78,0x30,0x38,0x1C,
0x8C,0x18,0x30,0x70,0x50,0x9C,0x97,0x13,
0x11,0x08,0x0A,0x0C,0x38,0x10,0x00,0x00,
0x00,0x10,0x08,0x08,0x44,0x44,0x26,0x22,
0x23,0x31,0x10,0x18,0x88,0x8C,0x86,0x43,
0x63,0x21,0x31,0x18,0x1C,0x08,0x09,0x81,
0xE3,0xC2,0xC6,0x06,0x0C,0x04,0x04,0x00,
0x00,0x00,0x00,0x20,0x22,0x22,0x22,0x22,
0x22,0x23,0x11,0x11,0x11,0x10,0x08,0x08,
0x08,0x04,0x04,0x06,0x02,0x03,0x01,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//觀(新細明體) //'guan' (font 1)
0x00,0x10,0x90,0x90,0x10,0x7E,0x7E,0x96,
0x90,0x90,0x90,0x7E,0x3E,0x16,0x90,0x98,
0x10,0x02,0xFC,0xFC,0x04,0x04,0x04,0x04,
0x04,0x04,0x04,0xFC,0xFE,0x0C,0x00,0x00,
0x00,0x00,0x1F,0x1F,0x09,0xE9,0x49,0x5F,
0x1F,0x1F,0xDF,0x49,0x49,0x09,0x1F,0x1F,
0x01,0x00,0xFF,0xFF,0x21,0x21,0x21,0x21,
0x21,0x21,0x21,0xFF,0xFF,0x00,0x00,0x00,
0x00,0x10,0x08,0x06,0xFF,0xFF,0x92,0x92,
0x92,0xFE,0xFF,0x92,0x92,0xDB,0xDB,0x92,
0x00,0x00,0x1F,0x1F,0xC4,0xFC,0x0C,0x04,
0xFC,0xFC,0x04,0x1F,0x1F,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x3F,0x3F,0x08,0x08,
0x08,0x0F,0x0F,0x08,0x08,0x08,0x0C,0x2C,
0x30,0x10,0x0C,0x06,0x03,0x00,0x00,0x00,
0x1F,0x1F,0x10,0x10,0x10,0x1F,0x10,0x00,
//歡(標楷體) //'huan' (font 2)
0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x90,
0xF0,0x80,0x00,0x00,0x00,0xFC,0x7C,0x68,
0x20,0x20,0x00,0x00,0xC0,0xF8,0x78,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x08,0x78,0xC8,
0xA6,0x3D,0x0C,0x84,0xBC,0x25,0x24,0x3E,
0x2E,0x44,0x30,0x1E,0x07,0xCD,0xC4,0x04,
0x26,0x1E,0x1E,0x0C,0x04,0x00,0x00,0x00,
0x00,0x00,0x20,0x20,0x10,0x08,0x06,0xFF,
0x93,0x92,0xD2,0xFE,0xFF,0x4A,0x4B,0x4B,
0x00,0x00,0x00,0xC0,0xF8,0x1F,0x0D,0x30,
0xE0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x1F,
0x04,0x06,0x02,0x03,0x03,0x02,0x02,0x02,
0x06,0x06,0x03,0x01,0x00,0x00,0x00,0x00,
0x00,0x03,0x07,0x06,0x06,0x04,0x04,0x00,
//迎(標楷體) //'ying' (font 2)
0x00,0x00,0x00,0x00,0x00,0x20,0x60,0xC0,
0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x80,0xE0,0x78,0x38,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x20,0x20,0x30,0x30,0xF8,
0x71,0x31,0x00,0x00,0x00,0xFF,0xFF,0x01,
0x00,0x80,0x80,0x00,0xFE,0xFE,0x02,0x81,
0x01,0x01,0xFF,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xC0,0xC0,0xC0,0x41,0x46,
0x7C,0x58,0xC0,0x80,0x80,0x8F,0x07,0x03,
0x01,0x00,0x00,0x00,0xFF,0x3F,0x00,0x00,
0x03,0x03,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x03,
0x03,0x03,0x06,0x06,0x0F,0x0E,0x0E,0x1E,
0x0E,0x0E,0x0E,0x06,0x06,0x06,0x02,0x00,
//參(標楷體) //'can' (font 2)
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x80,0x60,0x60,0x70,0x7C,0x2E,
0x24,0x28,0xF8,0xF8,0x30,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x18,
0x1E,0x1B,0x09,0x08,0x8A,0xCE,0x7C,0x70,
0x7C,0xCE,0x8F,0x8D,0x04,0x05,0x06,0x0E,
0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x20,0x20,0x10,0x18,
0x08,0x04,0x26,0x13,0x11,0x88,0xCC,0x67,
0x33,0x98,0xD0,0xC1,0x03,0x07,0x06,0x0E,
0x0E,0x0C,0x0C,0x0C,0x0C,0x04,0x04,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x20,0x20,0x10,0x11,0x09,0x08,0x0C,0x06,
0x03,0x03,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//觀(標楷體) //'guan' (font 2)
0x00,0x00,0x80,0x80,0x80,0xC0,0x70,0xF0,
0x00,0x00,0x00,0xE0,0x7C,0x48,0x60,0x20,
0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x40,
0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x38,0x28,0xE4,0xB5,
0x1C,0x24,0xC3,0xDC,0x12,0x92,0x9E,0x96,
0x00,0xFF,0x4B,0x48,0x4C,0x44,0x64,0x64,
0x4F,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x20,0x10,0x18,0x0C,0xFE,0xFB,0x29,
0x29,0x29,0xFF,0xFF,0xA5,0xA5,0xA4,0x80,
0x00,0xCF,0xF2,0x3E,0x0A,0x06,0xFE,0x0E,
0x02,0x07,0x00,0x00,0x00,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x1F,0x1F,0x03,
0x01,0x01,0x01,0x01,0x01,0x09,0x05,0x07,
0x03,0x01,0x00,0x00,0x00,0x00,0x0F,0x18,
0x18,0x18,0x18,0x18,0x18,0x1F,0x0E,0x00,


} ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0設定為輸入埠// P0 set to input port
	do{
	    DI=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0

}
void Command(cmd){
	P0=cmd ;
	DI=0 ;RW=0; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	DI=1 ;RW=0; E=1;E=0 ;RW=1 ;
 	waitlcd() ;
}
void FillHWAN(unsigned char code *pp)
{
	char i ,page,y;
	for(y=0 ; y < 64 ; y+=32){
	    for(page=0 ; page < 8 ; page++){
		Command(0xb8+page) ; // X addr  ;
		Command(0x40+y) ;    // Y Addr ;
		for(i=0; i< 32  ;i++){
		    Data(*pp++);
		}
	    }
	}
}
main()
{

	CS1=CS2=1 ;
	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // DISPLAY ON

	CS1=1; CS2=0 ;
	FillHWAN(&hwan[0]) ;
	CS1=0 ; CS2=1 ;
	FillHWAN(&hwan[128*4]) ;
	for(;;) ;
}
%}


%{glcds1.a51
;
; 配合"繪圖型LCD(直排)實習板";
;   在繪圖型LCD上方顯示一橫線;   Display a horizontal line (at top)  on Graphic LCD
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
DI	REGEQU	P1.0
CS1	REGEQU	P1.3
CS2	REGEQU	P1.4
SPAGE	REGEQU	R0

START:
	SETB	CS1
	CLR	CS2
	ACALL	DELAY5MS
	MOV	A,#0111111B  ; wait for LCD Power-on Ready & Display ON
	ACALL	COMMAND

	MOV	SPAGE,#7
LOOP:
	MOV	A,#010111000B   ;X addr=0
	ORL	A,SPAGE
	ACALL	COMMAND
	MOV	A,#001000000B   ;Y addr=0
	ACALL	COMMAND
	MOV	A,#0FFH
	ACALL	SDATA
	DEC	SPAGE
	CJNE	SPAGE,#0FFH,LOOP
	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	DI
	CLR	E
	SETB	RW
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	DI
	CLR	E
	SETB	RW
WAITLCD:
	MOV	P0,#0FFH  ; P0設定為輸入埠; P0 set to input port
WAITLCD1:
	CLR	DI
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


@1
%{glcds1.c
//
//  配合"繪圖型LCD(直排)實習板"//
//   在繪圖型LCD上方顯示一橫線//   Display a horizontal line (at top)  on Graphic LCD
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit DI=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
sbit CS1=P1^3 ;
sbit CS2=P1^4 ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0設定為輸入埠// P0 set to input port
	do{
	    DI=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0
}
void Command(cmd){
	P0=cmd ;
	DI=0 ;RW=0; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	DI=1 ;RW=0; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
main()
{
	char page ;

	CS1=1;CS2=0 ;
	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // DISPLAY ON


	for(page=7; page >= 0  ;page--){
	    Command(0xb8+page) ; // X addr = 0 ;
	    Command(0x40+0) ; // Y Addr= 0 ;
	    Data(0xff);
	}
	for(;;) ;
}
%}


%{glcds2.a51
;
; 配合"繪圖型LCD(直排)實習板";
;   在繪圖型LCD上顯示"歡迎參觀";   Display Chinese word "huan ying can guan" on Graphic LCD
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
DI	REGEQU	P1.0
CS1	REGEQU	P1.3
CS2	REGEQU	P1.4
Y	REGEQU	R0
SPAGE	REGEQU	R1
IDX	REGEQU	R2

START:
	SETB	CS1
	SETB	CS2
	ACALL	DELAY5MS
	MOV	A,#0111111B  ; wait for LCD Power-on Ready & Display ON
	ACALL	COMMAND

	SETB	CS1
	CLR	CS2
	MOV	DPTR,#HWAN
	ACALL	FILLHWAN
	CLR	CS1
	SETB	CS2
	ACALL	FILLHWAN
	SJMP	$
FILLHWAN:
	MOV	Y,#0
NEXT3:
	MOV	SPAGE,#7
NEXT2:
	MOV	A,#010111000b
	ORL	A,SPAGE
	ACALL	COMMAND
	MOV	A,#001000000B
	ORL	A,Y
	ACALL	COMMAND
	MOV	IDX,#32
NEXT1:
	CLR	A
	MOVC	A,@A+DPTR
	ACALL	SDATA
	INC	DPTR
	DJNZ	IDX,NEXT1
	DEC	SPAGE
	CJNE	SPAGE,#0FFH,NEXT2
	MOV	A,Y
	ADD	A,#32
	MOV	Y,A
	CJNE	A,#64,NEXT3
	RET
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	DI
	CLR	E
	SETB	RW
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	DI
	CLR	E
	SETB	RW
WAITLCD:
	MOV	P0,#0FFH  ; P0設定為輸入埠; P0 set to input port
WAITLCD1:
	CLR	DI
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

HWAN:
                                                      ;歡(新細明體) ;'huan' (font 1)
      DB    000H,000H,003H,003H,07FH,003H,003H,022H
      DB    01FH,018H,018H,018H,01FH,018H,007H,007H
      DB    004H,00FH,01CH,03CH,06FH,08CH,00CH,00CH
      DB    00FH,00CH,00CH,00CH,00FH,00CH,00CH,000H
      DB    000H,000H,08EH,00CH,0FFH,00CH,00CH,0A0H
      DB    0FFH,0D8H,0D8H,0D8H,0DFH,090H,018H,01CH
      DB    031H,0FFH,030H,033H,0FFH,030H,030H,033H
      DB    0FFH,030H,030H,031H,0FFH,000H,001H,000H
      DB    000H,000H,007H,0C7H,0E4H,004H,00CH,08CH
      DB    0EFH,0C8H,0D0H,0D3H,0E3H,0E3H,003H,003H
      DB    083H,0C3H,003H,002H,082H,006H,006H,004H
      DB    08CH,008H,018H,0B0H,0E0H,0C0H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,00CH
      DB    0FEH,008H,018H,090H,010H,020H,000H,000H
      DB    000H,080H,080H,080H,080H,040H,040H,060H
      DB    020H,030H,018H,01CH,00EH,007H,000H,000H
                                                                       ;迎(新細明體) ;'ying' (font 1)
      DB    000H,000H,010H,00EH,003H,001H,000H,000H
      DB    060H,018H,00EH,006H,000H,000H,000H,000H
      DB    003H,07FH,003H,003H,003H,003H,003H,003H
      DB    003H,002H,00DH,018H,070H,020H,020H,000H
      DB    000H,000H,000H,021H,01FH,098H,018H,018H
      DB    018H,018H,018H,018H,018H,018H,018H,018H
      DB    018H,098H,018H,018H,01BH,01EH,078H,070H
      DB    020H,000H,000H,0C0H,03EH,007H,000H,000H
      DB    000H,000H,0C0H,0E8H,00FH,00CH,00CH,00CH
      DB    00CH,00CH,00CH,00CH,00CH,00CH,00CH,00CH
      DB    00CH,00CH,02CH,0CCH,00CH,00DH,00CH,00CH
      DB    00CH,00CH,00CH,000H,000H,0FFH,000H,000H
      DB    000H,000H,000H,00EH,0FEH,00CH,00CH,00CH
      DB    00CH,00CH,00CH,00CH,00CH,00CH,00CH,00CH
      DB    00CH,00CH,00CH,00CH,00CH,0FCH,038H,020H
      DB    000H,000H,000H,000H,03EH,0FCH,000H,000H
                                                                       ;參(新細明體) ;'can' (font 1)
      DB    000H,000H,000H,000H,000H,000H,007H,007H
      DB    004H,001H,003H,003H,006H,03FH,03CH,020H
      DB    000H,000H,003H,00EH,030H,040H,003H,00CH
      DB    000H,000H,00FH,000H,000H,000H,01FH,000H
      DB    000H,004H,007H,00CH,018H,030H,0FFH,080H
      DB    000H,080H,0C0H,031H,01BH,0EFH,00EH,018H
      DB    030H,0C1H,083H,006H,01CH,070H,0C0H,001H
      DB    00EH,078H,0C0H,000H,003H,03CH,0C0H,000H
      DB    000H,000H,000H,008H,016H,007H,0F9H,000H
      DB    003H,003H,003H,086H,0C4H,07FH,030H,018H
      DB    086H,0E3H,080H,008H,01EH,038H,0E0H,080H
      DB    001H,007H,01CH,070H,080H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,080H,0C0H,0C0H
      DB    000H,080H,020H,010H,078H,08CH,008H,000H
      DB    000H,080H,0F0H,03EH,008H,000H,080H,0E0H
      DB    0E0H,000H,000H,000H,000H,000H,000H,000H
                                                                       ;觀(新細明體) ;'guan' (font 1)
      DB    000H,000H,007H,007H,006H,07FH,006H,006H
      DB    031H,03FH,031H,031H,03FH,031H,004H,007H
      DB    004H,00CH,01FH,01CH,02CH,04FH,00CH,00CH
      DB    00FH,00CH,00CH,00CH,00FH,00CH,00CH,000H
      DB    000H,000H,01CH,01CH,019H,0FFH,018H,010H
      DB    0E3H,0FFH,0E3H,0E3H,0FFH,0E3H,000H,038H
      DB    020H,026H,0FFH,060H,066H,0FFH,060H,066H
      DB    0FFH,060H,060H,063H,0FFH,000H,001H,000H
      DB    000H,000H,040H,03FH,030H,0B0H,030H,030H
      DB    030H,0BFH,030H,030H,030H,030H,03FH,030H
      DB    030H,030H,030H,03FH,036H,034H,004H,00CH
      DB    00CH,008H,018H,030H,020H,0C0H,080H,000H
      DB    000H,000H,008H,0FCH,01CH,018H,018H,018H
      DB    018H,0F8H,018H,018H,018H,018H,0F8H,018H
      DB    018H,018H,018H,0F8H,0D8H,0D8H,0C0H,0C0H
      DB    0C4H,0C4H,0C4H,0C4H,0C4H,0FEH,000H,000H
                                                                       ;歡(標楷體) ;'huan' (font 2)
      DB    000H,000H,000H,000H,000H,001H,000H,000H
      DB    00FH,000H,000H,000H,007H,002H,002H,003H
      DB    001H,001H,003H,003H,005H,009H,031H,001H
      DB    001H,001H,001H,003H,003H,001H,000H,000H
      DB    000H,000H,000H,006H,007H,086H,087H,087H
      DB    0C4H,044H,081H,0FFH,069H,049H,0CFH,000H
      DB    098H,08BH,0FFH,018H,01FH,0F8H,018H,03FH
      DB    0F8H,018H,07FH,0C0H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,006H,006H,0C6H,00EH
      DB    00CH,00CH,098H,0DFH,094H,030H,0A0H,046H
      DB    006H,006H,004H,006H,00EH,00DH,009H,018H
      DB    018H,030H,0E0H,0C0H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,0E0H,0F8H,070H,060H,080H,000H
      DB    000H,000H,000H,000H,000H,000H,080H,080H
      DB    0C0H,060H,078H,03EH,000H,000H,000H,000H
                                                                       ;迎(標楷體) ;'ying' (font 2)
      DB    000H,000H,000H,000H,000H,000H,006H,003H
      DB    001H,000H,000H,000H,001H,007H,01FH,001H
      DB    001H,002H,001H,001H,000H,000H,000H,01FH
      DB    01CH,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,080H
      DB    0C0H,0C7H,006H,006H,006H,0C6H,0C6H,086H
      DB    006H,007H,007H,086H,0C4H,0C0H,080H,0E0H
      DB    03CH,007H,001H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,030H,038H,070H,060H
      DB    0C0H,001H,00EH,00CH,00CH,00CH,00CH,00CH
      DB    06DH,08CH,00CH,00CH,00CH,00CH,00CH,008H
      DB    008H,0C8H,0FFH,03FH,00FH,001H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,0F0H,030H,030H,030H,030H,030H,030H
      DB    030H,0E0H,0E0H,000H,000H,000H,000H,000H
      DB    000H,000H,0FEH,0FCH,0E0H,000H,000H,000H
                                                                       ;參(標楷體) ;'can' (font 2)
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,003H,003H,002H,000H
      DB    000H,000H,000H,000H,001H,003H,00CH,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,001H,003H,003H,006H,01FH,01EH
      DB    060H,060H,0CCH,086H,0FEH,0C3H,003H,007H
      DB    00CH,019H,031H,063H,086H,018H,021H,003H
      DB    006H,018H,001H,003H,00EH,030H,0C0H,000H
      DB    000H,000H,000H,080H,070H,038H,0F8H,030H
      DB    030H,034H,063H,0FFH,0F1H,080H,080H,0C0H
      DB    070H,09CH,08FH,007H,041H,0E0H,080H,030H
      DB    070H,0E0H,0C0H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,080H,080H,000H,000H,000H
      DB    000H,000H,080H,0FEH,0F8H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
                                                                       ;觀(標楷體) ;'guan' (font 2)
      DB    000H,000H,000H,000H,000H,003H,003H,007H
      DB    03DH,001H,000H,003H,00CH,009H,00FH,002H
      DB    003H,003H,006H,00CH,01FH,036H,047H,006H
      DB    006H,007H,007H,006H,006H,006H,000H,000H
      DB    000H,000H,000H,008H,00CH,008H,01BH,01EH
      DB    010H,020H,02FH,0D3H,092H,09FH,040H,030H
      DB    037H,0FCH,030H,03EH,0F0H,030H,0FEH,030H
      DB    03FH,0FFH,001H,003H,004H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,001H
      DB    07EH,060H,060H,04FH,078H,040H,043H,07FH
      DB    040H,040H,07FH,057H,05BH,032H,032H,062H
      DB    062H,0C2H,082H,002H,003H,001H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,0C0H
      DB    0E0H,0E0H,0C0H,0C0H,0C0H,040H,040H,0C0H
      DB    040H,040H,0C0H,040H,000H,000H,000H,000H
      DB    004H,004H,006H,006H,0FEH,0FCH,000H,000H

	END
%}


@1
%{glcds2a.c
//
//  配合"繪圖型LCD(直排)實習板"//
//   在繪圖型LCD上顯示"歡迎參觀"//   Display Chinese word "huan ying can guan" on Graphic LCD

//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit DI=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
sbit CS1=P1^3 ;
sbit CS2=P1^4 ;
unsigned char code hwan[]={
//歡(新細明體) //'huan' (font 1)
0x00,0x00,0x03,0x03,0x7F,0x03,0x03,0x22,
0x1F,0x18,0x18,0x18,0x1F,0x18,0x07,0x07,
0x04,0x0F,0x1C,0x3C,0x6F,0x8C,0x0C,0x0C,
0x0F,0x0C,0x0C,0x0C,0x0F,0x0C,0x0C,0x00,
0x00,0x00,0x8E,0x0C,0xFF,0x0C,0x0C,0xA0,
0xFF,0xD8,0xD8,0xD8,0xDF,0x90,0x18,0x1C,
0x31,0xFF,0x30,0x33,0xFF,0x30,0x30,0x33,
0xFF,0x30,0x30,0x31,0xFF,0x00,0x01,0x00,
0x00,0x00,0x07,0xC7,0xE4,0x04,0x0C,0x8C,
0xEF,0xC8,0xD0,0xD3,0xE3,0xE3,0x03,0x03,
0x83,0xC3,0x03,0x02,0x82,0x06,0x06,0x04,
0x8C,0x08,0x18,0xB0,0xE0,0xC0,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,
0xFE,0x08,0x18,0x90,0x10,0x20,0x00,0x00,
0x00,0x80,0x80,0x80,0x80,0x40,0x40,0x60,
0x20,0x30,0x18,0x1C,0x0E,0x07,0x00,0x00,
//迎(新細明體) //'ying' (font 1)
0x00,0x00,0x10,0x0E,0x03,0x01,0x00,0x00,
0x60,0x18,0x0E,0x06,0x00,0x00,0x00,0x00,
0x03,0x7F,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x02,0x0D,0x18,0x70,0x20,0x20,0x00,
0x00,0x00,0x00,0x21,0x1F,0x98,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x98,0x18,0x18,0x1B,0x1E,0x78,0x70,
0x20,0x00,0x00,0xC0,0x3E,0x07,0x00,0x00,
0x00,0x00,0xC0,0xE8,0x0F,0x0C,0x0C,0x0C,
0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
0x0C,0x0C,0x2C,0xCC,0x0C,0x0D,0x0C,0x0C,
0x0C,0x0C,0x0C,0x00,0x00,0xFF,0x00,0x00,
0x00,0x00,0x00,0x0E,0xFE,0x0C,0x0C,0x0C,
0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
0x0C,0x0C,0x0C,0x0C,0x0C,0xFC,0x38,0x20,
0x00,0x00,0x00,0x00,0x3E,0xFC,0x00,0x00,
//參(新細明體) //'can' (font 1)
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x07,
0x04,0x01,0x03,0x03,0x06,0x3F,0x3C,0x20,
0x00,0x00,0x03,0x0E,0x30,0x40,0x03,0x0C,
0x00,0x00,0x0F,0x00,0x00,0x00,0x1F,0x00,
0x00,0x04,0x07,0x0C,0x18,0x30,0xFF,0x80,
0x00,0x80,0xC0,0x31,0x1B,0xEF,0x0E,0x18,
0x30,0xC1,0x83,0x06,0x1C,0x70,0xC0,0x01,
0x0E,0x78,0xC0,0x00,0x03,0x3C,0xC0,0x00,
0x00,0x00,0x00,0x08,0x16,0x07,0xF9,0x00,
0x03,0x03,0x03,0x86,0xC4,0x7F,0x30,0x18,
0x86,0xE3,0x80,0x08,0x1E,0x38,0xE0,0x80,
0x01,0x07,0x1C,0x70,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,
0x00,0x80,0x20,0x10,0x78,0x8C,0x08,0x00,
0x00,0x80,0xF0,0x3E,0x08,0x00,0x80,0xE0,
0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//觀(新細明體) //'guan' (font 1)
0x00,0x00,0x07,0x07,0x06,0x7F,0x06,0x06,
0x31,0x3F,0x31,0x31,0x3F,0x31,0x04,0x07,
0x04,0x0C,0x1F,0x1C,0x2C,0x4F,0x0C,0x0C,
0x0F,0x0C,0x0C,0x0C,0x0F,0x0C,0x0C,0x00,
0x00,0x00,0x1C,0x1C,0x19,0xFF,0x18,0x10,
0xE3,0xFF,0xE3,0xE3,0xFF,0xE3,0x00,0x38,
0x20,0x26,0xFF,0x60,0x66,0xFF,0x60,0x66,
0xFF,0x60,0x60,0x63,0xFF,0x00,0x01,0x00,
0x00,0x00,0x40,0x3F,0x30,0xB0,0x30,0x30,
0x30,0xBF,0x30,0x30,0x30,0x30,0x3F,0x30,
0x30,0x30,0x30,0x3F,0x36,0x34,0x04,0x0C,
0x0C,0x08,0x18,0x30,0x20,0xC0,0x80,0x00,
0x00,0x00,0x08,0xFC,0x1C,0x18,0x18,0x18,
0x18,0xF8,0x18,0x18,0x18,0x18,0xF8,0x18,
0x18,0x18,0x18,0xF8,0xD8,0xD8,0xC0,0xC0,
0xC4,0xC4,0xC4,0xC4,0xC4,0xFE,0x00,0x00,
//歡(標楷體) //'huan' (font 2)
0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,
0x0F,0x00,0x00,0x00,0x07,0x02,0x02,0x03,
0x01,0x01,0x03,0x03,0x05,0x09,0x31,0x01,
0x01,0x01,0x01,0x03,0x03,0x01,0x00,0x00,
0x00,0x00,0x00,0x06,0x07,0x86,0x87,0x87,
0xC4,0x44,0x81,0xFF,0x69,0x49,0xCF,0x00,
0x98,0x8B,0xFF,0x18,0x1F,0xF8,0x18,0x3F,
0xF8,0x18,0x7F,0xC0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x06,0x06,0xC6,0x0E,
0x0C,0x0C,0x98,0xDF,0x94,0x30,0xA0,0x46,
0x06,0x06,0x04,0x06,0x0E,0x0D,0x09,0x18,
0x18,0x30,0xE0,0xC0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xE0,0xF8,0x70,0x60,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,
0xC0,0x60,0x78,0x3E,0x00,0x00,0x00,0x00,
//迎(標楷體) //'ying' (font 2)
0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x03,
0x01,0x00,0x00,0x00,0x01,0x07,0x1F,0x01,
0x01,0x02,0x01,0x01,0x00,0x00,0x00,0x1F,
0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0xC0,0xC7,0x06,0x06,0x06,0xC6,0xC6,0x86,
0x06,0x07,0x07,0x86,0xC4,0xC0,0x80,0xE0,
0x3C,0x07,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x30,0x38,0x70,0x60,
0xC0,0x01,0x0E,0x0C,0x0C,0x0C,0x0C,0x0C,
0x6D,0x8C,0x0C,0x0C,0x0C,0x0C,0x0C,0x08,
0x08,0xC8,0xFF,0x3F,0x0F,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xF0,0x30,0x30,0x30,0x30,0x30,0x30,
0x30,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xFE,0xFC,0xE0,0x00,0x00,0x00,
//參(標楷體) //'can' (font 2)
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x03,0x03,0x02,0x00,
0x00,0x00,0x00,0x00,0x01,0x03,0x0C,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x03,0x03,0x06,0x1F,0x1E,
0x60,0x60,0xCC,0x86,0xFE,0xC3,0x03,0x07,
0x0C,0x19,0x31,0x63,0x86,0x18,0x21,0x03,
0x06,0x18,0x01,0x03,0x0E,0x30,0xC0,0x00,
0x00,0x00,0x00,0x80,0x70,0x38,0xF8,0x30,
0x30,0x34,0x63,0xFF,0xF1,0x80,0x80,0xC0,
0x70,0x9C,0x8F,0x07,0x41,0xE0,0x80,0x30,
0x70,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x00,
0x00,0x00,0x80,0xFE,0xF8,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//觀(標楷體) //'guan' (font 2)
0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x07,
0x3D,0x01,0x00,0x03,0x0C,0x09,0x0F,0x02,
0x03,0x03,0x06,0x0C,0x1F,0x36,0x47,0x06,
0x06,0x07,0x07,0x06,0x06,0x06,0x00,0x00,
0x00,0x00,0x00,0x08,0x0C,0x08,0x1B,0x1E,
0x10,0x20,0x2F,0xD3,0x92,0x9F,0x40,0x30,
0x37,0xFC,0x30,0x3E,0xF0,0x30,0xFE,0x30,
0x3F,0xFF,0x01,0x03,0x04,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
0x7E,0x60,0x60,0x4F,0x78,0x40,0x43,0x7F,
0x40,0x40,0x7F,0x57,0x5B,0x32,0x32,0x62,
0x62,0xC2,0x82,0x02,0x03,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,
0xE0,0xE0,0xC0,0xC0,0xC0,0x40,0x40,0xC0,
0x40,0x40,0xC0,0x40,0x00,0x00,0x00,0x00,
0x04,0x04,0x06,0x06,0xFE,0xFC,0x00,0x00,

} ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0設定為輸入埠// P0 set to input port
	do{
	    DI=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0

}
void Command(cmd){
	P0=cmd ;
	DI=0 ;RW=0; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	DI=1 ;RW=0; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
void FillHWAN(unsigned int pidx)
{
	char i ,page,y;

	for(y=0 ; y < 64 ; y+=32){
	    for(page=7 ; page >= 0 ; page--){
		Command(0xb8+page) ; // X addr  ;
		Command(0x40+y) ;    // Y Addr ;
		for(i=0; i< 32  ;i++){
		    Data(hwan[pidx++]);
		}
	    }
	}
}
main()
{

	CS1=CS2=1 ;
	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // DISPLAY ON

	CS1=1; CS2=0 ;
	FillHWAN(0) ;
	CS1=0 ; CS2=1 ;
	FillHWAN(128*4) ;
	for(;;) ;
}
%}


@1
%{glcds2b.c
//
//  配合"繪圖型LCD(直排)實習板"//
//   在繪圖型LCD上顯示"歡迎參觀"//   Display Chinese word "huan ying can guan" on Graphic LCD
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit DI=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
sbit CS1=P1^3 ;
sbit CS2=P1^4 ;
unsigned char code hwan[]={
//歡(新細明體) //'huan' (font 1)
0x00,0x00,0x03,0x03,0x7F,0x03,0x03,0x22,
0x1F,0x18,0x18,0x18,0x1F,0x18,0x07,0x07,
0x04,0x0F,0x1C,0x3C,0x6F,0x8C,0x0C,0x0C,
0x0F,0x0C,0x0C,0x0C,0x0F,0x0C,0x0C,0x00,
0x00,0x00,0x8E,0x0C,0xFF,0x0C,0x0C,0xA0,
0xFF,0xD8,0xD8,0xD8,0xDF,0x90,0x18,0x1C,
0x31,0xFF,0x30,0x33,0xFF,0x30,0x30,0x33,
0xFF,0x30,0x30,0x31,0xFF,0x00,0x01,0x00,
0x00,0x00,0x07,0xC7,0xE4,0x04,0x0C,0x8C,
0xEF,0xC8,0xD0,0xD3,0xE3,0xE3,0x03,0x03,
0x83,0xC3,0x03,0x02,0x82,0x06,0x06,0x04,
0x8C,0x08,0x18,0xB0,0xE0,0xC0,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,
0xFE,0x08,0x18,0x90,0x10,0x20,0x00,0x00,
0x00,0x80,0x80,0x80,0x80,0x40,0x40,0x60,
0x20,0x30,0x18,0x1C,0x0E,0x07,0x00,0x00,
//迎(新細明體) //'ying' (font 1)
0x00,0x00,0x10,0x0E,0x03,0x01,0x00,0x00,
0x60,0x18,0x0E,0x06,0x00,0x00,0x00,0x00,
0x03,0x7F,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x02,0x0D,0x18,0x70,0x20,0x20,0x00,
0x00,0x00,0x00,0x21,0x1F,0x98,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x98,0x18,0x18,0x1B,0x1E,0x78,0x70,
0x20,0x00,0x00,0xC0,0x3E,0x07,0x00,0x00,
0x00,0x00,0xC0,0xE8,0x0F,0x0C,0x0C,0x0C,
0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
0x0C,0x0C,0x2C,0xCC,0x0C,0x0D,0x0C,0x0C,
0x0C,0x0C,0x0C,0x00,0x00,0xFF,0x00,0x00,
0x00,0x00,0x00,0x0E,0xFE,0x0C,0x0C,0x0C,
0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
0x0C,0x0C,0x0C,0x0C,0x0C,0xFC,0x38,0x20,
0x00,0x00,0x00,0x00,0x3E,0xFC,0x00,0x00,
//參(新細明體) //'can' (font 1)
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x07,
0x04,0x01,0x03,0x03,0x06,0x3F,0x3C,0x20,
0x00,0x00,0x03,0x0E,0x30,0x40,0x03,0x0C,
0x00,0x00,0x0F,0x00,0x00,0x00,0x1F,0x00,
0x00,0x04,0x07,0x0C,0x18,0x30,0xFF,0x80,
0x00,0x80,0xC0,0x31,0x1B,0xEF,0x0E,0x18,
0x30,0xC1,0x83,0x06,0x1C,0x70,0xC0,0x01,
0x0E,0x78,0xC0,0x00,0x03,0x3C,0xC0,0x00,
0x00,0x00,0x00,0x08,0x16,0x07,0xF9,0x00,
0x03,0x03,0x03,0x86,0xC4,0x7F,0x30,0x18,
0x86,0xE3,0x80,0x08,0x1E,0x38,0xE0,0x80,
0x01,0x07,0x1C,0x70,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,
0x00,0x80,0x20,0x10,0x78,0x8C,0x08,0x00,
0x00,0x80,0xF0,0x3E,0x08,0x00,0x80,0xE0,
0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//觀(新細明體) //'guan' (font 1)
0x00,0x00,0x07,0x07,0x06,0x7F,0x06,0x06,
0x31,0x3F,0x31,0x31,0x3F,0x31,0x04,0x07,
0x04,0x0C,0x1F,0x1C,0x2C,0x4F,0x0C,0x0C,
0x0F,0x0C,0x0C,0x0C,0x0F,0x0C,0x0C,0x00,
0x00,0x00,0x1C,0x1C,0x19,0xFF,0x18,0x10,
0xE3,0xFF,0xE3,0xE3,0xFF,0xE3,0x00,0x38,
0x20,0x26,0xFF,0x60,0x66,0xFF,0x60,0x66,
0xFF,0x60,0x60,0x63,0xFF,0x00,0x01,0x00,
0x00,0x00,0x40,0x3F,0x30,0xB0,0x30,0x30,
0x30,0xBF,0x30,0x30,0x30,0x30,0x3F,0x30,
0x30,0x30,0x30,0x3F,0x36,0x34,0x04,0x0C,
0x0C,0x08,0x18,0x30,0x20,0xC0,0x80,0x00,
0x00,0x00,0x08,0xFC,0x1C,0x18,0x18,0x18,
0x18,0xF8,0x18,0x18,0x18,0x18,0xF8,0x18,
0x18,0x18,0x18,0xF8,0xD8,0xD8,0xC0,0xC0,
0xC4,0xC4,0xC4,0xC4,0xC4,0xFE,0x00,0x00,
//歡(標楷體) //'huan' (font 2)
0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,
0x0F,0x00,0x00,0x00,0x07,0x02,0x02,0x03,
0x01,0x01,0x03,0x03,0x05,0x09,0x31,0x01,
0x01,0x01,0x01,0x03,0x03,0x01,0x00,0x00,
0x00,0x00,0x00,0x06,0x07,0x86,0x87,0x87,
0xC4,0x44,0x81,0xFF,0x69,0x49,0xCF,0x00,
0x98,0x8B,0xFF,0x18,0x1F,0xF8,0x18,0x3F,
0xF8,0x18,0x7F,0xC0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x06,0x06,0xC6,0x0E,
0x0C,0x0C,0x98,0xDF,0x94,0x30,0xA0,0x46,
0x06,0x06,0x04,0x06,0x0E,0x0D,0x09,0x18,
0x18,0x30,0xE0,0xC0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xE0,0xF8,0x70,0x60,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,
0xC0,0x60,0x78,0x3E,0x00,0x00,0x00,0x00,
//迎(標楷體) //'ying' (font 2)
0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x03,
0x01,0x00,0x00,0x00,0x01,0x07,0x1F,0x01,
0x01,0x02,0x01,0x01,0x00,0x00,0x00,0x1F,
0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0xC0,0xC7,0x06,0x06,0x06,0xC6,0xC6,0x86,
0x06,0x07,0x07,0x86,0xC4,0xC0,0x80,0xE0,
0x3C,0x07,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x30,0x38,0x70,0x60,
0xC0,0x01,0x0E,0x0C,0x0C,0x0C,0x0C,0x0C,
0x6D,0x8C,0x0C,0x0C,0x0C,0x0C,0x0C,0x08,
0x08,0xC8,0xFF,0x3F,0x0F,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xF0,0x30,0x30,0x30,0x30,0x30,0x30,
0x30,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xFE,0xFC,0xE0,0x00,0x00,0x00,
//參(標楷體) //'can' (font 2)
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x03,0x03,0x02,0x00,
0x00,0x00,0x00,0x00,0x01,0x03,0x0C,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x03,0x03,0x06,0x1F,0x1E,
0x60,0x60,0xCC,0x86,0xFE,0xC3,0x03,0x07,
0x0C,0x19,0x31,0x63,0x86,0x18,0x21,0x03,
0x06,0x18,0x01,0x03,0x0E,0x30,0xC0,0x00,
0x00,0x00,0x00,0x80,0x70,0x38,0xF8,0x30,
0x30,0x34,0x63,0xFF,0xF1,0x80,0x80,0xC0,
0x70,0x9C,0x8F,0x07,0x41,0xE0,0x80,0x30,
0x70,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x00,
0x00,0x00,0x80,0xFE,0xF8,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//觀(標楷體) //'guan' (font 2)
0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x07,
0x3D,0x01,0x00,0x03,0x0C,0x09,0x0F,0x02,
0x03,0x03,0x06,0x0C,0x1F,0x36,0x47,0x06,
0x06,0x07,0x07,0x06,0x06,0x06,0x00,0x00,
0x00,0x00,0x00,0x08,0x0C,0x08,0x1B,0x1E,
0x10,0x20,0x2F,0xD3,0x92,0x9F,0x40,0x30,
0x37,0xFC,0x30,0x3E,0xF0,0x30,0xFE,0x30,
0x3F,0xFF,0x01,0x03,0x04,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
0x7E,0x60,0x60,0x4F,0x78,0x40,0x43,0x7F,
0x40,0x40,0x7F,0x57,0x5B,0x32,0x32,0x62,
0x62,0xC2,0x82,0x02,0x03,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,
0xE0,0xE0,0xC0,0xC0,0xC0,0x40,0x40,0xC0,
0x40,0x40,0xC0,0x40,0x00,0x00,0x00,0x00,
0x04,0x04,0x06,0x06,0xFE,0xFC,0x00,0x00,

} ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0設定為輸入埠// P0 set to input port
	do{
	    DI=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0

}
void Command(cmd){
	P0=cmd ;
	DI=0 ;RW=0; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	DI=1 ;RW=0; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
void FillHWAN(unsigned char code *pp)
{
	char i ,page,y;

	for(y=0 ; y < 64 ; y+=32){
	    for(page=7 ; page >= 0 ; page--){
		Command(0xb8+page) ; // X addr  ;
		Command(0x40+y) ;    // Y Addr ;
		for(i=0; i< 32  ;i++){
		    Data(*pp++);
		}
	    }
	}
}
main()
{

	CS1=CS2=1 ;
	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // DISPLAY ON

	CS1=1; CS2=0 ;
	FillHWAN(&hwan[0]) ;
	CS1=0 ; CS2=1 ;
	FillHWAN(&hwan[128*4]) ;
	for(;;) ;
}
%}


@1
%{gscop.c
//
//   配合"示波器字幕控制實習板"//   P0 control horizontal position(X),
//   P0控制亮點水平方向位置, P1控制亮點垂直方向位置, //   P1 control vertical position(Y),
//   顯示 HELLO !! 字串.並閃爍. //     Display "HELLO !!" and  twinkle
//       	
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>

char code tbl[8][8]=
{
{0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x00},
{0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00},
{0xf0, 0x60, 0x60, 0x60, 0x60, 0x62, 0xfe, 0x00},
{0xf0, 0x60, 0x60, 0x60, 0x60, 0x62, 0xfe, 0x00},
{0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x18, 0x3c, 0x3c, 0x18, 0x18, 0x00, 0x18, 0x00},
{0x18, 0x3c, 0x3c, 0x18, 0x18, 0x00, 0x18, 0x00},
};


main()
{
	char t;
	int i,j, x=20, y=20;

	P0 =0;
	P1 =0;
	
	for(;;){
	    for(i=0;i<8 ;i++){
		for(j=0; j<8*8; j++){
		    t=tbl[j>>3][i];
		    t=t<<(j&7);
		    if(t&0x80){
			P0 = j+x;	
			P1 = i+y;
		    }
		}
	    }
	    P0=0;
	    P1=0;
	    for(i=0; i < 30000; i++);
	}
}
%}


@1
%{int0.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char Count ;
main()
{
	P0=Count=0 ;
	IT0=1 ; // 偵測負緣觸發動作// detect negative edge trigger
	EA=1;
	EX0=1 ;
	for(;;) ;
}
void external0(void ) interrupt 0
{
	Count++ ;
	P0=Count ;
}
%}


@1
%{int1.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char Shift ;
main()
{
	P0=Shift=1 ;
	IT1=1 ; // Detect negative edge trigger 	
	EA=1;
	EX1=1 ;
	for(;;) ;
}
void external1(void ) interrupt 2
{
	Shift <<=1 ;
	if(Shift == 0){
	    Shift=1 ;
	}
	P0=Shift;
}
%}


%{key1.a51
;
; 配合"單鍵實習板";
;   按鍵的彈跳現象(bounce) ;   The phenomenon of Key bounce
;
KEY1	REGEQU	P1.0
START:
	MOV	P0,#0
LOOP:
	JB	KEY1,$
	INC	P0
	JNB	KEY1,$
	SJMP	LOOP
	END
%}


@1
%{key1.c
//
//  配合"單鍵實習板"//
//   按鍵的彈跳現象(bounce) //   The phenomenon of Key bounce
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit KEY1=P1 ^0 ;
main()
{
	P0=0 ;
	for(;;){
	    while(KEY1 ==1) ;
	    P0++;
	    while(KEY1==0) ;
	}
}
%}


%{key2.a51
;
; 配合"單鍵實習板";
;   配合解彈跳(debounce)的程式設計;   Using debounce technique on key-scanning design
;
KEY1	REGEQU	P1.0
START:
	MOV	P0,#0
LOOP1:
	JB	KEY1,$
	ACALL	DELAY20MS
	JB	KEY1,LOOP1
	INC	P0
LOOP2:
	JNB	KEY1,$
	ACALL	DELAY20MS
	JNB	KEY1,LOOP2
	SJMP	LOOP1
DELAY20MS:
	ACALL	DELAY10MS
	ACALL	DELAY10MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


@1
%{key2.c
//
//  配合"單鍵實習板"//
//   配合解彈跳(debounce)的程式設計//   Using debounce technique on key-scanning design
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit KEY1=P1 ^0 ;
void delay20ms()
{
	Delay10ms();
	Delay10ms();
}

main()
{
	P0=0 ;
	for(;;){
	    do{
		while(KEY1 ==1) ;
		delay20ms() ;
	    }
	    while(KEY1 == 1) ;
	    P0++;
	    do{
		while(KEY1==0) ;
		delay20ms() ;
	    }
	    while(KEY1== 0) ;    
	}
}
%}


%{key3.a51
;
; 配合"4*5鍵盤實習板";
;   簡單鍵盤掃瞄設計;   4*5 Keyboard-scanning design

;
KEY1	REGEQU	P1.0
ROW	REGEQU	R2
KEYFLAG	REGEQU	R3

START:
	MOV	P0,#0
LOOP1:
	MOV	P1,#0FEH
	MOV	ROW,#0
NEXT1:
	MOV	A,P2
	ANL	A,#0FH
	CJNE	A,#0FH,OUT1
	MOV	A,P1
	RL	A
	MOV	P1,A
 	INC	ROW
	CJNE	ROW,#5,NEXT1
	SJMP	LOOP1
OUT1:
	ACALL	DELAY20MS
	MOV	A,P2
	ANL	A,#0FH
	CJNE	A,#0FH,OUT2
	SJMP	LOOP1
OUT2:
	MOV	DPTR,#IDXCOL
	MOVC	A,@A+DPTR
	MOV	B,A
	MOV	A,ROW
;         setb   F0
	RL	A
	RL	A
	ANL	A,#011111100B
	ADD	A,B
	MOV	P0,A
LOOP2:
	MOV	A,P2
	ANL	A,#0FH
	CJNE	A,#0FH,LOOP2
	ACALL	DELAY20MS
	MOV	A,P2
	ANL	A,#0FH
	CJNE	A,#0FH,LOOP2
	SJMP	LOOP1
DELAY20MS:
	ACALL	DELAY10MS
	ACALL	DELAY10MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

IDXCOL:
	DB 0,1,0,2
	DB 0,1,0,3
	DB 0,1,0,2
	DB 0,1,0,4
	END
%}


@1
%{key3.c
//
//  配合"4*5鍵盤實習"//
//   簡單鍵盤掃瞄設計//  4*5 Keyboard-scanning design
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"

void delay20ms() ;
unsigned char code IdxCol[]= {
	0 , 1 , 0 , 2 ,
	0 , 1 , 0 , 3 ,
	0 , 1 , 0 , 2 ,
	0 , 1 , 0 , 4
} ;
main()
{
	char row ;
	char keyflag ;
	char tP1 ;
	P0=0 ;
	for(;;){
	    do{
		for(P1=tP1=0xfe,row=0 ,keyflag=0 ; (row < 5);row++){
		    if((P2&0xf) != 0xf){
			keyflag=1 ;
			break ;
		    }
		    tP1 <<=1 ;
		    tP1 +=1 ;
		    P1=tP1 ;
		}
		if(keyflag== 1){
		    delay20ms() ;
		    if((P2&0xf) ==0xf){
			keyflag= 0 ;
		    }
		}
	    }
	    while(keyflag==0) ;
	    P0=row*4+IdxCol[P2&0xf];
	    do{
		while((P2&0xf) != 0xf) ;
		delay20ms() ;
	    }
	    while((P2 &  0xf) != 0xf) ;
	}
}
void delay20ms()
{
	Delay10ms();
	Delay10ms();
}
%}


%{lcd1a.a51
;
; 配合"文字型LCD實習板";
;   在文字型LCD上顯示"Hello!!"(用延遲的方式和LCD同步) ;   Display "Hello!!" on Text LCD (synchronize by delay method)
;
START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ;採用8位元資料存取/雙列字/5*10點矩陣字型; 8bits data bus/2 lines/5*10dots
	ACALL	COMMAND
	MOV	A,#01110B   ;顯示器ON/游標被顯示在位址計數器; display ON
	ACALL	COMMAND
	MOV	A,#1     ;清除全螢幕;clear display
	ACALL	COMMAND
	ACALL	DELAY2MS
	MOV	A,#010000000B   ;設定DD RAM位址為0;DD RAM address =0
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP
ENDMES:
	SJMP	$
COMMAND:
	MOV	P0,A
	MOV	P1,#0100B    ;E=1 , RW=0 , RS=0
	MOV	P1,#0000B    ;E=0 , RW=0 , RS=0
	ACALL	DELAY40US
	RET
SDATA:
	MOV	P0,A
	MOV	P1,#0101B    ;E=1 , RW=0 , RS=1
	MOV	P1,#0001B    ;E=0 , RW=0 , RS=1
	ACALL	DELAY40US
	RET

DELAY40US:
	MOV	R1,#20
	DJNZ	R1,$
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
	END
%}


%{lcd1b.a51
;
; 配合"文字型LCD實習板";
;   在文字型LCD上顯示"Hello!!"(用延遲的方式和LCD同步) ;   Display "Hello!!" on Text LCD (synchronize by delay method)
;
START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ;採用8位元資料存取/雙列字/5*10點矩陣字型; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B    ;顯示器ON/游標被顯示在位址計數器; display ON
	ACALL	COMMAND
	MOV	A,#1     ;清除全螢幕;clear display
	ACALL	COMMAND
	ACALL	DELAY2MS
	MOV	A,#010000000B   ;設定DD RAM位址為0;DD RAM address =0
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP
ENDMES:
	SJMP	$
COMMAND:
	MOV	P0,A
	MOV	P1,#0100B    ;E=1 , RW=0 , RS=0
	MOV	P1,#0000B    ;E=0 , RW=0 , RS=0
	ACALL	DELAY40US
	RET
SDATA:
	MOV	P0,A
	MOV	P1,#0101B    ;E=1 , RW=0 , RS=1
	MOV	P1,#0001B    ;E=0 , RW=0 , RS=1
;	ACALL	DELAY40US
;	RET

DELAY40US:
	MOV	R1,#20
	DJNZ	R1,$
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
	END
%}


@1
%{lcd1.c
//
//  配合"文字型LCD實習板"//
//   在文字型LCD上顯示"Hello!!"(用延遲的方式和LCD同步) //   Display "Hello!!" on Text LCD (synchronize by delay method)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
char code mes[]="Hello!!" ;
void delay2ms()
{
	Delay1ms() ;
	Delay1ms() ;
}
void delay5ms()
{
	delay2ms() ;
	delay2ms() ;
	Delay1ms() ;
}
void delay40us()
{
	int i ;
	for(i=0 ; i < 5 ;i++) ;
}
void Command(cmd){
	P0=cmd ;
	P1=0x4 ;    //E=1 , RW=0 , RS=0
	P1=0;       //E=0 , RW=0 , RS=0
	delay40us() ;
}
void Data(char data1){
	P0=data1;
	P1=0x5;     //E=1 , RW=0 , RS=1
	P1=0x1 ;    //E=0 , RW=0 , RS=1
	delay40us() ;
}
main()
{
	char code1 ;
	char i ;
	char code *pp=mes ;
	delay5ms() ;            // wait for LCD Power-on Ready
	Command(0x3f) ;         // 採用8位元資料存取/雙列字/5*10點矩陣字型// 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;          //顯示器ON/游標被顯示在位址計數器// display ON
	Command(0x1) ;          // 清除全螢幕// clear display
	delay2ms() ;
	Command(0x80) ;         // 設定DD RAM位址為0// DD RAM address=0
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	for(;;) ;
}
%}


%{lcd2.a51
;
; 配合"文字型LCD實習板";
;   在文字型LCD上顯示"Hello!!"(用延遲的方式和LCD同步,使用位元運算指令) ;   Display "Hello!!" on Text LCD ( synchronize by delay method , and bit operation instruction)
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ;採用8位元資料存取/雙列字/5*10點矩陣字型; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B   ;顯示器ON/游標被顯示在位址計數器; display ON
	ACALL	COMMAND
	MOV	A,#1     ;清除全螢幕;clear display
	ACALL	COMMAND
	ACALL	DELAY2MS
	MOV	A,#010000000B   ;設定DD RAM位址為0;DD RAM address =0
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP
ENDMES:
	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	ACALL	DELAY40US
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
DELAY40US:
	MOV	R1,#20
	DJNZ	R1,$
	RET

DELAY5MS:
 	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
	END
%}


@1
%{lcd2.c
//
//  配合"文字型LCD實習板"//
//   在文字型LCD上顯示"Hello!!"(用延遲的方式和LCD同步,使用位元運算指令) //   Display "Hello!!" on Text LCD ( synchronize by delay method , and bit operation instruction)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes[]="Hello!!" ;
void delay2ms()
{
	Delay1ms() ;
	Delay1ms() ;
}
void delay5ms()
{
	delay2ms() ;
	delay2ms() ;
	Delay1ms() ;
}
void delay40us()
{
	int i ;
	for(i=0 ; i < 5 ;i++) ;
}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ;
	delay40us() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ;
	delay40us() ;
}
main()
{
	char code1 ;
	char i ;
	char code *pp=mes ;

	delay5ms() ;      // wait for LCD Power-on Ready
	Command(0x3f) ;   // 採用8位元資料存取/雙列字/5*10點矩陣字型// 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;    //顯示器ON/游標被顯示在位址計數器// display ON
	Command(0x1) ;    // 清除全螢幕// clear display
	delay2ms() ;
	Command(0x80) ;   // 設定DD RAM位址為0// DD RAM address=0
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	for(;;) ;
}
%}


%{lcd3.a51
;
; 配合"文字型LCD實習板";
;   在文字型LCD上顯示"Hello!!"用檢查BF的方式和LCD同步,使用位元運算指令) ;   Display "Hello!!" on Text LCD ( synchronize by checking BF method , and bit operation instruction)
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ;採用8位元資料存取/雙列字/5*10點矩陣字型; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B   ;顯示器ON/游標被顯示在位址計數器; display ON
	ACALL	COMMAND
	MOV	A,#1     ;清除全螢幕;clear display
	ACALL	COMMAND
;	ACALL	DELAY2MS
	MOV	A,#010000000B   ;設定DD RAM位址為0;DD RAM address =0
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP
ENDMES:
	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	SETB	RW
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
	SETB	RW
WAITLCD:
	MOV	P0,#0FFH  ; P0設定為輸入埠; P0 set to input port
WAITLCD1:
	CLR	RS
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
	END
%}


@1
%{lcd3.c
//
//  配合"文字型LCD實習板"//
//   在文字型LCD上顯示"Hello!!"用檢查BF的方式和LCD同步,使用位元運算指令) //   Display "Hello!!" on Text LCD ( synchronize by checking BF method , and bit operation instruction)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes[]="Hello!!" ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0設定為輸入埠// P0 set to input port
	do{
  	    RS=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0

}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
main()
{
	char code *pp=mes ;

	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // 採用8位元資料存取/雙列字/5*10點矩陣字型// 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;     //顯示器ON/游標被顯示在位址計數器// display ON
	Command(0x1) ;     // 清除全螢幕 // clear display
	delay2ms() ;
 	Command(0x80) ;    // 設定DD RAM位址為0// DD RAM address=0
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	for(;;) ;
}
%}


%{lcd4a.a51
;
; 配合"文字型LCD實習板";   Display 4 "Hello!!" on Text LCD,
;   在文字型LCD上顯示4個"Hello!!",顯示位置分別在第一行的第一位置,第十一位置及;      at line 1 location 1 , line 1 location 11 ,
;                                               第二行的第一位置,第十一位置;         line 2 location 1 , and line 2 location 11
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ;採用8位元資料存取/雙列字/5*10點矩陣字型; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B   ;顯示器ON/游標被顯示在位址計數器; display ON
	ACALL	COMMAND
	MOV	A,#1     ;清除全螢幕;clear display
	ACALL	COMMAND
	ACALL	DELAY2MS

	MOV	A,#010000000B   ;設定DD RAM位址為0-->第一行的第一位置; DD RAM address0-->line 1 location 1
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP1:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES1
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP1
ENDMES1:

	MOV	A,#010000000B+10   ;設定DD RAM位址為10-->第一行的第十一位置; DD RAM address=10-->line 1 location 11
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP2:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES2
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP2
ENDMES2:
	MOV	A,#010000000B+40H   ;設定DD RAM位址為40H--->第二行的第一位置; DD RAM address=40H--->line 2 location 1
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP3:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES3
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP3
ENDMES3:
	MOV	A,#010000000B+40H+10   ;設定DD RAM位址為40H+10--->第二行的第十一位置;DD RAM address=40H+10--->line 2 location 11
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP4:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES4
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP4
ENDMES4:
	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
WAITLCD:
	MOV	P0,#0FFH  ; P0設定為輸入埠; P0 set to input port
WAITLCD1:
	CLR	RS
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
	END
%}


%{lcd4b.a51
;
; 配合"文字型LCD實習板";   Display 4 "Hello!!" on Text LCD,
;   在文字型LCD上顯示4個"Hello!!",顯示位置分別在第一行的第一位置,第十一位置及;      at line 1 location 1 , line 1 location 11 ,
;                                               第二行的第一位置,第十一位置;         line 2 location 1 , and line 2 location 11
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

DSPSTR	MACRO	LOC
%1 	LOCAL	LOOP,ENDMES
	MOV	A,#LOC
	ACALL	COMMAND
	MOV	DPTR,#MES
%0 $1:
%1 LOOP:
%2 LOOP#:
	CLR	A
	MOVC	A,@A+DPTR
%0 	JZ	$2
%1 	JZ	ENDMES
%2 	JZ	ENDMES#
	ACALL	SDATA
	INC	DPTR
%0 	SJMP	$1
%0 $2:
%1 	SJMP	LOOP
%1 ENDMES:
%2 	SJMP   LOOP#
%2 ENDMES#:
	ENDM

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ;採用8位元資料存取/雙列字/5*10點矩陣字型; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B   ;顯示器ON/游標被顯示在位址計數器; display ON
	ACALL	COMMAND
	MOV	A,#1     ;清除全螢幕;clear display
	ACALL	COMMAND

	DSPSTR	010000000B      ;設定DD RAM位址為0-->第一行的第一位置; DD RAM address = 0-->line 1 location 1
	DSPSTR	010000000B+10   ;設定DD RAM位址為10-->第一行的第十一位置; DD RAM address =10--> line 1 location 11
	DSPSTR	010000000B+40H   ;設定DD RAM位址為40H--->第二行的第一位置; DD RAM address =40H---> line 2 location 1
	DSPSTR	010000000B+40H+10   ;設定DD RAM位址為40H+10--->第二行的第十一位置; DD RAM address =40H+10---> line 2 location 11

	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
WAITLCD:
	MOV	P0,#0FFH  ; P0設定為輸入埠; P0 set to input port
WAITLCD1:
	CLR	RS
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
	END
%}


%{lcd4c.a51
;
; 配合"文字型LCD實習板";   Display 4 "Hello!!" on Text LCD,
;   在文字型LCD上顯示4個"Hello!!",顯示位置分別在第一行的第一位置,第十一位置及;     at line 1 location 1 , line 1 location 11 ,
;                                               第二行的第一位置,第十一位置;      line 2 location 1 , and line 2 location 11
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ;採用8位元資料存取/雙列字/5*10點矩陣字型; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B   ;顯示器ON/游標被顯示在位址計數器; display ON
	ACALL	COMMAND
	MOV	A,#1     ;清除全螢幕;clear display
	ACALL	COMMAND

	MOV	R0,#0
NEXT1:
	MOV	DPTR,#LOC
	MOV	A,R0
	MOVC	A,@A+DPTR
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP
ENDMES:
	INC	R0
	CJNE	R0,#4,NEXT1

	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
WAITLCD:
	MOV	P0,#0FFH  ; P0設定為輸入埠; P0 set to input port
WAITLCD1:
	CLR	RS
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET

DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
LOC:	DB	010000000B
	DB	010000000B+10
	DB	010000000B+40H
	DB	010000000B+40H+10
	END
%}


%{lcd4d.a51
;
; 配合"文字型LCD實習板"; Display 4 "Hello!!" on Text LCD,
;   在文字型LCD上顯示4個"Hello!!",顯示位置分別在第一行的第一位置,第十一位置及;     at line 1 location 1 , line 1 location 11 ,
;                                               第二行的第一位置,第十一位置;       line 2 location 1 , and line 2 location 11
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ;採用8位元資料存取/雙列字/5*10點矩陣字型; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B   ;顯示器ON/游標被顯示在位址計數器; display ON
	ACALL	COMMAND
	MOV	A,#1     ;清除全螢幕;clear display
	ACALL	COMMAND

	MOV	R0,#4
NEXT1:
	MOV	DPTR,#LOC-1
	MOV	A,R0
	MOVC	A,@A+DPTR
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP
ENDMES:
	DJNZ	R0,NEXT1
	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
WAITLCD:
	MOV	P0,#0FFH  ; P0設定為輸入埠; P0 set to input port
WAITLCD1:
	CLR	RS
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
LOC:	DB	010000000B+40H+10
	DB	010000000B+40H
	DB	010000000B+10
	DB	010000000B
	END
%}


@1
%{lcd4a.c
//
//  配合"文字型LCD實習板"//   Display 4 "Hello!!" on Text LCD,
//   在文字型LCD上顯示4個"Hello!!",顯示位置分別在第一行的第一位置,第十一位置及//     at line 1 location 1 , line 1 location 11 ,
//                                               第二行的第一位置,第十一位置//      line 2 location 1 , and line 2 location 11
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes[]="Hello!!" ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++)  Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0設定為輸入埠// P0 set to input port
	do{
	    RS=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0
}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
main()
{
	char code *pp=mes ;

	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // 採用8位元資料存取/雙列字/5*10點矩陣字型// 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;     //顯示器ON/游標被顯示在位址計數器// display ON
	Command(0x1) ;     // 清除全螢幕// clear display
	delay2ms() ;
 	Command(0x80) ;    // 設定DD RAM位址為0---->第一行的第一位置// DD RAM address=0
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	Command(0x80+10) ;  // 設定DD RAM位址為10-->第一行的第十一位置// DD RAM address=10-->line 1 location 11
	pp=mes ;
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	Command(0x80+0x40) ;  // 設定DD RAM位址為0x40-->第二行的第一位置// DD RAM address=0x40--> line 2 location 1
	pp=mes ;
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	Command(0x80+0x40+10) ;  // 設定DD RAM位址為0x40+10-->第二行的第十一位置// DD RAM address=0x40+10--> line 2 location 11
	pp=mes ;
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	for(;;) ;
}
%}


@1
%{lcd4b.c
//
//  配合"文字型LCD實習板"//   Display 4 "Hello!!" on Text LCD,
//   在文字型LCD上顯示4個"Hello!!",顯示位置分別在第一行的第一位置,第十一位置及//     at line 1 location 1 , line 1 location 11 ,
//                                               第二行的第一位置,第十一位置//       line 2 location 1 , and line 2 location 11
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes[]="Hello!!" ;
#define DSPSTR(loc)		\
	Command(loc) ;		\
	for(pp=mes; *pp !=0 ;){	\
	    Data(*pp++);		\
	}

void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0設定為輸入埠// P0 set to input port
	do{
	    RS=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0
}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
main()
{
	char code *pp ;

	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // 採用8位元資料存取/雙列字/5*10點矩陣字型// 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;     //顯示器ON/游標被顯示在位址計數器// display ON
	Command(0x1) ;     // 清除全螢幕 // clear display

	DSPSTR(0x80) ;          //第一行的第一位置// line 1 location 1
	DSPSTR(0x80+10) ;       //第一行的第十一位置// line 1 location 11
	DSPSTR(0x80+0x40) ;     //第二行的第一位置// line 2 location 1
	DSPSTR(0x80+0x40+10) ;  //第二行的第十一位置// line 2 location 11
	for(;;) ;
}
%}


@1
%{lcd4c.c
//
//  配合"文字型LCD實習板"//   Display 4 "Hello!!" on Text LCD,
//   在文字型LCD上顯示4個"Hello!!",顯示位置分別在第一行的第一位置,第十一位置及//     at line 1 location 1 , line 1 location 11 ,
//                                               第二行的第一位置,第十一位置//       line 2 location 1 , and line 2 location 11
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes[]="Hello!!" ;
unsigned char code loc[]= {0x80,0x80+10 , 0x80+0x40,0x80+0x40+10} ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++)  Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0設定為輸入埠// P0 set to input port
	do{
	    RS=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0
}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
main()
{
	char code *pp ;
	char i ;	

	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // 採用8位元資料存取/雙列字/5*10點矩陣字型// 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;     //顯示器ON/游標被顯示在位址計數器// display ON
	Command(0x1) ;     // 清除全螢幕// clear display
	for(i=0 ; i < 4 ; i++){
   	    Command(loc[i]) ;
	    for(pp=mes; *pp !=0 ;){
		Data(*pp++);
	    }
	}
	for(;;) ;
}
%}


%{lcd5.a51
;
; 配合"文字型LCD實習板";
;   在文字型LCD上顯示"1998年10月16日";   Display "1998"nian"10"yue"16"ri"" on Text LCD
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ;採用8位元資料存取/雙列字/5*10點矩陣字型; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B   ;顯示器ON/游標被顯示在位址計數器; display ON
	ACALL	COMMAND
	MOV	A,#1     ;清除全螢幕;clear display
	ACALL	COMMAND

;      設定自定字型 年,月,日;      define font of  "nian" "yue" "ri"
	MOV	A,#001000000B   ;設定CG RAM位址為0;CG RAM address=0
	ACALL	COMMAND
	MOV	DPTR,#CG
	MOV	R0,#3*8
LOOP1:
	CLR	A
	MOVC	A,@A+DPTR
	ACALL	SDATA
	INC	DPTR
	DJNZ	R0,LOOP1

	MOV	A,#010000000B   ;設定DD RAM位址為0; DD RAM address=0
	ACALL	COMMAND
	MOV	DPTR,#MES
	MOV	R0,#11
LOOP2:
	CLR	A
	MOVC	A,@A+DPTR
	ACALL	SDATA
	INC	DPTR
	DJNZ	R0,LOOP2

	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	SETB	RW
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
	SETB	RW
WAITLCD:
	MOV	P0,#0FFH  ; P0設定為輸入; P0 set to input port
WAITLCD1:
	CLR	RS
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"1998",0,"10",1,"16",2
CG:	DB	010H , 01fH , 002H , 00fH , 00aH , 0ffH , 002H , 000H  ; 年; "nian"
	DB	00fH , 009H , 00fH , 009H , 00fH , 009H , 013H , 000H  ; 月; "yue"
	DB	00fH , 009H , 009H , 00fH , 009H , 009H , 00fH , 000H  ; 日; "ri"

	END
%}


@1
%{lcd5.c
//
//  配合"文字型LCD實習板"//
//   在文字型LCD上顯示"1998年10月16日"//   Display "1998"nian"10"yue"16"ri"" on Text LCD
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes[]="1998\00010\00116\002" ;
char code CG[]={
	0x10 , 0x1f , 0x02 , 0x0f , 0x0a , 0xff , 0x02 , 0x00 , // 年// "nian"
	0x0f , 0x09 , 0x0f , 0x09 , 0x0f , 0x09 , 0x13 , 0x00 , // 月// "yue"
	0x0f , 0x09 , 0x09 , 0x0f , 0x09 , 0x09 , 0x0f , 0x00 , // 日// "ri"
} ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0設定為輸入埠// P0 set to input port
	do{
	    RS=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0

}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
main()
{
	char code *pp ;
	char i ;

	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // 採用8位元資料存取/雙列字/5*10點矩陣字型// 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;     //顯示器ON/游標被顯示在位址計數器// display ON
	Command(0x1) ;     // 清除全螢幕// clear display
	// 設定自定字型 年,月,日// define font of  "nian" "yue" "ri"
	Command(0x40) ;   //設定CG RAM位址為0// CG RAM address=0
	pp= CG ;
	for(i=0 ; i < 3*8 ; i++){
	    Data(*pp++) ;
	}
	Command(0x80) ;    // 設定DD RAM位址為0// DD RAM address=0
	for(pp= mes,i=0; i<11 ;i++){
	    Data(*pp++);
	}
	for(;;) ;
}
%}

%{lcd6.a51
;
; 配合"文字型LCD實習板";
;   在文字型LCD上做雙列字左(右)移;   Test Text LCD in double-line shift the left(right) mode
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ;採用8位元資料存取/雙列字/5*10點矩陣字型; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B   ;顯示器ON/游標被顯示在位址計數器; display ON
	ACALL	COMMAND
	MOV	A,#1     ;清除全螢幕;clear display
	ACALL	COMMAND
	ACALL	DELAY2MS
	MOV	A,#010000000B   ;設定DD RAM位址為0;DD RAM address =0
	ACALL	COMMAND
	MOV	DPTR,#MES1
LOOP1:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES1
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP1
ENDMES1:

	MOV	A,#011000000B   ;設定DD RAM位址為40h(第二行) ; DD RAM address=40h(line 2)
	ACALL	COMMAND
	MOV	DPTR,#MES2
LOOP2:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES2
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP2
ENDMES2:
LOOP3:
	MOV	A,#18H     ;18H---左移/1CH---右移;18H---left shift/1CH---right shift
	ACALL	COMMAND
	LCALL	Delay1s
	SJMP	LOOP3
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	ACALL	DELAY40US
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
DELAY40US:
	MOV	R1,#20
	DJNZ	R1,$
	RET

DELAY5MS:
 	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES1:	DB	"          111111111122222222223333333333",0
MES2:	DB	"0123456789012345678901234567890123456789",0
	END
%}


@1
%{lcd6.c
//
//  配合"文字型LCD實習板"//
//   在文字型LCD上做雙列字左(右)移//   Test Text LCD in double-line shift the left(right) mode
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes1[]="          111111111122222222223333333333" ;
char code mes2[]="0123456789012345678901234567890123456789" ;
void delay2ms()
{
	Delay1ms() ;
	Delay1ms() ;
}
void delay5ms()
{
	delay2ms() ;
	delay2ms() ;
	Delay1ms() ;
}
void delay40us()
{
	int i ;
	for(i=0 ; i < 5 ;i++) ;
}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ;
	delay40us() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ;
	delay40us() ;
}
main()
{
	char code1 ;
	char i ;
	char code *pp=mes1 ;

	delay5ms() ;      // wait for LCD Power-on Ready
	Command(0x3f) ;   // 採用8位元資料存取/雙列字/5*10點矩陣字型// 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;    //顯示器ON/游標被顯示在位址計數器// display ON
	Command(0x1) ;    // 清除全螢幕// clear display
	delay2ms() ;
	Command(0x80) ;   // 設定DD RAM位址為0// DD RAM address=0
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	Command(0xC0) ;   // 設定DD RAM位址為40H(第二行) // DD RAM address=40H(line 2)
	pp=mes2 ;
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	for(;;){
	    Command(0x18) ;// 0x18---左移/0x1c----右移// 0x18---left shift/0x1c----right shift
	    Delay1s() ;
	}
}
%}

%{lcd7.a51
;
; 配合"文字型LCD實習板";
;   在文字型LCD上做單列字左(右)移;   Test Text LCD in single-line shift the left(right) mode
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0110111B  ;採用8位元資料存取/單列字/5*10點矩陣字型; 8 bits data bus/1 line/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B   ;顯示器ON/游標被顯示在位址計數器; display ON
	ACALL	COMMAND
	MOV	A,#1     ;清除全螢幕;clear display
	ACALL	COMMAND
	ACALL	DELAY2MS
	MOV	A,#010000000B   ;設定DD RAM位址為0;DD RAM address =0
	ACALL	COMMAND
	MOV	DPTR,#MES1
LOOP1:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES1
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP1
ENDMES1:
LOOP3:
	MOV	A,#18H     ;18H---左移/1CH---右移;18H---left shift/1CH---right shift
	ACALL	COMMAND
	LCALL	Delay1s
	SJMP	LOOP3
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	ACALL	DELAY40US
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
DELAY40US:
	MOV	R1,#20
	DJNZ	R1,$
	RET

DELAY5MS:
 	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES1:	DB	"0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ",0
	END
%}


@1
%{lcd7.c
//
//  配合"文字型LCD實習板"//
//   在文字型LCD上做單列字左(右)移//   Test Text LCD in single-line shift the left(right) mode
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes1[]="0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 " ;
void delay2ms()
{
	Delay1ms() ;
	Delay1ms() ;
}
void delay5ms()
{
	delay2ms() ;
	delay2ms() ;
	Delay1ms() ;
}
void delay40us()
{
	int i ;
	for(i=0 ; i < 5 ;i++) ;
}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ;
	delay40us() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ;
	delay40us() ;
}
main()
{
	char code1 ;
	char i ;
	char code *pp=mes1 ;

	delay5ms() ;      // wait for LCD Power-on Ready
	Command(0x37) ;   // 採用8位元資料存取/單列字/5*10點矩陣字型// 8 bits data bus/1 lines/5*10 dots
	Command(0xe) ;    //顯示器ON/游標被顯示在位址計數器// display ON
	Command(0x1) ;    // 清除全螢幕 // clear display
	delay2ms() ;
	Command(0x80) ;   // 設定DD RAM位址為0// DD RAM address=0
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	for(;;){
	    Command(0x18) ;// 0x18---左移/0x1c----右移// 0x18---left shift/0x1c----right shift
	    Delay1s() ;
	}
}
%}



%{led321.a51
;
; 配合"32個LED(共陰)實習板";    8 pieces of LED in P0  change state by  binary counter;
;    P0所接的8個LED當二進制計數器,P1所接的8個LED依序亮熄著,並交互變化,;    8 pieces of LED in P1 interchange state between   OFF-ON-OFF-ON-OFF-ON-OFF-ON and ON-OFF-ON-OFF-ON-OFF-ON-OFF  
;     P2所接的8個LED只有一LED亮著,並進行左旋的變化;    8 pieces of LED in P2(only 1 piece of LED is ON)change state by ON-LED to rotate left,
;     P3所接的8個LED只有一LED亮著,並進行右旋的變化;    8 pieces of LED in P3(only 1 piece of LED is ON)change state  by ON-LED to rotate right
;
START:
	MOV	P0,#0
	MOV	P1,#55H
	MOV	P2,#1
	MOV	P3,#1
LOOP:
	INC	P0          ; P0當二進制計數器; P0 binary counter

	MOV	A,P1        ; P1 0x55/0xaa交互變化; P1 0x55/0xaa interchange
	CJNE	A,#55H,FILL55H
	MOV	P1,#0AAH
	AJMP	NEXT1
FILL55H:
	MOV	P1,#055H
NEXT1:

	MOV	A,P2        ;P2左旋;P2  left rotate
	RL	A
	MOV	P2,A

	MOV	A,P3        ;P3右旋;P3 right rotate
	RR	A
	MOV	P3,A

	ACALL	DELAY100MS
	SJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}



%{led322.a51
;
; 配合"32個LED(共陽)實習板";    8 pieces of LED in P0  change state by  binary counter;
;    P0所接的8個LED當二進制計數器,P1所接的8個LED依序亮熄著,並交互變化,;    8 pieces of LED in P1 interchange state between   OFF-ON-OFF-ON-OFF-ON-OFF-ON and ON-OFF-ON-OFF-ON-OFF-ON-OFF  
;     P2所接的8個LED只有一LED亮著,並進行左旋的變化;    8 pieces of LED in P2(only 1 piece of LED is ON)change state by ON-LED to rotate left,
;     P3所接的8個LED只有一LED亮著,並進行右旋的變化;    8 pieces of LED in P3(only 1 piece of LED is ON)change state  by ON-LED to rotate right
;
TP0:	EQU	020H
TP1:	EQU	021H
TP2:	EQU	022H
TP3:	EQU	023H
START:
	MOV	TP0,#0
	MOV	A,TP0
	CPL	A
	MOV	P0,A
	MOV	TP1,#55H
	MOV	A,TP1
	CPL	A
	MOV	P1,A
	MOV	TP2,#1
	MOV	A,TP2
	CPL	A
	MOV	P2,A
	MOV	TP3,#1
	MOV	A,TP3
	CPL	A
	MOV	P3,A
LOOP:
	INC	TP0          ; P0當二進制計數器; P0 binary counter
	MOV	A,TP0
	CPL	A
	MOV	P0,A

	MOV	A,TP1        ; P1 0x55/0xaa交互變化; P1 0x55/0xaa interchange
	CJNE	A,#55H,FILL55H
	MOV	TP1,#0AAH
	AJMP	NEXT1
FILL55H:
	MOV	TP1,#055H
NEXT1:
	MOV	A,TP1
	CPL	A
	MOV	P1,A

	MOV	A,TP2        ;P2左旋;P2  left rotate
	RL	A
	MOV	TP2,A
	CPL	A
	MOV	P2,A


	MOV	A,TP3        ;P3右旋;P3 right rotate
	RR	A
	MOV	TP3,A
	CPL	A
	MOV	P3,A

	ACALL	DELAY100MS
	SJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


@1
%{led321.c
//
// 配合"32個LED(共陰)實習板"//    8 pieces of LED in P0  change state by  binary counter,
//    P0所接的8個LED當二進制計數器,P1所接的8個LED依序亮熄著,並交互變化, //    8 pieces of LED in P1 interchange state between  OFF-ON-OFF-ON-OFF-ON-OFF-ON and ON-OFF-ON-OFF-ON-OFF-ON-OFF,
//    P2所接的8個LED只有一LED亮著,並進行左旋的變化, //    8 pieces of LED in P2(only 1 piece of LED is ON)change state by ON-LED to rotate left,
//    P3所接的8個LED只有一LED亮著,並進行右旋的變化//    8 pieces of LED in P3(only 1 piece of LED is ON)change state  by ON-LED to rotate right
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"
main()
{
	char i ;
	int j ;

	P0=0 ;
	P1=0x55 ;
	P2=P3=0x1 ;
	for(;;) {
	    Delay100ms() ;
	    P0++ ;        // P0當二進制計數器// P0 binary counter
	    P1=(P1== 0x55)? 0xaa : 0x55 ; //P1 0x55/0xaa交互變化//P1 0x55/0xaa interchange
	    if(P2 ==0x80){  //P2左旋//P2 left rotate
		P2= 0x1 ;
	    }
	    else{
		P2 <<=1 ;
	    }
	    if(P3== 0x1){      //P3右旋//P3 right rotate
		P3= 0x80 ;
	    }
	    else{
		P3 >>=1  ;
	    }
	}
}
%}


@1
%{led322.c
//
// 配合"32個LED(共陽)實習板"//    8 pieces of LED in P0  change state by  binary counter,
//    P0所接的8個LED當二進制計數器,P1所接的8個LED依序亮熄著,並交互變化, //    8 pieces of LED in P1 interchange state between  OFF-ON-OFF-ON-OFF-ON-OFF-ON and ON-OFF-ON-OFF-ON-OFF-ON-OFF,
//    P2所接的8個LED只有一LED亮著,並進行左旋的變化, //    8 pieces of LED in P2(only 1 piece of LED is ON)change state by ON-LED to rotate left,
//    P3所接的8個LED只有一LED亮著,並進行右旋的變化//    8 pieces of LED in P3(only 1 piece of LED is ON)change state  by ON-LED to rotate right
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"
main()
{
	char i ;
	int j ;
	unsigned char tP0,tP1,tP2,tP3 ;

	tP0=0 ;
	P0= ~tP0 ;
	tP1=0x55 ;
	P1=~tP1 ;
	tP2=tP3=0x1 ;
	P2=P3=~tP2 ;
	for(;;) {
	    Delay100ms() ;
	    tP0++ ;        // P0當二進制計數器// P0 binary counter
	    P0=~tP0 ;
	    tP1=(tP1== 0x55)? 0xaa : 0x55 ; //P1 0x55/0xaa交互變化//P1 0x55/0xaa interchange
	    P1= ~tP1 ;
	    if(tP2 ==0x80){  //P2左旋//P2 left rotate
		tP2= 0x1 ;
	    }
	    else{
		tP2 <<=1 ;
	    }
	    P2= ~tP2 ;

	    if(tP3== 0x1){      //P3右旋//P3 right rotate
		tP3= 0x80 ;
	    }
	    else{
		tP3 >>=1  ;
	    }
    	    P3= ~tP3 ;
	}
}
%}


%{led81.a51
;
; 配合"8個LED(共陰)實習板";
;     P0所接的8個LED(初始狀態:最左2個亮；其餘6個LED熄著),並進行右旋的變化;     ON-LED  rotate  right
;

	MOV	A,#11000000B
START:
	MOV	P0,A

	ACALL	DELAY100MS
	RR	A
	SJMP	START

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


%{led83.a51
;
; 配合"8個LED(共陽)實習板";
;     P0所接的8個LED(初始狀態:最左2個亮；其餘6個LED熄著),並進行右旋的變化;     ON-LED  rotate  right
;

	MOV	A,#11000000B
START:
	CPL	A
	MOV	P0,A
	CPL	A

	ACALL	DELAY100MS
	RR	A
	SJMP	START

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


@1
%{led81.c
//
//   配合"8個LED(共陰)實習板"//
//       P0所接的8個LED(初始狀態:最左2個亮；其餘6個LED熄著),並進行右旋的變化//       ON-LED  rotate  right
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"

main()
{
	P0 =0xc0;
	for(;;) {
	    Delay100ms() ;
	    if(P0&0x01){                 //P0右旋1位元//P0 rotate right 1 bit
		P0 >>=1 ;
		P0 |=0x80 ;
	    }
	    else{
		P0 >>= 1 ;
	    }
	}
}
%}


@1
%{led83.c
//
//   配合"8個LED(共陽)實習板"//
//       P0所接的8個LED(初始狀態:最左2個亮；其餘6個LED熄著),並進行右旋的變化//       ON-LED  rotate  right
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"

main()
{
	unsigned char tP0 ;
	tP0 =0xc0;
	P0=~tP0 ;
	for(;;) {
	    Delay100ms() ;
	    if(tP0&0x01){                 //P0右旋1位元//P0 rotate right 1 bit
		tP0 >>=1 ;
		tP0 |=0x80 ;
	    }
	    else{
		tP0 >>= 1 ;
	    }
	    P0=~tP0 ;
	}
}
%}


%{led82a.a51
;
; 配合"8個LED(共陰)實習板";
;   P0所接的8個LED(初始狀態:最左1個熄；其餘7個LED亮著),其變化方式:;
;         當熄的LED出現在最左邊時,進行右旋, ;   1. When the most left  LED is OFF ====>OFF-LED rotate right
;         反之,當熄的LED出現在最右邊時,進行左旋;   2. When the most right LED is OFF ====>OFF-LED rotate  left
;
	MOV	P0,#01111111B
RIGHT:
	JNB	P0.0,LEFT
	ACALL	DELAY100MS
	MOV	A,P0
	RR	A
	MOV	P0,A
	SJMP	RIGHT
LEFT:
	ACALL	DELAY100MS
	JNB	P0.7,RIGHT
	MOV	A,P0
	RL	A
	MOV	P0,A
	SJMP	LEFT

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


%{led84a.a51
;
; 配合"8個LED(共陽)實習板";
;   P0所接的8個LED(初始狀態:最左1個熄；其餘7個LED亮著),其變化方式:;
;         當熄的LED出現在最左邊時,進行右旋, ;   1. When the most left  LED is OFF ====>OFF-LED rotate right
;         反之,當熄的LED出現在最右邊時,進行左旋;   2. When the most right LED is OFF ====>OFF-LED rotate  left
;
TP0:	EQU	020H
	MOV	TP0,#01111111B
	MOV	A,TP0
	CPL	A
	MOV	P0,A
RIGHT:
	JNB	TP0.0,LEFT
	ACALL	DELAY100MS
	MOV	A,TP0
	RR	A
	MOV	TP0,A
	CPL	A
	MOV	P0,A
	SJMP	RIGHT
LEFT:
	ACALL	DELAY100MS
	JNB	TP0.7,RIGHT
	MOV	A,TP0
	RL	A
	MOV	TP0,A
	CPL	A
	MOV	P0,A
	SJMP	LEFT

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


%{led82b.a51
;
; 配合"8個LED(共陰)實習板";
;   P0所接的8個LED(初始狀態:最左1個熄；其餘7個LED亮著),其變化方式:;
;         當熄的LED出現在最左邊時,進行右旋, ; 1. When the most left  LED is OFF ====>OFF-LED rotate right
;         反之,當熄的LED出現在最右邊時,進行左旋; 2. When the most right LED is OFF ====>OFF-LED rotate  left
;
START:
	MOV	DPTR,#TBL1
	MOV	R2,#14
LOOP:
	MOV	A,#0
	MOVC	A,@A+DPTR
	INC	DPTR
	MOV	P0,A
	ACALL	DELAY100MS
	DJNZ	R2,LOOP
	LJMP	START

%0,2 	include delay.inc
%1 	$include (delay.inc)

TBL1:
	DB	01111111B
	DB	10111111B
	DB	11011111B
	DB	11101111B
	DB	11110111B
	DB	11111011B
	DB	11111101B
	DB	11111110B
	DB	11111101B
	DB	11111011B
	DB	11110111B
	DB	11101111B
	DB	11011111B
	DB	10111111B
	END
%}


%{led84b.a51
;
; 配合"8個LED(共陽)實習板";
;   P0所接的8個LED(初始狀態:最左1個熄；其餘7個LED亮著),其變化方式:;
;         當熄的LED出現在最左邊時,進行右旋, ; 1. When the most left  LED is OFF ====>OFF-LED rotate right
;         反之,當熄的LED出現在最右邊時,進行左旋; 2. When the most right LED is OFF ====>OFF-LED rotate  left
;
START:
	MOV	DPTR,#TBL1
	MOV	R2,#14
LOOP:
	MOV	A,#0
	MOVC	A,@A+DPTR
	INC	DPTR
	CPL	A
	MOV	P0,A
	ACALL	DELAY100MS
	DJNZ	R2,LOOP
	LJMP	START

%0,2 	include delay.inc
%1 	$include (delay.inc)

TBL1:
	DB	01111111B
	DB	10111111B
	DB	11011111B
	DB	11101111B
	DB	11110111B
	DB	11111011B
	DB	11111101B
	DB	11111110B
	DB	11111101B
	DB	11111011B
	DB	11110111B
	DB	11101111B
	DB	11011111B
	DB	10111111B
	END
%}


@1
%{led82a.c
//
//   配合"8個LED(共陰)實習板"//
//      P0所接的8個LED(初始狀態:最左1個熄；其餘7個LED亮著),其變化方式://
//         當熄的LED出現在最左邊時,進行右旋, //      1. When the most left  LED is OFF ====>OFF-LED rotate right
//         反之,當熄的LED出現在最右邊時,進行左旋//      2. When the most right LED is OFF ====>OFF-LED rotate  left
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"
enum {LEFT,RIGHT} ;
main()
{
	char State ;
	P0 =0x7f;
	State=RIGHT ;
	for(;;) {
	    Delay100ms() ;
	    if(State == RIGHT){
		P0 >>= 1;
		P0 |=0x80 ;
	    }
	    if(State == LEFT){
		P0 <<= 1;
		P0 ++ ;
	    }
	    if((P0&0x1)==0){
		State= LEFT ;
	    }
	    if((P0&0x80)==0){
		State= RIGHT ;
	    }
	}
}
%}


@1
%{led84a.c
//
//   配合"8個LED(共陽)實習板"//
//      P0所接的8個LED(初始狀態:最左1個熄；其餘7個LED亮著),其變化方式://
//         當熄的LED出現在最左邊時,進行右旋, //      1. When the most left  LED is OFF ====>OFF-LED rotate right
//         反之,當熄的LED出現在最右邊時,進行左旋//      2. When the most right LED is OFF ====>OFF-LED rotate  left
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"
enum {LEFT,RIGHT} ;
main()
{
	unsigned char tP0 ;
	char State ;
	tP0 =0x7f;
	P0= ~tP0 ;
	State=RIGHT ;
	for(;;) {
	    Delay100ms() ;
	    if(State == RIGHT){
		tP0 >>= 1;
		tP0 |=0x80 ;
	    }
	    if(State == LEFT){
		tP0 <<= 1;
		tP0 ++ ;
	    }
	    if((tP0&0x1)==0){
		State= LEFT ;
	    }
	    if((tP0&0x80)==0){
		State= RIGHT ;
	    }
	    P0= ~tP0 ;
	}
}
%}


@1
%{led82b.c
//
//   配合"8個LED(共陰)實習板"//
//      P0所接的8個LED(初始狀態:最左1個熄；其餘7個LED亮著),其變化方式://
//         當熄的LED出現在最左邊時,進行右旋, //   1. When the most left  LED is OFF ====>OFF-LED rotate right
//         反之,當熄的LED出現在最右邊時,進行左旋//   2. When the most right LED is OFF ====>OFF-LED rotate  left 
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"
code tbl1[]= { 0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf } ;
main()
{
	char i ;
	for(;;) {
	    for(i = 0 ; i < 14 ; i++ ){
		P0=tbl1[i] ;
		Delay100ms() ;
	    }
	}
}
%}

@1
%{led84b.c
//
//   配合"8個LED(共陽)實習板"//
//      P0所接的8個LED(初始狀態:最左1個熄；其餘7個LED亮著),其變化方式://
//         當熄的LED出現在最左邊時,進行右旋, //   1. When the most left  LED is OFF ====>OFF-LED rotate right
//         反之,當熄的LED出現在最右邊時,進行左旋//   2. When the most right LED is OFF ====>OFF-LED rotate  left 
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"
code tbl1[]= { 0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf } ;
main()
{
	char i ;
	for(;;) {
	    for(i = 0 ; i < 14 ; i++ ){
		P0=~tbl1[i] ;
		Delay100ms() ;
	    }
	}
}
%}



@1
%{mkdisasm.c
//
//  配合"自動測試反組譯程式實習"//auto testing for disassembler
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>

char code p[]={
	'M','U','L',' ','A','B',0,
	'X','C','H',' ','A',',','@','R','0',0,
	'X','C','H',' ','A',',','T','C','O','N',0
};

void main ()
{
	unsigned char c, i, j;
	int len;

	P2=0xff;
	for(;;){
	    // 觸發輸入// trigger input
	    P2 = P2|0x01;
	    P2 = P2&0xfe;
	    // 讀入一個MACHINE CODE// read MACHINE CODE
	    c = P0;

	    // 如果是0xa5表示讀完所有的資料// ending  all data when 0xa5
	    if( c == 0xa5 ){
		for(i=0;i<28;i++){
		    // 寫入一個ASCII CODE// write ASCII CODE
		    P1 = p[i];
		    // 觸發輸出// trigger output
		    P2 = P2|0x02;
		    P2 = P2&0xfd;
		}

		// 停止計時// stop operation
		P2 = P2&0xfb;
		break;
	    }
	    else{
		// 處理讀入的資料// process data
	    }
	}
	for(;;);
}
%}


@1
%{mklinasm.c
//
//  配合"自動測試行組譯程式實習"// auto testing for line assembler
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>

unsigned char code tt[]={0xa4, 0xa5, 0xc6, 0xa5, 0xc5, 0x88, 0xa5};

void main ()
{
	unsigned char c, flag=0;
	int j=0;

	P2=0xff;
	for(;;){
	    // 觸發輸入// trigger input
	    P2 = P2|0x01;
	    P2 = P2&0xfe;
	    // 讀入一個ASCII CODE// read ASCII CODE
	    c = P0;

	    // 如果是0表示讀完一行指令//
	    if( c==0 ){
		// 如果是1表示連續兩次讀取ASCII CODE都是0,//
		// 表示讀完所有資料//
		if(flag==1 ){
		    for(j=0; j < 7; j++){
			// 寫入MACHINE CODE// write MACHINE CODE
			P1=tt[j];
			// 觸發輸出// trigger output
			P2 = P2|0x02;
			P2 = P2&0xfd;
		    }
		    // 停止計時// stop
		    P2 = P2&0xfb;
		    break;
		}
		else{
		    // 讀完一行指令//
		    flag=1;
		}
	    }
	    else{
		flag = 0;
	    }
	}
	for(;;);
}
%}


@1
%{ptr1.c
//
//  指到內部資料記憶體的指標佔一位元組//  The typed pointer to internal data memory can be stored using 1 byte
//  指到程式記憶體的指標佔二位元組//  typed pointer to program memory can be stored using 2 bytes
//  指到任意記憶體的指標佔參位元組//  untyped pointers are always stored using 3 bytes
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
char data *pd ;
char code *pc ;
char *pp ;
void main()
{
char s1,s2,s3 ;
s1 = sizeof(pd) ;
s2 =  sizeof(pc) ;
s3 = sizeof(pp) ;
}
%}


@1
%{ptr2a.c
//
//示範char data *pd之存取// Demonstrate the access of char data *pd
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
char data *pd ;
void main()
{
	char v1,v2,v3;
	char i ;
	v1=*pd ;
	v2=*(pd+1) ;
	v3=*(pd+i) ;
}
%}


@1
%{ptr2b.c
//
//示範char data *pd之存取// Demonstrate the access of char data *pd
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
char data *pd ;
void main()
{
	char v1,v2,v3;
	char i ;
	v1=pd[0] ;
	v2=pd[1] ;
	v3=pd[i] ;
}
%}


@1
%{ptr3a.c
//
//    示範int data *pd之存取//    Demonstrate the access of int data *pd
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
int data *pd ;
void main()
{
	int v1,v2,v3;
	char i ;
	v1=*pd ;
	v2=*(pd+1) ;
	v3=*(pd+i) ;
}
%}


@1
%{ptr3b.c
//
//    示範int data *pd之存取//    Demonstrate the access of int data *pd
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
int data *pd ;
void main()
{
	int v1,v2,v3;
	char i ;
	v1=pd[0] ;
	v2=pd[1] ;
	v3=pd[i] ;
}
%}


@1
%{ptr4a.c
//
//    示範long data *pd之存取//    Demonstrate the access of long data *pd
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
long data *pd ;
void main()
{
	long v1,v2,v3;
	char i ;
	v1=*pd ;
	v2=*(pd+1) ;
	v3=*(pd+i) ;
}
%}


@1
%{ptr4b.c
//
//    示範long data *pd之存取//    Demonstrate the access of long data *pd
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
long data *pd ;
void main()
{
	long v1,v2,v3;
	char i ;
	v1=pd[0] ;
	v2=pd[1] ;
	v3=pd[i] ;
}
%}


@1
%{rs2321.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
code char mes[]="Hello!!" ;
main()
{
	char *s ;
	SM0=0 ;
	SM1=1 ; // Serial port in  Mode 1
	TMOD=0x20 ; // Timer1 in Mode 2
	TH1=TL1= 0xfd  ; // 0xfd:baud rate 9600/0xfa:4800
	TR1=1 ; // Enable timer 
	for(s=mes;*s != '\0' ;){
	    SBUF=*s++ ;
	    while(TI==0) ;
	    TI=0 ;
	}
	for(;;) ;
}
%}


@1
%{rs2322.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char buf[10] ;
char idx ;
main()
{
	idx=0 ;
	SM0=0 ;
	SM1=1 ; // Serial port in  Mode 1
	TMOD=0x20 ; // Timer1 in Mode 2
	TH1=TL1= 0xfd  ; // 0xfd:baud rate 9600/0xfa:4800
	TR1=1 ; // Enable timer
	REN=1 ;
	for(;;){
	    while(RI==0) ;
	    RI=0 ;
 	    buf[idx++]=SBUF ;
	}
}
%}


@1
%{rs2323.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char buf[10] ;
char idx ;
main()
{
	idx=0 ;
	SM0=0 ;
	SM1=1 ; // Serial port in  Mode 1
	TMOD=0x20 ; // Timer1 in Mode 2
	TH1=TL1= 0xfd  ; // 0xfd:baud rate 9600/0xfa:4800
	TR1=1 ; // Enable timer
	REN=1 ;
	for(;;){
	    while(RI==0) ;
	    RI=0 ;
 	    c=SBUF ;
	    SBUF=c ;
	    while(TI==0) ;
	    TI=0 ;
	}
}
%}


%{ssled1.a51
;
; 配合"1個七段式LED實習板";
;  依序打亮七段式LED的a段,b段,c段,d段,e段,f段,g段及dot段;  Sequence ON a-segment, b-segment, c-segment, d-segment, e-segment, f-segment, g-segment , and dot-segment on Seven-Segment LED
;
START:
	MOV	P0,#0FEH
LOOP:
	ACALL	DELAY100MS
	MOV	A,P0
	RL	A
	MOV	P0,A
	AJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


@1
%{ssled1.c
//
//  配合"1個七段式LED(共陽)實習板"//
//    依序打亮七段式LED的a段,b段,c段,d段,e段,f段,g段及dot段//    Sequence ON a-segment, b-segment, c-segment, d-segment, e-segment, f-segment, g-segment , and dot-segment on Seven-Segment LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
main()
{
	P0=0xfe ;
	for(;;){
	    Delay100ms() ;
	    P0 <<=1 ;
	    P0 +=1 ;
	    if(P0 ==0xff){
		P0=0xfe ;
	    }
	}
}
%}


%{ssled2a.a51
;
; 配合"1個七段式LED實習板";
;  依序在七段式LED上顯示數字0,1,2,3,4,5,6,7,8,9;  Sequence display number 0,1,2,3,4,5,6,7,8,9 on Seven-Segment LED
;
START:
	MOV	R2,#0
LOOP:
	MOV	A,R2
	MOV	DPTR,#SSTBL
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R2
	CJNE	R2,#10,NEXT1
	MOV	R2,#0
NEXT1:
	ACALL	DELAY100MS
	AJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

SSTBL:
	DB	0C0H
	DB	0F9H
	DB	0A4H,0B0H,099H
	DB	092H,082H,0F8H,080H,090H

	END
%}


%{ssled2b.a51
;
; 配合"1個七段式LED實習板";
;  依序在七段式LED上顯示數字0,1,2,3,4,5,6,7,8,9;  Sequence display number 0,1,2,3,4,5,6,7,8,9 on Seven-Segment LED
;
START:
	MOV	R2,#0
	MOV	DPTR,#SSTBL   ;在迴路內未曾改變,故移出迴路外;
LOOP:
	MOV	A,R2
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R2
	CJNE	R2,#10,NEXT1
	MOV	R2,#0
NEXT1:
	ACALL	DELAY100MS
	AJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

SSTBL:
	DB	0C0H
	DB	0F9H
	DB	0A4H,0B0H,099H
	DB	092H,082H,0F8H,080H,090H

	END
%}


@1
%{ssled2.c
//
//    配合"1個七段式LED(共陽)實習板"//
//     依序在七段式LED上顯示數字0,1,2,3,4,5,6,7,8,9//     Sequence display number 0,1,2,3,4,5,6,7,8,9 on Seven-Segment LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code sstbl[]= { 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90} ;
main()
{
	char i ;
	i=0 ;
	for( ; ;){
	    P0=sstbl[i++] ;
	    if(i >=10){
		i=0 ;
	    }
	    Delay100ms() ;
	}
}
%}


%{ssled3.a51
;
; 配合"4個七段式LED實習板";
;  在4個七段式LED上顯示數字"1234";其掃瞄間隔為100ms;  Display number string "1234" on 4 pieces of Seven-Segment LED; the scanning interval is 100ms
;
START:
	MOV	R2,#0
LOOP:
	MOV	P1,#0FFH   ;  關閉共陽;  OFF common anode

 	MOV	A,R2
	INC	A
	MOV	DPTR,#SSTBL
	MOVC	A,@A+DPTR
	MOV	P0,A

	MOV	A,R2
	MOV	DPTR,#LOC
	MOVC	A,@A+DPTR
	MOV	P1,A

	INC	R2
	CJNE	R2,#4,NEXT1
	MOV	R2,#0
NEXT1:
	ACALL	DELAY100MS
	AJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

SSTBL:
	DB	0C0H
	DB	0F9H
	DB	0A4H,0B0H,099H
	DB	092H,082H,0F8H,080H,090H
LOC:
	DB	0F7H,0FBH,0FDH,0FEH
	END
%}


@1
%{ssled3.c
//
//  配合"4個七段式LED(共陽)實習板"//
//    在4個七段式LED上顯示數字"1234";其掃瞄間隔為100ms//    Display number string "1234" on 4 pieces of Seven-Segment LED; the scanning interval is 100ms
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code sstbl[]= { 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90} ;
unsigned char code loc[]={ 0xf7,0xfb,0xfd,0xfe} ;
main()
{
	char i ;
	i=0 ;
	for( ; ;){
	    P1=0xff ;     //關閉共陽//OFF common anode
	    P0=sstbl[i+1] ;
	    P1=loc[i++] ;
	    if(i >=4){
		i=0 ;
	    }
	    Delay100ms() ;
	}
}
%}


%{ssled4.a51
;
; 配合"4個七段式LED實習板";
;  在4個七段式LED上顯示數字"1234";其掃瞄間隔為1ms;  Display number string "1234" on 4 pieces of Seven-Segment LED; the scanning interval is 1ms
;
START:
	MOV	R2,#0
LOOP:
	MOV	P1,#0FFH   ;  關閉共陽;  OFF common anode

	MOV	A,R2
	INC	A
	MOV	DPTR,#SSTBL
	MOVC	A,@A+DPTR
	MOV	P0,A

	MOV	A,R2
	MOV	DPTR,#LOC
	MOVC	A,@A+DPTR
	MOV	P1,A

	INC	R2
	CJNE	R2,#4,NEXT1
	MOV	R2,#0
NEXT1:
	ACALL	DELAY1MS
	AJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

SSTBL:
	DB	0C0H
	DB	0F9H
	DB	0A4H,0B0H,099H
	DB	092H,082H,0F8H,080H,090H
LOC:
	DB	0F7H,0FBH,0FDH,0FEH
	END
%}


@1
%{ssled4.c
//
//  配合"4個七段式LED(共陽)實習板"//
//    在4個七段式LED上顯示數字"1234";其掃瞄間隔為1ms//    Display number string "1234" on 4 pieces of Seven-Segment LED; the scanning interval is 1ms
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code sstbl[]= { 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90} ;
unsigned char code loc[]={ 0xf7,0xfb,0xfd,0xfe} ;
main()
{
	char i ;
	i=0 ;
	for( ; ;){
	    P1=0xff ;     //關閉共陽// OFF common anode
	    P0=sstbl[i+1] ;
	    P1=loc[i++] ;
	    if(i >=4){
		i=0 ;
	    }
	    Delay1ms() ;
	}
}
%}


%{ssled5.a51
;
; 配合"4個七段式LED實習板";   Display number string "1234" on 4 pieces of Seven-Segment LED,
;   在4個七段式LED上顯示數字"1234";其掃瞄間隔為(1ms*連接DIPSW15~8指撥開關所代表的數值) ;     the scanning interval is 1ms * DIP Switch setting (on DIPSW15~7)
;
START:
	MOV	R2,#0
LOOP:
	MOV	P1,#0FFH   ;  關閉共陽;  OFF common anode

	MOV	A,R2
	INC	A
	MOV	DPTR,#SSTBL
	MOVC	A,@A+DPTR
	MOV	P0,A

	MOV	A,R2
	MOV	DPTR,#LOC
	MOVC	A,@A+DPTR
	MOV	P1,A

	INC	R2
	CJNE	R2,#4,NEXT1
	MOV	R2,#0
NEXT1:
	MOV	A,P2
	CPL	A
	JZ	NEXT3
	MOV	R3,A

NEXT2:
	ACALL	DELAY1MS
	DJNZ	R3,NEXT2
NEXT3:
	AJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

SSTBL:
	DB	0C0H
	DB	0F9H
	DB	0A4H,0B0H,099H
	DB	092H,082H,0F8H,080H,090H
LOC:
	DB	0F7H,0FBH,0FDH,0FEH
	END
%}


@1
%{ssled5.c
//
//  配合"4個七段式LED(共陽)實習板"//    Display number string "1234" on 4 pieces of Seven-Segment LED,
//    在4個七段式LED上顯示數字"1234";其掃瞄間隔為(1ms*連接DIPSW15~8指撥開關所代表的數值) //    the scanning interval is 1ms * DIP Switch setting (on DIPSW15~8)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code sstbl[]= { 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90} ;
unsigned char code loc[]={ 0xf7,0xfb,0xfd,0xfe} ;
main()
{
	char i ;
	unsigned char j;
	i=0 ;
	for( ; ;){
	    P1=0xff ;     //關閉共陽//OFF common anode
	    P0=sstbl[i+1] ;
	    P1=loc[i++] ;
	    if(i >=4){
		i=0 ;
	    }
	    for(j=0 ; j < ~P2;j++){
 		Delay1ms() ;
	    }
	}
}
%}


%{ssled6.a51
;
; 配合"4個七段式LED實習板";   Display number(DIP Switch setting (on DIPSW15~0)) on 4 pieces of Seven-Segment LED;
;   連接DIPSW15~0指撥開關所代表的數值,顯示在4個七段式LED上;其掃瞄間隔為7ms;   the scanning interval is 7ms
;
START:
	MOV	R2,#0
	MOV	DPTR,#SSTBL
LOOP:
	MOV	P1,#0FFH   ;  關閉共陽;  OFF common anode

	CJNE	R2,#0,LOC1
	INC	R2
	MOV	A,P2
	CPL	A
	SWAP	A
	ANL	A,#0FH
	MOVC	A,@A+DPTR
	MOV	P0,A
	MOV	P1,#0F7H
	SJMP	DELAY
LOC1:
	CJNE	R2,#1,LOC2
	INC	R2
	MOV	A,P2
	CPL	A
	ANL	A,#0FH
	MOVC	A,@A+DPTR
	MOV	P0,A
	MOV	P1,#0FBH
	SJMP	DELAY
LOC2:
	CJNE	R2,#2,LOC3
	INC	R2
	MOV	A,P3
	CPL	A
	SWAP	A
	ANL	A,#0FH
	MOVC	A,@A+DPTR
	MOV	P0,A
	MOV	P1,#0FDH
	SJMP	DELAY
LOC3:
	MOV	R2,#0
	MOV	A,P3
	CPL	A
	ANL	A,#0FH
	MOVC	A,@A+DPTR
	MOV	P0,A
	MOV	P1,#0FEH
	SJMP	DELAY
DELAY:

	MOV	R3,#7
NEXT2:
	ACALL	DELAY1MS
	DJNZ	R3,NEXT2

	AJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

SSTBL:
	DB	0C0H,0F9H,0A4H,0B0H,099H
	DB	092H,082H,0F8H,080H,090H
	END
%}


@1
%{ssled6.c
//
//  配合"4個七段式LED(共陽)實習板"//   Display number(DIP Switch setting (on DIPSW15~0)) on 4 pieces of Seven-Segment LED
//   連接DIPSW15~0指撥開關所代表的數值,顯示在4個七段式LED上;其掃瞄間隔為7ms//   the scanning interval is 7ms
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code sstbl[]= { 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e} ;
delay7ms()
{
	char i ;
	for(i=0;i < 7 ;i++){
	    Delay1ms() ;
	}
}
main()
{
	char i ;
	i=0 ;
	for( ; ;){
	    P1=0xff ;  // 關閉所有LED// OFF all LED
	    switch(i){
		case 0:
		    P0 = sstbl[~P2 >> 4] ;
		    P1= 0xf7 ;
		    i++ ;
		    break ;
		case 1:
		    P0 = sstbl[~P2&0xf] ;
		    P1= 0xfb ;
		    i++ ;
 		    break ;
		case 2:
		    P0= sstbl[~P3 >> 4] ;
		    P1=0xfd ;
		    i++ ;
		    break ;
		case 3:
		    P0= sstbl[~P3&0xf] ;
		    P1=0xfe ;
		    i=0 ;
		    break ;
	    }
	    delay7ms() ;
	}
}
%}

%{stepm1a.A51
;
;    用單相激磁的方式,使步進馬達正轉n格;    Let Stepping Motor clockwise to rotate n steps ,using single-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#00000001B
LOOP:
	MOV	P0,R1
	MOV	A,R1
	RL	A
	CJNE	A,#00010000B,NEXT1
	MOV	A,#00000001B
NEXT1:
	MOV	R1,A
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}


%{stepm1b.A51
;
;   用單相激磁的方式,使步進馬達正轉n格;
;    由於步進馬達初值的刻意設定,迴路內只須左旋即可;   Let Stepping Motor clockwise to rotate n steps ,using single-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#00010001B
LOOP:
	MOV	P0,R1
	MOV	A,R1
	RL	A
	MOV	R1,A
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}

%{stepm2a.A51
;
;    用單相激磁的方式,使步進馬達反轉n格;    Let Stepping Motor counterclockwise to rotate n steps ,using single-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#00001000B
LOOP:
	MOV	P0,R1
	MOV	A,R1
	RR	A
	CJNE	A,#10000000B,NEXT1
	MOV	A,#00001000B
NEXT1:
	MOV	R1,A
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}


%{stepm2b.A51
;
;   用單相激磁的方式,使步進馬達反轉n格;
;    由於步進馬達初值的刻意設定,迴路內只須右旋即可;   Let Stepping Motor counterclockwise to rotate n steps ,using single-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#00010001B
LOOP:
	MOV	P0,R1
	MOV	A,R1
	RR	A
	MOV	R1,A
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}

%{stepm3a.A51
;
;    用二相激磁的方式,使步進馬達正轉n格;    Let Stepping Motor clockwise to rotate n steps ,using two-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#0
	MOV	DPTR,#PP
LOOP:
	MOV	A,R1
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R1
	CJNE	R1,#4,NEXT1
	MOV	R1,#0
NEXT1:
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
PP:	
	DB	03H,06H,0CH,09H
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}

%{stepm3b.A51
;
;    用二相激磁的方式,使步進馬達正轉n格;
;    由於步進馬達初值的刻意設定,迴路內只須左旋即可;    Let Stepping Motor clockwise to rotate n steps ,using two-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#00110011B
LOOP:
	MOV	P0,R1
	MOV	A,R1
	RL	A
	MOV	R1,A
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}


%{stepm4a.A51
;
;    用二相激磁的方式,使步進馬達反轉n格;    Let Stepping Motor counterclockwise to rotate n steps ,using two-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#0
	MOV	DPTR,#PP
LOOP:
	MOV	A,R1
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R1
	CJNE	R1,#4,NEXT1
	MOV	R1,#0
NEXT1:
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
PP:	
	DB	03H,09H,0CH,06H
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}

%{stepm4b.A51
;
;    用二相激磁的方式,使步進馬達反轉n格;
;    由於步進馬達初值的刻意設定,迴路內只須右旋即可;    Let Stepping Motor counterclockwise to rotate n steps ,using two-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#00110011B
LOOP:
	MOV	P0,R1
	MOV	A,R1
	RR	A
	MOV	R1,A
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}


%{stepm5.A51
;
;    用半步激磁的方式,使步進馬達正轉n格;    Let Stepping Motor clockwise to rotate n steps ,using half-step method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#0
	MOV	DPTR,#PP
LOOP:
	MOV	A,R1
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R1
	CJNE	R1,#8,NEXT1
	MOV	R1,#0
NEXT1:
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N*2+1,LOOP
	AJMP	$
PP:	
	DB	01H,03H,02H,06H,04H,0CH,08H,09H
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}


%{stepm6.A51
;
;    用半步激磁的方式,使步進馬達反轉n格;    Let Stepping Motor counterclockwise to rotate n steps ,using half-step method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#0
	MOV	DPTR,#PP
LOOP:
	MOV	A,R1
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R1
	CJNE	R1,#8,NEXT1
	MOV	R1,#0
NEXT1:
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N*2+1,LOOP
	AJMP	$
PP:	
	DB	01H,09H,08H,0CH,04H,06H,02H,03H
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}


@1
%{stepm1a.c
//
//    用單相激磁的方式,使步進馬達正轉n格//    Let Stepping Motor clockwise to rotate n steps ,using single-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
main()
{
	unsigned char pp=0x1 ;
	int Step ;

	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp ;
	    pp <<=1 ;
	    if(pp == 0x10){
		pp=0x1 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}


@1
%{stepm1b.c
//
//   用單相激磁的方式,使步進馬達正轉n格//
//       由於步進馬達初值的刻意設定,迴路內只須左旋即可//   Let Stepping Motor clockwise to rotate n steps ,using single-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
#define n   10
main()
{
	unsigned char pp=0x11 ;
	int Step ;

	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp ;
	    // pp內容作左旋// pp rotate left
	    if(pp &0x80){
		pp <<=1 ;
		pp+=1 ;
	    }
	    else{
		pp <<=1 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}


@1
%{stepm2a.c
//
//    用單相激磁的方式,使步進馬達反轉n格//    Let Stepping Motor counterclockwise to rotate n steps ,using single-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
main()
{
	unsigned char pp=0x8 ;
	int Step ;

	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp ;
	    pp >>=1 ;
	    if(pp == 0x00){
		pp=0x8 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}

@1
%{stepm2b.c
//
//    用單相激磁的方式,使步進馬達反轉n格//
//       由於步進馬達初值的刻意設定,迴路內只須右旋即可//    Let Stepping Motor counterclockwise to rotate n steps ,using single-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
main()
{
	unsigned char pp=0x88 ;
	int Step ;

	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp ;
	    // pp內容作右旋// pp rotate right
	    if(pp&0x1){
		pp >>=1 ;
		pp+=0x80 ;
	    }
	    else{
		pp >>=1 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}


@1
%{stepm3a.c
//
//    用二相激磁的方式,使步進馬達正轉n格//    Let Stepping Motor clockwise to rotate n steps ,using two-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
char code pp[]={
	0x3 ,
	0x6 ,
	0xC ,
	0x9 
} ;
main()
{
	int Step ;
	char idx_pp=0 ;
	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp[idx_pp++] ;
	    if(idx_pp == 4){
		idx_pp=0 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}


@1
%{stepm3b.c
//
//    用二相激磁的方式,使步進馬達正轉n格//
//       由於步進馬達初值的刻意設定,迴路內只須左旋即可//    Let Stepping Motor clockwise to rotate n steps ,using two-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
main()
{
	unsigned char pp=0x33 ;
	int Step ;

	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp ;
	    // pp內容作左旋// pp rotate left
	    if(pp &0x80){
		pp <<=1 ;
		pp+=1 ;
	    }
	    else{
		pp <<=1 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}


@1
%{stepm4a.c
//
//    用二相激磁的方式,使步進馬達反轉n格//    Let Stepping Motor counterclockwise to rotate n steps ,using two-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
char code pp[]={
	0x3 ,
	0x9 ,
	0xC ,
	0x6 
} ;
main()
{
	int Step ;
	char idx_pp=0 ;
	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp[idx_pp++] ;
	    if(idx_pp == 4){
		idx_pp=0 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}

@1
%{stepm4b.c
//
//    用二相激磁的方式,使步進馬達反轉n格//
//       由於步進馬達初值的刻意設定,迴路內只須右旋即可//    Let Stepping Motor counterclockwise to rotate n steps ,using two-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
main()
{
	unsigned char pp=0x33 ;
	int Step ;

	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp ;
	    // pp內容作右旋// pp rotate right
	    if(pp&0x1){
		pp >>=1 ;
		pp+=0x80 ;
	    }
	    else{
		pp >>=1 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}


@1
%{stepm5.c
//
//    用半步激磁的方式,使步進馬達正轉n格//    Let Stepping Motor clockwise to rotate n steps ,using half-step method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
char code pp[]={
	0x1 ,
	0x3 ,
	0x2 ,
	0x6 ,
	0x4 ,
	0xC ,
	0x8 ,
	0x9 
} ;
main()
{
	int Step ;
	char idx_pp=0 ;
	for(Step=0 ;Step < (n*2+1) ; Step++){
	    P0=pp[idx_pp++] ;
	    if(idx_pp == 8){
		idx_pp=0 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}


%{stepm6.c
//
//    用半步激磁的方式,使步進馬達反轉n格//    Let Stepping Motor counterclockwise to rotate n steps ,using half-step method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
char code pp[]={
	0x1 ,
	0x9 ,
	0x8 ,
	0xC ,
	0x4 ,
	0x6 ,
	0x2 ,
	0x3 
} ;
main()
{
	int Step ;
	char idx_pp=0 ;
	for(Step=0 ;Step < (n*2+1) ; Step++){
	    P0=pp[idx_pp++] ;
	    if(idx_pp == 8){
		idx_pp=0 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}

@1
%{tc.c
//
//   配合"計時計算器實習板"//   P0.0~P0.7 and P1.0~P1.3 control 4 pieces of Seven-Segment LED,
//   P0.0-P0.7和P1.0-P1.2控制四個七毇顯示器,顯示所經時間或數量. //   P2.0 select timer mode/counter mode;ON is timer mode, OFF is counter mode
//   DIP SW-1控制計時或計數, //   P2.1 to start/stop timer/counter ;On is to start timer/counter , OFF is to stop timer/counter
//   DIP SW-2控制開始或停止, 計時計數. //   P2.2 is counter pulse input
//
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>

unsigned char code sstbl[]={
	0xc0,0xf9,0xa4,0xb0,
	0x99,0x92,0x82,0xf8,
	0x80,0x90,0x88,0x83,
	0xc6,0xa1,0x86,0x8e
} ;
void delay1ms()
{
	int i ;
	char  j;
	for(i=0 ; i < 124 ;i++) ;
	j++ ;
}

char Count=0;

main()
{
	char Lt=1, Time=1;
	char i, s=0, ch[4]={0,0,0,0};

	TMOD =0x01;
	TH0= (0xffff-50000)/256 ;
	TL0= (0xffff-50000)%256 ;
	EA=1;
	ET0=1 ;
	TR0=1 ;

	for(i=0; ;i++){
	   if(~P2&0x02 ){
		if(~P2&0x01 ){ //計時// timer mode
		    if(Time == 0){
			Time=1;
			ch[0]=0;
			ch[1]=0;
			ch[2]=0;
			ch[3]=0;
			s = 0;
			Count = 0;
		    }
		    if(Count>=20){
			Count -= 20;
			s++;
			if( s>=60 ){
			    s=0;
			    ch[3]++;
			    if(ch[3]>9){
				ch[3]=0;
				ch[2]++;
				if(ch[2]>=6){
				    ch[2]=0;
				    ch[1]++;
				    if(ch[1]>9){
					ch[1]=0;
					ch[0]++;
					if(ch[0]>9){
					    ch[0]=0;
					}
				    }	
				}
			    }
			}
		    }
		}
		else{          //計數// counter mode
		    if(Time == 1){
			Time=0;
			ch[0]=0;
			ch[1]=0;
			ch[2]=0;
			ch[3]=0;
			s = 0;
		    }
		    if( Lt==1 ){
			if((~P2&0x04)==0 ){
			    Lt=0;
			    ch[3]++;
			    if( ch[3]>9 ){
				ch[3]=0;
				ch[2]++;
				if(ch[2]>9){
				    ch[2]=0;
				    ch[1]++;
				    if(ch[1]>9){
					ch[1]=0;
					ch[0]++;
					if(ch[0]>9){
					    ch[0]=0;
					}
				    }
				}
			    }
			}
		    }
		    else{
			if(~P2&0x04){
			    Lt=1;
			}
		    }
		}
	    }
  	    i &= 3;	
	    P1=0xff ;  // 關閉所有LED// OFF all LED
	    P0 = sstbl[ch[i]];
	    if(s&1) P0&=0x7f;
	    else    P0|=0x80;		
	    P1 = ~(1<<i);
	    delay1ms();
	}
}

void timer0(void ) interrupt 1
{
	Count++;
	TH0= (0xffff-50000)/256 ;
	TL0=(0xffff-50000)%256 ;

}
%}


@1
%{testgate.c
//
//  配合"邏輯閘測試器程式實習"// design  logical gate tester
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"

struct tt{
	char in1,in2,out;
};

struct tt code Tbl[7][4]=
{
    {{0,0,0}, {0,1,0}, {1,0,0}, {1,1,1}},
    {{0,0,0}, {0,1,1}, {1,0,1}, {1,1,1}},
    {{0,0,0}, {0,1,1}, {1,0,1}, {1,1,0}},
    {{0,0,1}, {0,1,1}, {1,0,1}, {1,1,0}},
    {{0,0,1}, {0,1,0}, {1,0,0}, {1,1,0}},
    {{0,0,1}, {0,1,0}, {1,0,0}, {1,1,1}},
    {{0,0,1}, {0,1,1}, {1,0,0}, {1,1,0}}, 
};

void delay20ms()
{
	Delay10ms();
	Delay10ms();
}

void main ()
{
	unsigned char i, j, k, t;

	P0 = 0;
	for(;;){
	    if( (P2&0x01) == 1 ){
		delay20ms() ;
		delay20ms() ;
		while((P2&0x01) == 1);
		for( i=0; i < 7; i++ ){
		    t = 0x01<<i;
		    if( (P1&t) != 0 ){
			k=0;
			for(j=0;j<4;j++){
			    if( Tbl[i][j].in1 ) P0 |= 1;
			    else  P0 &= 0xfe;
			    if( Tbl[i][j].in2 ) P0 |= 2;
			    else	  P0 &= 0xfd;
			    t = P2>>1;
			    if( (t&0x01) != Tbl[i][j].out ){
				k=1;
			    }
			}
			P0&=0xf3;
			if( k==1){
			    P0 |=0x08;
			}
			else{
			    P0 |=0x04;
			}	
			break;
		    }
		}
	    }
	}
}
%}


@1
%{timer0a.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char Count ;
main()
{
	P0=Count=0 ;
	TMOD =0x10 ;
	TH0= (0xffff-10000)/256 ;
	TL0=(0xffff-10000)%256 ;
	EA=1;
	ET0=1 ;
	TR0=1 ;
	for(;;) ;
}
void timer0(void ) interrupt 1
{
	Count++ ;
	P0=Count ;
	TH0= (0xffff-10000)/256 ;
	TL0=(0xffff-10000)%256 ;
}
%}


@1
%{timer0b.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
main()
{
	TMOD =0x50 ; // counter mode 
	TR0=1 ;
	for(;;) {
	    P0=TL0 ;
	}
}
%}


@1
%{timer0c.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
main()
{
	TMOD =0xd0 ; // counter mode 
	TR0=1 ;
	for(;;) {
	    P0=TL0 ;
	}
}
%}


%{Timer1a.A51
;
;    計時/計數器0工作在模式2的計數器; timer/counter0  working in  counter and mode 2  
;     每當在T0接腳出現3個脈波,將產生中斷,於是P0依序使bit7~bit4或bit3~bit0為1
;
;**** 閃爍(0號計數器中斷) cli ****
	ORG	00H		;開機的起始位址
	JMP	MAIN
	ORG	0BH		;0 號計數器中斷的起始位址
	CPL	A	
	MOV	P0,A
	RETI			;中斷副程式, 返回
MAIN:	MOV	TMOD,#06H	;設定, 0 號計數器工作於模式2
	MOV	TH0,#256-3
	MOV	TL0,#256-3
	SETB	EA		;致能, 所有中斷
	SETB	ET0		;致能, 0 號計數器中斷
	SETB	TR0		;啟動, 0 號計數器
	MOV	A,#0F0H
	MOV	P0,A
HALT:	JMP	HALT
	END			;程式結束
%}


%{Timer2a.A51
;
;    計時/計數器1工作在模式2的計數器; timer/counter1  working in  counter and mode 2  
;     每當在T1接腳出現3個脈波,將產生中斷,於是P0依序使bit7~bit4或bit3~bit0為1
;
;**** 閃爍(1號計數器中斷) c1i ****
	ORG	00H		;開機的起始位址
	JMP	MAIN
	ORG	1BH		;1 號計數器中斷的起始位址
	CPL	A	
	MOV	P0,A
	RETI			;中斷副程式, 返回
MAIN:	MOV	TMOD,#60H	;設定, 1 號計數器工作於模式2 
	MOV	TH1,#256-3
	MOV	TL1,#256-3
	SETB	EA		;致能, 所有中斷
	SETB	ET1		;致能, 1 號計數器中斷
	SETB	TR1		;啟動, 1 號計數器
	MOV	A,#0F0H
	MOV	P0,A
HALT:	JMP	HALT
	END			;程式結束
%}


@1
%{traffic.c
//
//   配合"12個LED實習板"
//       P0.0~P0.5控制4組紅綠燈//   P0.0~P0.5 control 4 couple of traffic light(initial state:all OFF),
////   Change form:
////        The same direction traffic lights have the same operation ,
////      green light ON 3 sec, yellow light flash 3 sec, red light ON 3 sec
////
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"

main()
{
	int i;

	for(;;) {
	    P0 = 0xde;
	    for(i=0;i<1;i++) {
		Delay100ms() ;
	    }

	    for(i=0;i<4;i++){
		if((i&1)==1){
		    P0 = 0xfe;
		}
		else{
		    P0 = 0xee;
		}
		Delay100ms() ;
	    }

	    P0 = 0xf3;
	    for(i=0;i<1;i++) {
		Delay100ms() ;
	    }

	    for(i=0;i<4;i++){
		if((i&1)==1) P0 = 0xf7;
		else 	 P0 = 0xf5;
		Delay100ms() ;
	    }
	}
}
%}


@1
%{sdelay.h
// Simulator 專用副程式//
// 進入專用副程式後, 禁止所有中斷,計時器等工作, //  delay routine dedicate to Simulator
// CPU處閒置狀態直到等待時間到達,才離開專用副程式. //

#ifndef SIMULATOR_DELAY_ROUTINE
#define SIMULATOR_DELAY_ROUTINE
#ifdef DUMMY_DELAY
void Delay100us (void)
{
	ACC = 1;
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

void Delay1ms (void)
{
	ACC = 2;
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

void Delay10ms (void)
{
	ACC = 3;
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

void Delay100ms (void)
{
	ACC = 4;
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

void Delay1s (void)
{
	ACC = 5;
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

void Delay10s (void)
{
	ACC = 6;
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

void Delay100s (void)
{
	ACC = 7;
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

void Delay100usP(unsigned char cnt)
{
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

#else
void Delay100us (void)
{
	char i;
	for(i=0; i<31; i++);
	i++;	
}

void Delay1ms (void)
{
	int i ;
	char  j;
	for(i=0 ; i < 124 ;i++) ;
	j++ ;
}

void Delay10ms (void)
{
	char i;
	for(i=0; i < 10; i++){
	    Delay1ms();
	}
}

void Delay100ms (void)
{
	long i ;
	char j ;
	for(i=0 ; i < 709 ; i++) ;  
	for(j=0 ; j < 5 ;j++) ;
	j++ ;
	j++ ;
}

void Delay1s (void)
{
	char i;
	for(i=0; i < 10; i++){
	    Delay100ms();
	}
}

void Delay10s (void)
{
	char i;
	for(i=0; i < 10; i++){
	    Delay1s();
	}
}

void Delay100s (void)
{
	char i;
	for(i=0; i < 10; i++){
	    Delay10s();
	}
}

void Delay100usP(unsigned char cnt)
{
	char i;

	while( cnt != 0 ){
	    for(i=0; i<31; i++);
	    i++;
	    cnt--;
	}
}
#endif
#endif
%}


%{rdelay.inc
;Simulator 專用副程式; delay routine dedicate to Simulator
;使用R0, R1, R2, R3; using R0, R1, R2, R3
;
DELAY100US:
	PUSH	ACC
	MOV	A,R1
	PUSH	ACC
	MOV	R1,#44
	DJNZ	R1,$
	POP	ACC
	MOV	R1,A
	POP	ACC
	RET
;
DELAY1MS:
	PUSH	ACC
	MOV	A,R1
	PUSH	ACC
	MOV	R1,#255
	DJNZ	R1,$
	MOV	R1,#236
	DJNZ	R1,$
	POP	ACC
	MOV	R1,A
	POP	ACC
	RET
;
DELAY10MS:
	PUSH	ACC
	MOV	A,R0
	PUSH	ACC
	MOV	A,R1
	PUSH	ACC
	MOV	R0,#19
DELAY10ms_1:
	MOV	R1,#255
	DJNZ	R1,$
	DJNZ	R0,DELAY10ms_1
	MOV	R1,#113
	DJNZ	R1,$
	NOP
	POP	ACC
	MOV	R1,A
	POP	ACC
	MOV	R0,A
	POP	ACC
	RET
;
DELAY100MS:
	PUSH	ACC
	MOV	A,R0
	PUSH	ACC
	MOV	A,R1
	PUSH	ACC
	MOV	R0,#194
DELAY100ms_1:
	MOV	R1,#255
	DJNZ	R1,$
	DJNZ	R0,DELAY100ms_1
	POP	ACC
	MOV	R1,A
	POP	ACC
	MOV	R0,A
	POP	ACC
        RET
;
DELAY1S:
	PUSH	ACC
	MOV	A,R2
	PUSH	ACC
	MOV	R2,#10
DELAY1s_1:
	LCALL	DELAY100MS
	DJNZ	R2,DELAY1s_1
	POP	ACC
	MOV	R2,A
	POP	ACC
	RET
;
DELAY10S:
	PUSH	ACC
	MOV	A,R2
	PUSH	ACC
	MOV	R2,#100
DELAY10s_1:
	LCALL	DELAY100MS
 	DJNZ	R2,DELAY10s_1
	POP	ACC
	MOV	R2,A
	POP	ACC
	RET
;
DELAY100S:
	PUSH	ACC
	MOV	A,R3
	PUSH	ACC
	MOV	R3,#10
DELAY100s_1:
	LCALL	DELAY10S
	DJNZ	R3,DELAY100s_1
	POP	ACC
	MOV	R2,A
	POP	ACC
	RET
;
DELAY100USP:
	PUSH	ACC
	MOV	A,R1
	PUSH	ACC
	MOV	A, R7
DELAY100usP_1:
	MOV	R1,#44
	DJNZ	R1,$
	DJNZ	ACC,DELAY100usP_1    
	POP	ACC
	MOV	R1,A
	POP	ACC
	RET
;
%}


%{sdelay.inc
; Simulator 專用副程式; delay routine dedicate to Simulator
; 進入專用副程式後, 禁止所有中斷,計時器等工作,;
; CPU處閒置狀態直到等待時間到達,才離開專用副程式. ;
DELAY100US:
	MOV	A,#01;
	SETB	F0
	SETB	F0
	SETB	F0
	RET
DELAY1MS:
	MOV	A,#02;
	SETB	F0
	SETB	F0
	SETB	F0
	RET
DELAY10MS:
	MOV	A,#03;
	SETB	F0
	SETB	F0
	SETB	F0
	RET
DELAY100MS:
	MOV	A,#04;
	SETB	F0
	SETB	F0
	SETB	F0
	RET
DELAY1S:
	MOV	A,#05;
	SETB	F0
	SETB	F0
	SETB	F0
	RET
DELAY10S:
	MOV	A,#06;
	SETB	F0
	SETB	F0
	SETB	F0
	RET
DELAY100S:
	MOV	A,#07;
	SETB	F0
	SETB	F0
	SETB	F0
	RET
DELAY100USP:
	SETB	F0
	SETB	F0
	SETB	F0
	RET
%}


@1
%{struct1.c
#pragma oe db pw(80) SM SB CD
struct{
	char year ;
	char month ;
	char day ;
	int temp ;
	int pressure;
	long acc_no ;
} tt ;
main()
{
	int i ;
//	char c;
//	c= tt.year ;
//	c=tt.month ;
//	c= tt.day ;
	i=tt.temp ;
	i=tt.pressure ;
}
%}


@1
%{struct2.c
#pragma oe db pw(80) SM SB CD
struct{
	char year ;
	char month ;
	char day ;
	int temp ;
	int pressure;
	long acc_no ;
} tt[10] ;
main()
{
	int i ;
	char c;
//	c= tt[2].year ;
//	c=tt[3].month ;
//	c= tt[4].day ;
	i=tt[2].temp ;
//	i=tt[c].pressure ;
}
%}


@1
%{timer0.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char Count ;
main()
{
	P0=Count=0 ;
	TMOD =0x10 ;
	TH0= (0xffff-10000)/256 ;
	TL0=(0xffff-10000)%256 ;
	EA=1;
	ET0=1 ;
	TR0=1 ;
	for(;;) ;
}
void timer0(void ) interrupt 1
{
	Count++ ;
	P0=Count ;
	TH0= (0xffff-10000)/256 ;
	TL0=(0xffff-10000)%256 ;
}
%}


%{bug1.a51
;
; 配合"4*5鍵盤實習板"
;   簡單鍵盤掃瞄設計
;
VAL1	EQU	0
VAL2	EQU	1
VAL3	EQU	2
START:
	MOV	VAL1,#1
	SETB	F0

	MOV	B,#0FFH
	SETB	F0
	MOV	A,#1
	SETB	F0
	CJNE	A,VAL1,ADDR1
	MOV	B,#1
	SETB	F0
	JMP	ADDR2
ADDR1:	MOV	B,#0
ADDR2:	SETB	F0
	JMP	$

	END
%}


%{sswich81.a51
LOOP:
	MOV	P0,P1
	AJMP	LOOP
	END
%}


%{test.a51
LOOP:
	MOV	P0,P1
	AJMP	LOOP
	END
%}


%{tled8.a51
;
; 配合"8個LED實習板"
;   P0所接的8個LED有二相鄰的LED亮著,並進行右旋的變化
;
	MOV	A,#01111111B
right:
	jnb	p0.0,left
	ACALL	DELAY100MS
	RR	A
	MOV	P0,A
	SJMP	right
left:
	jnb	p0.7,right
	acall	delay100ms
	rl	a
	MOV	P0,A
	sjmp	left

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


%{tt.a51
;
;   各種組譯指引(Directive)
;    配合DSEG,DS或EQU,示範內部資料記憶體的安置及位址設定
;
%0,2 di:	EQU	30H
%0,2 dd:	EQU	di+2
%1 	DSEG	AT 30H
%1 di:	DS	2
%1 dd:	DS	1
%1 	CSEG
	MOV	A,dd
	RLC	A
	SUBB	A,ACC
	MOV	di,A
	MOV	di+01H,dd
	END
%}


%{tt-1.a51
;
;   存取內部資料記憶體(位址為0,8,40h,90h)的各種方法
;
;
;   將內部記憶體位址0載入到ACC(三種)
	MOV	A,R0
	CLR	A

	MOV	A,00
	CLR	A

	MOV	R1,#00
	MOV	A,@R1

;     將內部記憶體位址8載入到ACC(三種)
	SETB	RS0
	MOV	A,R0
	CLR	RS0
	CLR	A

	MOV	A,08
	CLR	A

	MOV	R1,#08
	MOV	A,@R1
	CLR	A

;     將內部記憶體位址40h載入到ACC(二種)

	MOV	A,40h
	CLR	A

	MOV	R1,#40h
	MOV	A,@R1
	CLR	A

;     將內部記憶體位址40h載入到ACC(一種)

	MOV	A,90h     ; 錯誤結果(存取到特殊暫存器)
	CLR	A

	MOV	R1,#90h
	MOV	A,@R1
	CLR	A

	END
%}


@1
%{dotmatrix1.c
#pragma   sm  sb cd
#include	<reg51.h>
unsigned char code dai[]= { 0xfe,0xdd,0xdb,0x0f,0xd7,0xdb,0xdd,0xfe} ;
delay()
{
	long i ;
	for(i=0;i < 100L ;i++) ;
}
main()
{
	char i ;
	char com ;
	i=0 ;
	com=0x80 ;
	for( ; ;){
	    P1=0 ;
	    P0=dai[i++] ;
	    P1=com ;
	    com >>=1 ;
	    if(i >=8){
		i=0 ;
		com=0x80 ;
	    }
	    delay() ;
	}
}
%}


@1
%{dotmtx1.c
//
//  配合"8*8單色點矩陣LED實習板"
//   在8*8單色點矩陣LED上顯示中文字---"大"
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned char code dai[]= { 0xfd,0xdb,0xd7,0x0f,0xd7,0xdb,0xdd,0xff} ;
void delay1ms()
{
	int i ;
	char  j;
	for(i=0 ; i < 124 ;i++) ;
	j++ ;
}
delay3ms()
{
	delay1ms() ;
	delay1ms() ;
	delay1ms() ;
}
main()
{
	unsigned char com ,idx;

	com=0x80 ;
	idx=0 ;
	for( ;;){
	    P1=0xff ;
	    P0=dai[idx++] ;
	    P1=~com ;
	    com >>=1 ;
	    if(idx==8){
		idx=0;
		com=0x80 ;
	    }
	    delay3ms() ;
	}
}
%}


@1
%{dtype1.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char val1,val2,res,i;
char data *pcd ;
char code *pcc ;
int ival1,ival2,ires;
int data *pid ;
long lval1,lval2,lres;
long data *pld ;
main()
{
	pcd= &val1 ;
	val1= *pcd ;
	val2= pcd[1] ;
	val1= pcd[i] ;
	ival1= *pid ;
	ival2= pid[1] ;
	ival1= pid[i] ;
	lval1= *pld ;
	lval2= pld[1] ;
	lval1= pld[i] ;

	res=val1+val2 ;
	for(;;);
}
%}

1


181


