C51 COMPILER V8.17   CALENDAR2                                                             06/04/2009 17:04:07 PAGE 1   


C51 COMPILER V8.17, COMPILATION OF MODULE CALENDAR2
OBJECT MODULE PLACED IN calendar2.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE calendar2.C OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //************* calendar2.c *************************************
   2          //以計時中斷，進行萬年曆電子鐘顯示年、月、日、時、分、秒、星期
   3          //年、月、日、時、分、秒可自由設定，星期由程式判斷自行產生
   4          //作者:游景翔(青輔會青年職訓中心100期電子應用班)
   5          //*************************************************************
   6          #include "..\MPC82.H"   //暫存器及組態定義
   7          
   8                            //Fosc=22.1184MHz，Timer時脈=Fosc/12=1.8432MHz
   9          #define T  57600  //Timer延時時間=(1/1.8432MHz)*57600=31250uS
  10           unsigned char dly_sec=32; //設定計時重覆次數，時間=31250uS*32=1秒
  11           unsigned char sec=55; //設定秒初值     
  12          
  13          char code mes[]="\000\001\002";//0=年、1=月、2=日
  14          char code Table[]={
  15            0x10,0x1f,0x02,0x0f,0x0a,0xff,0x02,0x00, //年
  16            0x0f,0x09,0x0f,0x09,0x0f,0x09,0x13,0x00, //月
  17            0x0f,0x09,0x09,0x0f,0x09,0x09,0x0f,0x00};//日
  18          
  19          main()
  20          {
  21   1         int year=2009;      //設定年
  22   1         char mon=1,day=20;  //設定月、日
  23   1         char hor=13,min=32; //設定時、分值
  24   1         char i;                     //變數宣告
  25   1         int y,m,d;              //陣列資料計數
  26   1         
  27   1         EA=1;ET1=1; //致能Timet1計時溢位中斷
  28   1         TMOD=0x10;  //設定Timer1為mode1內部計時
  29   1         TR1=1;      //啟動Timer1
  30   1                                                  
  31   1         LCD_init();           //重置及清除LCD 
  32   1         for(i=0x0;i<=0x3f;i++) //寫入年月日字型 
  33   1         {
  34   2           LCD_Cmd(0x40+i);    //指定CGRAM位址  
  35   2           LCD_Data(Table[i]); //寫入CGRAM資料  
  36   2         } 
  37   1         while(1)       //開始顯示及計算萬年曆
  38   1         {    
  39   2              LCD_Cmd(0x80);  //顯示第一行位置
  40   2              LCD_Data(year/1000+'0');  //年的千位數到LCD顯示
  41   2              LCD_Data(year%1000/100+'0'); //年的百位數到LCD顯示
  42   2              LCD_Data(year%100/10+'0'); //年的十位數到LCD顯示
  43   2          LCD_Data(year%10+'0'); //年的個位數到LCD顯示
  44   2              for(i=0;i<1;i++) LCD_Data(mes[i]); //顯示年
  45   2              LCD_Data(' ');  LCD_Data(' '); //空格
  46   2              
  47   2          LCD_Data(mon/10+'0'); //月的十位數到LCD顯示
  48   2          LCD_Data(mon%10+'0'); //月的個位數到LCD顯示
  49   2          for(i=1;i<2;i++) LCD_Data(mes[i]); //顯示月
  50   2              LCD_Data(' ');  LCD_Data(' ');  //空格
  51   2      
  52   2          LCD_Data(day/10+'0'); //日的十位數到LCD顯示
  53   2          LCD_Data(day%10+'0'); //日的個位數到LCD顯示
  54   2              for(i=2;i<3;i++) LCD_Data(mes[i]); //顯示日
  55   2          
C51 COMPILER V8.17   CALENDAR2                                                             06/04/2009 17:04:07 PAGE 2   

  56   2              LCD_Cmd(0xc0); //顯示第二行位置
  57   2              if(hor==12) //12時上午轉下午
  58   2               { LCD_Data('P'); LCD_Data('M'); LCD_Data(' ');} //顯示PM
  59   2              if(hor==24) //24時下午轉上午 
  60   2               { LCD_Data('A'); LCD_Data('M'); LCD_Data(' ');}//顯示AM
  61   2               
  62   2              if(hor<12) //時小於12
  63   2              { LCD_Data('A'); LCD_Data('M'); LCD_Data(' ');}  //顯示AM
  64   2                else if(hor>12 && hor<=23) //小時介於12-23之間
  65   2                 { LCD_Data('P');  LCD_Data('M');  LCD_Data(' ');} //顯示PM
  66   2              
  67   2              if(hor<=12)             //時小於/等於12
  68   2                {
  69   3              LCD_Data(hor/10+'0');LCD_Data(hor%10+'0'); //顯示時
  70   3              LCD_Data(':');
  71   3             } 
  72   2                 else    //時大於12
  73   2                 {       
  74   3                   LCD_Data((hor-12)/10+'0'); LCD_Data((hor-12)%10+'0');//顯示時
  75   3               LCD_Data(':');
  76   3                  }
  77   2                
  78   2                        LCD_Data(min/10+'0');LCD_Data(min%10+'0'); //顯示分
  79   2                LCD_Data(':');
  80   2          
  81   2                LCD_Data(sec/10+'0'); LCD_Data(sec%10+'0');//顯示秒
  82   2                LCD_Data(' ');
  83   2      
  84   2              if(year%4==0) //閏年
  85   2              {
  86   3                      y=((year-1)+(year-1)/4-(year-1)/100+(year-1)/400); 
  87   3                      switch (mon)   //逢4年閏年,逢百不閏,逢400年閏年
  88   3                      {
  89   4                              case 1:  m=day; break;       //1月
  90   4                              case 2:  m=(day+31); break;  //2月
  91   4                              case 3:  m=(day+60); break;  //3月
  92   4                              case 4:  m=(day+91); break;  //4月
  93   4                              case 5:  m=(day+121); break; //5月
  94   4                              case 6:  m=(day+152); break; //6月
  95   4                              case 7:  m=(day+182); break; //7月
  96   4                              case 8:  m=(day+213); break; //8月
  97   4                              case 9:  m=(day+244); break; //9月
  98   4                              case 10: m=(day+274); break; //10月
  99   4                              case 11: m=(day+305); break; //11月
 100   4                              case 12: m=(day+335); break; //12月
 101   4                        }
 102   3               }
 103   2              else if(year%4==1||2||3)        //非閏年
 104   2               {
 105   3                      y=((year-1)+(year-1)/4-(year-1)/100+(year-1)/400);
 106   3                      switch (mon)
 107   3                      {
 108   4                              case 1:  m=day;       break; //1月
 109   4                              case 2:  m=(day+31);  break; //2月
 110   4                              case 3:  m=(day+59);  break; //3月
 111   4                              case 4:  m=(day+90);  break; //4月
 112   4                              case 5:  m=(day+120); break; //5月
 113   4                              case 6:  m=(day+151); break; //6月
 114   4                              case 7:  m=(day+187); break; //7月
 115   4                              case 8:  m=(day+212); break; //8月
 116   4                              case 9:  m=(day+243); break; //9月
 117   4                              case 10: m=(day+273); break; //10月
C51 COMPILER V8.17   CALENDAR2                                                             06/04/2009 17:04:07 PAGE 3   

 118   4                              case 11: m=(day+304); break; //11月
 119   4                              case 12: m=(day+334); break; //12月
 120   4                      }
 121   3              }
 122   2              d=(y+m)%7;      //總天數除以7的餘數
 123   2              if(d==1) //星期一
 124   2                { LCD_Data('M');LCD_Data('o');LCD_Data('n');} //顯示Mon
 125   2              
 126   2              if(d==2) //星期二
 127   2                { LCD_Data('T');LCD_Data('u');LCD_Data('e');} //顯示Tue
 128   2              
 129   2              if(d==3) //星期三
 130   2                { LCD_Data('W');LCD_Data('e');LCD_Data('d');} //顯示Wed
 131   2              
 132   2              if(d==4) //星期四
 133   2                { LCD_Data('T');LCD_Data('h');LCD_Data('u');} //顯示Thu
 134   2              
 135   2              if(d==5) //星期五
 136   2                { LCD_Data('F');LCD_Data('r');LCD_Data('i');} //顯示Fri
 137   2              
 138   2              if(d==6)  //星期六
 139   2                { LCD_Data('S');LCD_Data('a');LCD_Data('t');} //顯示Sat
 140   2              
 141   2              if(d==0)  //星期日
 142   2                { LCD_Data('S');LCD_Data('u');LCD_Data('n');} //顯示Sun
 143   2      
 144   2          if (sec < 60) continue; //若秒小於60到while(1)處   
 145   2          sec=0; min++;           //秒等於60則令秒=0，分加一
 146   2          if (min < 60) continue; //若分小於60到while(1)處   
 147   2          min=0; hor++;           //若分等於60則令分=0，時加一
 148   2              if(hor==24) 
 149   2               {
 150   3                switch (day)  //檢查日
 151   3                 {
 152   4                      case 28:   //日=28
 153   4                       if(year%4==0 && mon==2) day++;//29天//閏年2月
 154   4                        else if(mon==2) { day=0; mon++;}//28天
 155   4                              else day++;      break;
 156   4                      
 157   4                      case 29: //日=29
 158   4                        if(year%4==0 && mon==2) { day=0;mon++; }
 159   4                          else day++;  break;
 160   4                      
 161   4                      case 30: //日=30
 162   4                        if(mon==4 || mon==6 || mon==9 || mon==11) 
 163   4                              {day=0;mon++;}  //4.6.9.11月30天
 164   4                                else day++; break;
 165   4                              
 166   4                      case 31: //日=31
 167   4                        if(mon==1||mon==3||mon==5||mon==7||mon==8||mon==10) 
 168   4                              { day=0;mon++; }   //1.3.5.7.8.10月31天
 169   4                                 else if(mon==12)
 170   4                                      { day=0; mon=1;year++;}  //過年
 171   4                              break;
 172   4                 }
 173   3                if(day<28) day++;     //日<28
 174   3               }
 175   2          if (hor <25)  continue; //若時小於24到while(1)處
 176   2          hor=1;min=0; sec=0;//若時等於24則令時、分、秒=0 
 177   2        }
 178   1      }
 179          /*******************************************************/ 
C51 COMPILER V8.17   CALENDAR2                                                             06/04/2009 17:04:07 PAGE 4   

 180          void T1_int(void) interrupt 3  //Timer1中斷函數
 181          {
 182   1        TL1= (65536-T) % 256; //將低8-bit計數值存入TL1 
 183   1        TH1= (65536-T) / 256; //將高8-bit計數值存入TH1 
 184   1        dly_sec--;            //計時重覆次數遞減
 185   1        if(dly_sec==0)        //若秒時間到
 186   1         { sec++; dly_sec=32;}//秒遞加及設定計時重覆次數
 187   1        TF1=0;                //清除計時溢位TF1=0
 188   1      }
 189          /***********************************************************
 190          *函數名稱: LCD_Data
 191          *功能描述: 傳送資料到文字型LCD
 192          *輸入參數：dat
 193          ************************************************************/
 194          void LCD_Data(char dat)  //傳送資料到LCD
 195          {
 196   1          Data=dat; //資料送到BUS
 197   1          RS=1;RW=0;EN=1;//資料寫入到LCD內
 198   1          Delay_ms(1);   //LCD等待寫入完成
 199   1          EN=0;          //禁能LCD    
 200   1      }
 201          /***************************************************************
 202          *函數名稱: LCD_Cmd
 203          *功能描述: 傳送命令到文字型LCD
 204          *輸入參數：Cmd
 205          ************************************************************/
 206          void LCD_Cmd(unsigned char Cmd) //傳送命令到LCD
 207          {
 208   1          Data=Cmd;  //命令送到BUS
 209   1          RS=0;RW=0;EN=1; //命令寫入到LCD內
 210   1          Delay_ms(1);    //LCD等待寫入完成     
 211   1          EN=0;           //禁能LCD
 212   1      }
 213          /***************************************************************
 214          *函數名稱: LCD_init
 215          *功能描述: 啟始化文字型LCD
 216          *****************************************************************/
 217          void LCD_init(void)    //LCD的啟始程式  
 218          {
 219   1          LCD_Cmd(0x38);/*0011 1000,8bit傳輸,顯示2行,5*7字型
 220   1                          bit4:DL=1,8bit傳輸,
 221   1                          bit3:N=1,顯示2行
 222   1                          bit2:F=0,5*7字型*/    
 223   1          LCD_Cmd(0x0c);/*0000 1100,顯示幕ON,不顯示游標,游標不閃爍
 224   1                          bit2:D=1,顯示幕ON
 225   1                          bit1:C=0,不顯示游標
 226   1                              bit0:B=0,游標不閃爍*/
 227   1          LCD_Cmd(0x06);/*0000 0110,//顯示完游標右移,游標移位禁能 
 228   1                          bit1:I/D=1,顯示完游標右移,
 229   1                          bit0:S=0,游標移位禁能*/  
 230   1          LCD_Cmd(0x01); //清除顯示幕  
 231   1          LCD_Cmd(0x02); //游標回原位  
 232   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1992    ----
   CONSTANT SIZE    =     28    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     21    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V8.17   CALENDAR2                                                             06/04/2009 17:04:07 PAGE 5   

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
