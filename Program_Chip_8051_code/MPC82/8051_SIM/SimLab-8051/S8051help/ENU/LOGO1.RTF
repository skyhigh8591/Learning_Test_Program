{\rtf1\ansi\ansicpg950\uc2 \deff0\deflang1033\deflangfe1028{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f18\froman\fcharset136\fprq2{\*\panose 02020300000000000000}\'b7\'73\'b2\'d3\'a9\'fa\'c5\'e9{\*\falt PMingLiU};}{\f22\fmodern\fcharset136\fprq1{\*\panose 02020309000000000000}\'b2\'d3\'a9\'fa\'c5\'e9{\*\falt MingLiU};}
{\f27\fmodern\fcharset136\fprq1{\*\panose 02020309000000000000}@\'b2\'d3\'a9\'fa\'c5\'e9;}{\f28\froman\fcharset136\fprq2{\*\panose 02020300000000000000}@\'b7\'73\'b2\'d3\'a9\'fa\'c5\'e9;}{\f33\froman\fcharset238\fprq2 Times New Roman CE;}
{\f34\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f36\froman\fcharset161\fprq2 Times New Roman Greek;}{\f37\froman\fcharset162\fprq2 Times New Roman Tur;}{\f38\froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\f39\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f40\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f49\fmodern\fcharset238\fprq1 Courier New CE;}{\f50\fmodern\fcharset204\fprq1 Courier New Cyr;}
{\f52\fmodern\fcharset161\fprq1 Courier New Greek;}{\f53\fmodern\fcharset162\fprq1 Courier New Tur;}{\f54\fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f55\fmodern\fcharset178\fprq1 Courier New (Arabic);}
{\f56\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;
\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\sl360\slmult0
\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\f0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\ql \li0\ri0\sl360\slmult0
\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\f0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 \sbasedon0 \snext15 footnote text;}{\*\cs16 \additive \super\loch\f18\hich\af18\dbch\af18 \sbasedon10 
footnote reference;}{\s17\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1028\kerning2\loch\f22\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 \sbasedon0 \snext17 Plain Text;}{
\s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\f2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 \sbasedon17 \snext18 \'ab\'fc\'a5\'4f;}{\s19\ql \li0\ri0\sl360\slmult0
\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\f2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 \sbasedon0 \snext19 \'ab\'fc\'a5\'4f\'b1\'d4\'ad\'7a;}}{\*\listtable{\list\listtemplateid-47144578\listsimple
{\listlevel\levelnfc255\levelnfcn255\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent300{\leveltext\'01.;}{\levelnumbers;}\i0\fs24\loch\af18\dbch\af18\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias1 \fi-300\li780 }
{\listname ;}\listid265816444}}{\*\listoverridetable{\listoverride\listid265816444\listoverridecount0\ls1}}{\info{\author ccy}{\operator \'b6\'c0\'aa\'46\'aa\'da}{\creatim\yr1999\mo2\dy10\hr23\min43}{\revtim\yr2000\mo11\dy7\hr18}
{\printim\yr2000\mo9\dy28\hr18\min23}{\version40}{\edmins503}{\nofpages73}{\nofwords7209}{\nofchars-32766}{\*\company  }{\nofcharsws0}{\vern8249}}\paperw11906\paperh16838\margl1800\margr1800\margt1440\margb1440\gutter0 
\deftab480\ftnbj\aenddoc\hyphcaps0\formshade\horzdoc\dgmargin\dghspace180\dgvspace180\dghorigin1800\dgvorigin1440\dghshow0\dgvshow2\jcompress\ksulang1028\viewkind4\viewscale100 {\*\fchars 
!),.:\'3b?]\'7d\'a1\'50\'a1\'56\'a1\'58\'a1\'a6\'a1\'a8\'a1\'4c\'a1\'4b\'a1\'45\'a1\'ac\'a1\'5a\'a1\'42\'a1\'43\'a1\'72\'a1\'6e\'a1\'76\'a1\'7a\'a1\'6a\'a1\'66\'a1\'aa\'a1\'4a\'a1\'57\'a1\'59\'a1\'5b\'a1\'60\'a1\'64\'a1\'68\'a1\'6c\'a1\'70\'a1\'74
\'a1\'78\'a1\'7c\'a1\'5c\'a1\'4d\'a1\'4e\'a1\'4f\'a1\'51\'a1\'52\'a1\'53\'a1\'54\'a1\'7e\'a1\'a2\'a1\'a4\'a1\'49\'a1\'5e\'a1\'41\'a1\'44\'a1\'47\'a1\'46\'a1\'48\'a1\'55\'a1\'62}{\*\lchars 
([\'7b\'a1\'a5\'a1\'a7\'a1\'ab\'a1\'71\'a1\'6d\'a1\'75\'a1\'79\'a1\'69\'a1\'65\'a1\'a9\'a1\'5f\'a1\'63\'a1\'67\'a1\'6b\'a1\'6f\'a1\'73\'a1\'77\'a1\'7b\'a1\'7d\'a1\'a1\'a1\'a3\'a1\'5d\'a1\'61}\fet0\sectd 
\linex0\headery851\footery992\colsx425\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta \dbch .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta \dbch .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang
{\pntxta \dbch .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta \dbch )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb \dbch (}{\pntxta \dbch )}}
{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb \dbch (}{\pntxta \dbch )}}
\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote \pard\plain 
\s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0  main_id}}}{
\fs20 \{\hich\af0\dbch\af18\loch\f0 bml logo1.shg\}
\par \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote \pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {
\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0  instruction_id}}}{\b\fs40\cf6 \hich\af0\dbch\af18\loch\f0 8051 Instruction Set}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 ACALL code address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 acall_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 ADD A,#data  ADD A,@Rr  ADD A,Rr  ADD A,data address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 add_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 ADDC A,#data  ADDC A,@Rr  ADDC A,Rr  ADC A,data address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 addc_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 AJMP code address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 ajmp_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 ANL A,#data  ANL A,@Rr  ANL A,Rr  ANL A,data address  ANL C,bit address  ANL C,/bit address  ANL data address,#data  ANL data address,A}{\v\fs20 \hich\af0\dbch\af18\loch\f0 anl_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 CJNE @Rr,#data,code\hich\af0\dbch\af18\loch\f0  address  CJNE A,#data,code address  CJNE A,data address,code address  CJNE Rr,#data,code address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 cjne_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 CLR A  CLR C  CLR bit address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 clr_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 CPL A  CPL C  CPL bit address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 cpl_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 DA A}{\v\fs20 \hich\af0\dbch\af18\loch\f0 da_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 DEC @Rr  DEC A  DEC Rr  DEC data address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 dec_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 DIV AB}{\v\fs20 \hich\af0\dbch\af18\loch\f0 div_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 DJNZ  Rr,\hich\af0\dbch\af18\loch\f0 code address  DJNZ data address,code address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 djnz_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 INC @Rr  INC A  INC DPTR  INC Rr  INC data address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 inc_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 JB bit address,code address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 jb_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 JBC bit address,code address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 jbc_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 JC bit code address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 jc_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 JMP @A+DPTR}{\v\fs20 \hich\af0\dbch\af18\loch\f0 jmp_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 JNB bit address,code address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 jnb_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 J\hich\af0\dbch\af18\loch\f0 NC code address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 jnc_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 JNZ code address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 jnz_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 JZ code address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 jz_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 LCALL code address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 lcall_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 LJMP code address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 ljmp_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 MOV @Rr,#data  MOV \hich\af0\dbch\af18\loch\f0 
@Rr,A  MOV @Rr,data address  MOV A,#data  MOV A,@Rr  MOV A,Rr  MOV A,data address  MOV C,bit address  MOV DPTR,#data  MOV Rr,#data  MOV Rr,A  MOV Rr,data address  MOV bit address,C  MOV data address,#data  MOV data address,@Rr  MOV data address,A  MOV dat
\hich\af0\dbch\af18\loch\f0 a\hich\af0\dbch\af18\loch\f0  address,Rr  MOV data address1,data address 2}{\v\fs20 \hich\af0\dbch\af18\loch\f0 mov_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 MOVC A,@A+DPTR  MOVC A,@A+PC}{\v\fs20 \hich\af0\dbch\af18\loch\f0 movc_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 MOVX @DPTR,A  MOVX @Rr,A  MOVX A,@DPTR  MOVX A,@Rr}{\v\fs20 \hich\af0\dbch\af18\loch\f0 movx_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 MUL AB}{\v\fs20 \hich\af0\dbch\af18\loch\f0 mul_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 NOP}{\v\fs20 \hich\af0\dbch\af18\loch\f0 nop_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 ORL A,#data  ORL A,@Rr  ORL A,Rr  ORL A,data address  ORL C,bit address  ORL C,/bit add\hich\af0\dbch\af18\loch\f0 ress  ORL data address,#data  ORL data address,A}{\v\fs20 \hich\af0\dbch\af18\loch\f0 orl_id}{
\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 POP data address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 pop_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 PUSH data address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 push_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 RET}{\v\fs20 \hich\af0\dbch\af18\loch\f0 ret_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 RETI}{\v\fs20 \hich\af0\dbch\af18\loch\f0 reti_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 RL A}{\v\fs20 \hich\af0\dbch\af18\loch\f0 rl_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 RLC A}{\v\fs20 \hich\af0\dbch\af18\loch\f0 rlc_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 RR A}{\v\fs20 \hich\af0\dbch\af18\loch\f0 rr_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 RRC A}{\v\fs20 \hich\af0\dbch\af18\loch\f0 rrc_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 SETB C  SETB bit address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 setb_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 SJMP code address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 sjmp_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 SUBB A,#data  SUBB A,@Rr  SUBB\hich\af0\dbch\af18\loch\f0  A,Rr  SUBB A,data address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 subb_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 SWAP A}{\v\fs20 \hich\af0\dbch\af18\loch\f0 swap_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 XCH A,@Rr  XCH A,Rr  XCH A,data address}{\v\fs20 \hich\af0\dbch\af18\loch\f0 xch_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 XCHD A,@Rr}{\v\fs20 \hich\af0\dbch\af18\loch\f0 xchd_id}{\fs20 
\par }{\fs20\uldb \hich\af0\dbch\af18\loch\f0 XRL A,#data  XRL A,@Rr  XRL A,Rr  XRL A,data address  XRL data address,#data  XRL data address,A}{\v\fs20 \hich\af0\dbch\af18\loch\f0 xrl_id}{\fs20 
\par \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote \pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {
\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0  acall_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 ACALL code address(Absolute
\hich\af2\dbch\af22\loch\f2  call within 2K byte page)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 A10 A9 A8 1 0001
\par \tab \hich\af2\dbch\af18\loch\f2 A7 A6 A5 A4 A3 A2 A1 A0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+2
\par \tab \hich\af2\dbch\af18\loch\f2 (SP)<-(SP)+1
\par \tab \hich\af2\dbch\af18\loch\f2 ((SP))<- (PC0~7) 
\par \tab \hich\af2\dbch\af18\loch\f2 (SP)<-(SP)+1
\par \tab \hich\af2\dbch\af18\loch\f2 ((SP))<- (PC8~15)
\par \tab \hich\af2\dbch\af18\loch\f2 (PC0~10)<-A0~10
\par \hich\af2\dbch\af18\loch\f2 Number  of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags : \tab No 
\par \hich\af2\dbch\af18\loch\f2 Descrip\hich\af2\dbch\af18\loch\f2 tion:
\par \tab \hich\af2\dbch\af18\loch\f2 
This instruction stores the program counter value (return address) in the stack following an increment operation. The program counter data PC0~ PCl0 following PC+2 is replaced by 11-bit page address data A0~ Al0. The destination address for this ins
\hich\af2\dbch\af18\loch\f2 truction must always be within the 2K byte page, but if the instruction is placed at address X7FEH or X7FFH, execution proceeds from the call address on the next page.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 add_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 ADD A,#data  (Add immediate data)

\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0010 0100
\par \tab \hich\af2\dbch\af18\loch\f2 I7 I6 I5 I4 \hich\af2\dbch\af18\loch\f2 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (A)<-(A)+#data 
\par \hich\af2\dbch\af18\loch\f2 Number of bytes: \tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles: \tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:
\par \tab \hich\af2\dbch\af18\loch\f2 C  AC  F0 RS1 RS0 OV  Fl  P
\par \tab \hich\af2\dbch\af18\loch\f2 ?  ?                ?        ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 An 8-bit immediate data value is added to the accumulator. The result is placed in the accumu\hich\af2\dbch\af18\loch\f2 lator and the flags are updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 ADD A,@Rr (Add indirect address)

\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0010 011r  
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<-(A)+((Rr))  r=0 or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags: \tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab ?  ?               ?       ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The data memory location contents addressed by the register r are added to the accumulator. The result is placed in the accumulator and the flags are updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 ADD A,Rr   (Add register)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0010 1 r2 r1 r0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<-(A)+(Rr)   r=0~7
\par \hich\af2\dbch\af18\loch\f2 N\hich\af2\dbch\af18\loch\f2 umber of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab ?  ?               ?       ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The register r contents are added to the accumulator. The result is placed in the accumulator and the flags are updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 ADD A,data a
\hich\af2\dbch\af22\loch\f2 ddress     (Add memory)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0010 0101
\par \tab \hich\af2\dbch\af18\loch\f2 a7 a6 a5 a4 a3 a2 a1 a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <- (A) + (data address)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab ?  ?                ?      ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The specified data address contents are added to the accumulator. The result is placed in the accumulator and the flags are updated.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 
\par \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote \pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {
\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0  addc_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ADDC A, #data (Add carry plus immediate data to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0011 0100
\par \hich\af2\dbch\af18\loch\f2    \tab I7 I6 I5 I4 I3 \hich\af2\dbch\af18\loch\f2 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <- (A) + (C) + #data 
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab ?  ?                ?      ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The carry flag is added to the accumulator, and an 8-bit immediate data is added to that \hich\af2\dbch\af18\loch\f2 result. The result is placed in the accumulator and the flags are updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ADDC A,@Rr  (Add carry plus indirect address to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab  0011 011r
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<-(A)+(C)+((Rr))   r=0 or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C\hich\af2\dbch\af18\loch\f2   AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab ?  ?                ?      ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The carry flag is added to the accumulator, and the contents of data memory location addressed by the register r contents are added to that result. The result is placed in the accumu\hich\af2\dbch\af18\loch\f2 
lator and the flags are updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ADDC A,Rr  (Add carry plus register to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0011 1 r2 r1 r0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<- (A)+(C)+(Rr)   r=0-7
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab \hich\af2\dbch\af18\loch\f2 ?  ?                ?      ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The carry flag is added to the accumulator, and the register r contents are added to that result. The result is placed in the accumulator and the flags are updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ADDC A,data address     (Add carry plus memory\hich\af2\dbch\af22\loch\f2  to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0011 0101
\par \hich\af2\dbch\af18\loch\f2     \tab a7 a6 a5 a4 a3 a2 a1 a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <- (A) + (C) + (data address)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab ?  ?                ?      ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The carry flag \hich\af2\dbch\af18\loch\f2 is added to the accumulator, and the specified data address contents are added to that result. The result is placed in the accumulator and the flags are updated.
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 ajmp_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
AJMP code address    (Absolute jump within 2K byte page)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 Al0 A9 A8 0 0001
\par \hich\af2\dbch\af18\loch\f2    \tab A7 A6 A5 A4 A3 A2 A1 A0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+2 
\par \tab \hich\af2\dbch\af18\loch\f2 (PC0~l0)<-A0~l0
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 
After an increment, the program counter PC0~PC10 is replaced by 11-bit page address data A0~Al0. The destination address for this instruction must always be within the 2K byte page, but if the instruction is placed at address X7FEH or X7FFH, execution pro
\hich\af2\dbch\af18\loch\f2 c\hich\af2\dbch\af18\loch\f2 eeds from the jump address on the next page.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 anl_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ANL A,#data  (Logical AND immediate data to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0101 0100
\par \hich\af2\dbch\af18\loch\f2    \tab I7 I6 I5 I4 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<-(A) AND #data
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 \hich\af2\dbch\af18\loch\f2 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The logical AND between an 8-bit immediate data value and the accumulator contents is determined. The result is stored in the accumulator and the flag is also updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 ANL A,@Rr  (Logica
\hich\af2\dbch\af22\loch\f2 l AND indirect address to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0101 011 r
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<-(A) AND ((Rr))   r=0 or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The logical AND between the accumulator contents and the data memory location contents addressed by the register r is determined. The result is stored in the accumulator and the flag is also updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ANL A,Rr    (Logical AND register to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Inst\hich\af2\dbch\af18\loch\f2 ruction code:
\tab 0101 1 r2 r1 r0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<-(A) AND (Rr)   r=0~7 
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The logical AND between the accumulator contents and the register \hich\af2\dbch\af18\loch\f2 r contents is determined. The result is stored in the accumulator and the flag is also updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ANL A,data address   (Logical AND memory to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0101 0101
\par \hich\af2\dbch\af18\loch\f2   \tab a7 a6 a5 a4 a3 a2 a1 a0 
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<-(A) AND (data address) 
\par \hich\af2\dbch\af18\loch\f2 Numb\hich\af2\dbch\af18\loch\f2 er of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The logical AND between the accumulator contents and  the  specified  data  address  contents  is determined. The result is stored in the \hich\af2\dbch\af18\loch\f2 accumulator and the flag is also updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ANL C,bit address     (Logical AND bit to carry flag)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1000 0010
\par \hich\af2\dbch\af18\loch\f2   \tab b7 b6 b5 b4 b3 b2 b1
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (C) <- (C) AND (bit address)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes: \tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab \hich\af2\dbch\af18\loch\f2 C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The logical AND between the carry flag and the specified bit address content is determined. The result is stored in the carry flag.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ANL C,/bit address   (Logical AND complement bit to carry flag)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instructio\hich\af2\dbch\af18\loch\f2 n code:

\par \tab \hich\af2\dbch\af18\loch\f2 1011 0000
\par \hich\af2\dbch\af18\loch\f2    \tab b7 b6 b5 b4 b3 b2 b1 b0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (C) <- (C) AND /(bit address)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The logical AND between the carry flag and the complement of specified bit\hich\af2\dbch\af18\loch\f2  address content is determined. The result is stored in the carry flag.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ANL data address,#data     (Logical AND immediate data to memory)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0101 0011
\par \hich\af2\dbch\af18\loch\f2   \tab a7 a6 a5 a4 a3 a2 a1 a0 
\par \hich\af2\dbch\af18\loch\f2   \tab I7 I6 I5 I4 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab \hich\af2\dbch\af18\loch\f2 (data address) <- (data address) AND #data
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The logical AND between an 8-bit immediate data value and the specified data address contents is determined. The result is stored in the specified dat\hich\af2\dbch\af18\loch\f2 a address.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ANL data address,A  (Logical AND accumulator to memory)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0101 0010
\par \hich\af2\dbch\af18\loch\f2   \tab a7 a6 a5 a4 a3 a2 a1 a0 
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (data address) <- (data address) AND (A) 
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The logical AN\hich\af2\dbch\af18\loch\f2 D between the accumulator and the specified data address contents is determined. The result is stored in the specified data address.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 cjne_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
CJNE @Rr,#data,code address  (Compare indirect address to immediate data, jump if not equal)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1011 011 r
\par \hich\af2\dbch\af18\loch\f2  \tab I7 I6 I5 I4 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2  \tab R7 R6 R5 R4 R3 R2 R1 R0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+3
\par \tab \hich\af2\dbch\af18\loch\f2 IF ((Rr)) != #data        \tab r = 0 or 1 
\par \tab \hich\af2\dbch\af18\loch\f2 THEN 
\par \tab \hich\af2\dbch\af18\loch\f2   (PC) <- (PC) + relative offset
\par \tab \hich\af2\dbch\af18\loch\f2 IF((Rr)) < #data \tab \tab r=0 or 1
\par \tab \hich\af2\dbch\af18\loch\f2 THEN 
\par \tab \hich\af2\dbch\af18\loch\f2   (C)<-l
\par \tab \hich\af2\dbch\af18\loch\f2 ELSE
\par \tab \hich\af2\dbch\af18\loch\f2   (C)<-0
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The data memory location contents addressed by the register r contents are compared with an immediate data value. Control is shifted to a relative jump address if the compared data\hich\af2\dbch\af18\loch\f2 
 is not equal. If the compared data is equal, control is shifted to the next address following this instruction. The carry flag is set to 1 if the immediate data value is greater than the specified address contents, but is set to 0 if otherwise
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 CJNE A,#d
\hich\af2\dbch\af22\loch\f2 ata,code address   (Compare immediate data to accumulator, jump if not equal)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1011 0100
\par \hich\af2\dbch\af18\loch\f2   \tab I7 I6 I5 I4 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2   \tab R7 R6 R5 R4 R3 R2 R1 R0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+3
\par \tab \hich\af2\dbch\af18\loch\f2 IF (A) != #data         
\par \tab \hich\af2\dbch\af18\loch\f2 THEN 
\par \tab \hich\af2\dbch\af18\loch\f2    (PC) <- (PC) + relative offset
\par \tab \hich\af2\dbch\af18\loch\f2 IF(A) < #data \tab \tab 
\par \tab \hich\af2\dbch\af18\loch\f2 THEN 
\par \tab \hich\af2\dbch\af18\loch\f2   (C)<-l
\par \tab \hich\af2\dbch\af18\loch\f2 ELSE
\par \tab \hich\af2\dbch\af18\loch\f2   (C)<-0
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator contents are compared with an immediate data value, and control is shifted to a relative jump ad\hich\af2\dbch\af18\loch\f2 
dress if the compared data is not equal. If the compared data is equal, control is shifted to the next address following this instruction. The carry flag is set to 1 if the immediate data value is greater than the accumulator contents, but is set to 0 if 
\hich\af2\dbch\af18\loch\f2 o\hich\af2\dbch\af18\loch\f2 therwise.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
CJNE A,data address,code address   (Compare memory to accumulator, jump if not equal)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1011 0101
\par \hich\af2\dbch\af18\loch\f2   \tab a7 a6 a5 a4 a3 a2 al a0
\par \hich\af2\dbch\af18\loch\f2   \tab R7 R6 R5 R4 R3 R2 R1 R0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+3
\par \tab \hich\af2\dbch\af18\loch\f2 IF (A) != (data address) 
\par \tab \hich\af2\dbch\af18\loch\f2 THEN 
\par \tab \hich\af2\dbch\af18\loch\f2    (PC) <- (PC)\hich\af2\dbch\af18\loch\f2  + relative offset
\par \tab \hich\af2\dbch\af18\loch\f2 IF (A) < (data address)
\par \tab \hich\af2\dbch\af18\loch\f2 THEN 
\par \tab \hich\af2\dbch\af18\loch\f2   (C)<-l
\par \tab \hich\af2\dbch\af18\loch\f2 ELSE
\par \tab \hich\af2\dbch\af18\loch\f2   (C)<-0
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 
The accumulator contents are compared with the specified data address, and control is shifted to a relative jump address if the compared data is not equal. If the compared data is equal, control is shifted to the next address following this instruction. T
\hich\af2\dbch\af18\loch\f2 h\hich\af2\dbch\af18\loch\f2 e carry flag is set to 1 if the specified data address contents are greater than the accumulator contents, but is set to 0 if otherwise.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
CJNE Rr,#data,code address    (Compare immediate data to register, jump if not equal)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1011 1 r2 rl\hich\af2\dbch\af18\loch\f2  r0
\par \hich\af2\dbch\af18\loch\f2   \tab I7 I6 I5 I4 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2   \tab R7 R6 R5 R4 R3 R2 R1 R0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+3
\par \tab \hich\af2\dbch\af18\loch\f2 IF (Rr) != #data        \tab r = 0 or 7 
\par \tab \hich\af2\dbch\af18\loch\f2 THEN 
\par \tab \hich\af2\dbch\af18\loch\f2   (PC) <- (PC) + relative offset
\par \tab \hich\af2\dbch\af18\loch\f2 IF(Rr) < #data \tab \tab r=0 or 7
\par \tab \hich\af2\dbch\af18\loch\f2 THEN 
\par \tab \hich\af2\dbch\af18\loch\f2   (C)<-l
\par \tab \hich\af2\dbch\af18\loch\f2 ELSE
\par \tab \hich\af2\dbch\af18\loch\f2   (C)<-0
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number cf cycle\hich\af2\dbch\af18\loch\f2 s:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab ?\tab 
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The register r contents are compared with an immediate data value, and control is shifted to a relative jump address if the compared data is not equal. If the compared data is equal, control is \hich\af2\dbch\af18\loch\f2 
shifted to the next address following this instruction. The carry flag is set to 1   if the  immediate data value  is  greater than the register r contents, but is set to 0 if otherwise.
\par 
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 clr_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 CLR A      (Clear accumulator)

\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 
\hich\af2\dbch\af18\loch\f2 1110 0100
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <-0
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator is cleared to 0. The flag is also updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 CLR C    (Clear carry flag)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code\hich\af2\dbch\af18\loch\f2 :
\tab 1100 0011\tab 
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (C)<-0
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab 0
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The carry flag is cleared to 0.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 CLR bit address   (Clear bit)

\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1100 0010
\par \hich\af2\dbch\af18\loch\f2   \tab b7 b6 b5 b4 b3 b2 b1 b0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab \hich\af2\dbch\af18\loch\f2 (bit address) <-0
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The specified bit address content is cleared to 0.
\par 
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 cpl_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 CPL A     (Complement accumulator)

\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1111 0100
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <- /(A)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Numb\hich\af2\dbch\af18\loch\f2 er of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator data 0 is set to 1, and 1 is set to 0.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 CPL C     (Complement carry flag) 

\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1011 0011
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (C)<-  /(C)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (\hich\af2\dbch\af18\loch\f2 PSW)\tab ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The carry flag is set to 1 if 0, and set to 0 if 1.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
CPL bit address     (Complement bit)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1011 0010
\par \tab \hich\af2\dbch\af18\loch\f2 b7 b6 b5 b4 b3 b2 bl b0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (bit address) <- /(bit address)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab \hich\af2\dbch\af18\loch\f2 No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The specified bit address content is set to 1 if 0, and set to 0 if 1.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 
\par \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote \pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {
\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0  da_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
DA A     (Decimal adjust accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1101 0100
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 IF (AC) =1 or (ACC0~3) >= 10
\par \hich\af2\dbch\af18\loch\f2   \tab THEN 
\par \hich\af2\dbch\af18\loch\f2  \tab    ACC<-ACC + 6
\par \hich\af2\dbch\af18\loch\f2   \tab IF (C)=1 or (ACC4~7\hich\af2\dbch\af18\loch\f2 ) >= 10
\par \hich\af2\dbch\af18\loch\f2  \tab THEN
\par \tab \hich\af2\dbch\af18\loch\f2    (C)<-1
\par \hich\af2\dbch\af18\loch\f2  \tab    ACC <- ACC+60H 
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab ?                           ?
\par \hich\af2\dbch\af18\loch\f2 Description: 
\par \tab \hich\af2\dbch\af18\loch\f2 
The arithmetic operation result located in the accumulator following an addition between two 2-digit decimal numbers is converted to a normal decimal number. When the contents of accumulator bits 0 thru 3 (low nibble) are greater than 9, or when the auxil
\hich\af2\dbch\af18\loch\f2 i\hich\af2\dbch\af18\loch\f2 
ary carry (AC) is 1, 6 is added to accumulator bit 0 thru 3. And if the contents of accumulator bits 4 thru 7 (high nibble) exceed 9, or if the result obtained by adding a carry from the lower order digits after compensation is greater than 9, or if the c
\hich\af2\dbch\af18\loch\f2 a\hich\af2\dbch\af18\loch\f2 rry flag is 1, 6 is added to the data in accumulator bits 4 thru 7. The flag is also updated.
\par 
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 dec_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
DEC @Rr         (Decrement indirect address)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0001 011 r
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab ((Rr))<-((Rr))-1  r=O or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab \hich\af2\dbch\af18\loch\f2 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The contents of the data memory location addressed by the register r contents are decremented by 1.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 DEC A     (Decrement accumulator)

\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0001 0100
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<-(A)-1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flag\hich\af2\dbch\af18\loch\f2 s:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator contents are decremented by 1, and the flag is updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 DEC Rr    (Decrement register)

\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0001 1 r2 r1 r0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (Rr)<-(Rr)-1   r=0~7
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The register r contents are decremented by 1.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
DEC data address      (Decrement memory)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0001 0101
\par \hich\af2\dbch\af18\loch\f2    \tab a7 a6 a5 a4 a3 a2 a1 a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (data address) <- (data address) - 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The specified data address contents are decremented by 1.
\par 
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 div_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
DIV AB      (Divide accumulator by B) 
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1000 0100
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) quotient, (B) remainder <- (A)/(B)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 4
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW) \tab ?                   ?       ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator contents are divided by the contents of arithmetic operation register (B). The two data values are handled as intege\hich\af2\dbch\af18\loch\f2 
rs without sign. The quotient is placed in the accumulator, and the remainder in the arithmetic operation register (B). The carry flag is always cleared, and the overflow flag (OV) is set to 1 if a division by 0 is executed. This flag is cleared in all ot
\hich\af2\dbch\af18\loch\f2 h\hich\af2\dbch\af18\loch\f2 er cases. In case of division by 0, the contents of the accumulator and the arithmetic operation register (B) remain unchanged.
\par 
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 djnz_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
DJNZ Rr,Code address    (Decrement register, and jump if not zero)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1101 1 r2 rl r0
\par \hich\af2\dbch\af18\loch\f2   \tab R7 R6 R5\hich\af2\dbch\af18\loch\f2  R4 R3 R2 R1 R0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+ 2
\par \tab \hich\af2\dbch\af18\loch\f2 (Rr)<-(Rr)-1 \tab r=0~7
\par \hich\af2\dbch\af18\loch\f2  \tab IF (Rr) != 0 
\par \hich\af2\dbch\af18\loch\f2  \tab THEN 
\par \hich\af2\dbch\af18\loch\f2  \tab    (PC) <- (PC) + relative offset
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The register r contents are decremented by 1.Control is shifted to a r\hich\af2\dbch\af18\loch\f2 
elative jump address if the register r contents are not 0 as a result of the decrement. Control is shifted to the next address following this instruction if the result is 0.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
DJNZ data address,Code address  (Decrement memory, and jump if not zero)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1101 0101
\par \hich\af2\dbch\af18\loch\f2   \tab a7 a6 a5 a4 a3 a2 al a0
\par \hich\af2\dbch\af18\loch\f2   \tab R7 R6 R5 R4 R3 R2 R1 R0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+3
\par \hich\af2\dbch\af18\loch\f2   \tab (data address) <- (data address) -1
\par \hich\af2\dbch\af18\loch\f2   \tab IF (data address) != 0 
\par \hich\af2\dbch\af18\loch\f2  \tab THEN 
\par \hich\af2\dbch\af18\loch\f2  \tab     (PC) <- (PC) + relative offset
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab \hich\af2\dbch\af18\loch\f2 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 
The specified data address contents are decremented by 1. Control is shifted to a relative jump address if the data address contents are not 0 as a result of the decrement. Control is shifted to the next address following this ins
\hich\af2\dbch\af18\loch\f2 truction if the result is 0.
\par 
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 inc_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
INC @Rr    (Increment indirect address)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0000 011 r
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab ((Rr))<-((Rr))+1  r=0 or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The contents of the data memory location ad\hich\af2\dbch\af18\loch\f2 dressed by the register r contents are incremented by 1.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 INC A    (Increment accumulator)

\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0000 0100
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<-(A)+1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator contents are incremented by 1, and the flag is updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
INC DPTR    (Increment data pointer)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1010 0011
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (DPTR)<- (DPTR)+1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 16-bit cont\hich\af2\dbch\af18\loch\f2 ents of data pointer (DPH/DPL) are incremented by 1.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 INC Rr     (Increment register)

\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0000 1 r2 r1 r0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (Rr)<-(Rr)+1  r=0~7
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The register r contents are incremented by 1.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
INC data address     (Increment memory)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0000 0101
\par \hich\af2\dbch\af18\loch\f2   \tab A7 a6 a5 a4 a3 a2 al a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (data address) <- (data address) +1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 Th\hich\af2\dbch\af18\loch\f2 e specified data address contents are incremented by 1.
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 
\par \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote \pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {
\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0  jb_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
JB bit address,Code address         (Jump if bit is set)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0010 0000
\par \hich\af2\dbch\af18\loch\f2  \tab b7 b6 b5 b4 b3 b2 b1 b0
\par \hich\af2\dbch\af18\loch\f2  \tab R7 R6 R5 R4 R3 R2 R1 R0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+3
\par \hich\af2\dbch\af18\loch\f2  \tab IF (bit address) = 1 
\par \hich\af2\dbch\af18\loch\f2  \tab THEN 
\par \hich\af2\dbch\af18\loch\f2  \tab    (PC) <- (PC) + relative offset
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 Control is shifted to a relative jump address if the specified bit address content is 1.
\par \hich\af2\dbch\af18\loch\f2  \tab \hich\af2\dbch\af18\loch\f2 Control is shifted to the next address following this instruction if the content is 0.
\par 
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 jbc_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
JBC bit address,Code address      (Jump and clear if bit is set)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0001 0000
\par \hich\af2\dbch\af18\loch\f2   \tab b7 b6 b5 b4 b3 b2 b1 b0
\par \hich\af2\dbch\af18\loch\f2   \tab R7 R6 R5 R4 R3 R2 R1 R0
\par \hich\af2\dbch\af18\loch\f2 Operati\hich\af2\dbch\af18\loch\f2 on:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+3
\par \hich\af2\dbch\af18\loch\f2  \tab IF (bit address) = 1 
\par \hich\af2\dbch\af18\loch\f2  \tab THEN
\par \tab \hich\af2\dbch\af18\loch\f2   (bit address) <-0
\par \tab \hich\af2\dbch\af18\loch\f2   (PC) <- (PC) + relative offset
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description: 
\par \tab \hich\af2\dbch\af18\loch\f2 Control is shifted to a relative jump address if the specified bit address content is 1,\hich\af2\dbch\af18\loch\f2  and that bit is cleared to 0.
\par \hich\af2\dbch\af18\loch\f2  \tab Control is shifted to the next address following this instruction if the content is 0.
\par 
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 jc_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
JC Code address       (Jump if carry is set)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0100 0000
\par \hich\af2\dbch\af18\loch\f2   \tab R7 R6 R5 R4 R3 R2 R1 R0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+2
\par \hich\af2\dbch\af18\loch\f2  \tab IF (C)=l 
\par \hich\af2\dbch\af18\loch\f2  \tab THEN 
\par \hich\af2\dbch\af18\loch\f2  \tab    (PC) <- (PC) + relative offset
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 Control is shifted to a relative jump address if the carry flag is 1. Control is shifted to the next address following this \hich\af2\dbch\af18\loch\f2 instruction if the content is 0.
\par 
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 jmp_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
JMP @A+DPTR    (Jump to sum of accumulator and data pointer)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0111 0011
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (PC)<-(A)+(DPTR)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator contents are added to the data pointer contents, and the resulting sum is stored in the program counter.
\par 
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 jnb_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
JNB bit address,Code address         (Jump if bit is not set)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0011 0000
\par \hich\af2\dbch\af18\loch\f2  \tab b7 b6 b5 b4 b3 b2 b1 b0
\par \hich\af2\dbch\af18\loch\f2  \tab R7\hich\af2\dbch\af18\loch\f2  R6 R5 R4 R3 R2 R1 R0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC) + 3 
\par \hich\af2\dbch\af18\loch\f2  \tab IF (bit address) = 0 
\par \hich\af2\dbch\af18\loch\f2  \tab THEN 
\par \hich\af2\dbch\af18\loch\f2  \tab     (PC) <- (PC) + relative offset
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 Control is shifted to a relative jump address if the specified bit address\hich\af2\dbch\af18\loch\f2  content is 0, but shifted to the next address following this instruction if the content is 1.
\par 
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 jnc_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
JNC Code address     (Jump if carry is not set)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0101 0000
\par \hich\af2\dbch\af18\loch\f2  \tab R7 R6 R5 R4 R3 R2 R1 R0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+2
\par \hich\af2\dbch\af18\loch\f2  \tab IF (C)=0
\par \hich\af2\dbch\af18\loch\f2  \tab THEN
\par \hich\af2\dbch\af18\loch\f2  \tab \hich\af2\dbch\af18\loch\f2   (PC) <- (PC) + relative offset
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 Control is shifted to a relative jump address if the carry flag is 0. Control is shifted to the next address following this instruction if the content is 1.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 jnz_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
JNZ Code address      (Jump if accumulator is not 0)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0111 0000
\par \hich\af2\dbch\af18\loch\f2  \tab R7 R6 R5 R4 R3 R2 R1 R0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+2
\par \hich\af2\dbch\af18\loch\f2  \tab IF (A)!=0
\par \hich\af2\dbch\af18\loch\f2  \tab THEN 
\par \hich\af2\dbch\af18\loch\f2  \tab    (PC) <- (PC) + relative offset
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Descript\hich\af2\dbch\af18\loch\f2 ion:
\par \tab \hich\af2\dbch\af18\loch\f2 Control is shifted to a relative jump address if the accumulator contents are not 0. Control is shifted to the next address following this instruction if the contents are 0.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 jz_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
JZ Code address         (Jump if accumulator is 0)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0110 0000
\par \hich\af2\dbch\af18\loch\f2  \tab R7 R6 R5 R4 R3 R2 R1 R0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+ 2 
\par \hich\af2\dbch\af18\loch\f2  \tab IF (A)=0 
\par \hich\af2\dbch\af18\loch\f2  \tab THEN 
\par \hich\af2\dbch\af18\loch\f2  \tab   (PC) <- (PC) + relative offset
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 Control is shifted to a relative jump address if the acc\hich\af2\dbch\af18\loch\f2 umulator contents are 0. Control is shifted to the next address following this instruction if the contents are not 0.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 lcall_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
LCALL Code address         (Long call)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code: 
\par \tab \hich\af2\dbch\af18\loch\f2 0001 0010
\par \hich\af2\dbch\af18\loch\f2  \tab A15 A14 A13 A12 All A10 A9 A8
\par \hich\af2\dbch\af18\loch\f2  \tab A7 A6 A5 A4 A3 A2 Al \hich\af2\dbch\af18\loch\f2 A0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+3
\par \hich\af2\dbch\af18\loch\f2  \tab (SP)<- (SP)+1
\par \hich\af2\dbch\af18\loch\f2  \tab ((SP))<- (PC0~7)
\par \hich\af2\dbch\af18\loch\f2  \tab (SP)<-(SP)+1
\par \hich\af2\dbch\af18\loch\f2  \tab ((SP))<- (PC8~15)
\par \hich\af2\dbch\af18\loch\f2  \tab (PC0~15)<- A0~15
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The contents of the program counter (return address) are stored in the stack following an increment. Call address A0~l5 specified by operand are placed in the program counter PC0~15.
\par \hich\af2\dbch\af18\loch\f2  \tab This instruction is capable of call jump to anywhere within the entire \hich\af2\dbch\af18\loch\f2 range of 64K words.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 ljmp_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
LJMP Code address       (Long jump)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0000 0010
\par \hich\af2\dbch\af18\loch\f2  \tab A15 A14 A13 Al2 All Al0 A9 A8
\par \hich\af2\dbch\af18\loch\f2  \tab A7 A6 A5 A4 A3 A2 A1 A0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (PC0~15)<-A0~15
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 Jump addre\hich\af2\dbch\af18\loch\f2 sses A0~15 specified by operand are placed in the program counter PC0~15.
\par \hich\af2\dbch\af18\loch\f2  \tab This instruction is capable of jump to anywhere within the entire range of 64K words.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 mov_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV @Rr,#data      (Move immediate data to indirect address)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 01\hich\af2\dbch\af18\loch\f2 11 011 r
\par \hich\af2\dbch\af18\loch\f2  \tab I7 I6 I5 I4 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab ((Rr))<- #data  r = 0 or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 An 8-bit immediate data value is copied to the data memory location addressed by the register r contents.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV @Rr,A      (Move accumulator to indirect address)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1111 011 r
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab ((Rr))<- (A)   r=0 or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator contents are copied to the data memory location addressed b\hich\af2\dbch\af18\loch\f2 y the register r contents.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV @Rr,data address       (Move memory to indirect address)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1010 011 r
\par \hich\af2\dbch\af18\loch\f2  \tab A7 a6 a5 a4 a3 a2 al a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab ((Rr))<- (data address)    r = 0 or 1 
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description\hich\af2\dbch\af18\loch\f2 :
\par \tab \hich\af2\dbch\af18\loch\f2 The specified data address contents are copied to the data memory location addressed by the register r contents.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV A,#data    (Move immediate data to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0111 0100
\par \hich\af2\dbch\af18\loch\f2  \tab I7 I6 I5 I4 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <- #data
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 An 8-bit immediate data value is copied to the accumulator, and the flag is updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV A,@Rr    (Move indirect address to accumul\hich\af2\dbch\af22\loch\f2 ator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1110 011 r
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)-((Rr))   r=0 or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The data memory location contents addressed by the register r con\hich\af2\dbch\af18\loch\f2 tents are copied to the accumulator, and the flag is updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV A,Rr       (Move register to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1110 1 r2 r1 r0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<-(Rr)  r=0~7
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab \hich\af2\dbch\af18\loch\f2                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The register \hich\af2\dbch\af18\loch\f2 R\hich\af2\dbch\af18\loch\f2 r contents are copied to the accumulator, and the flag is updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV A,data address        (Move memory to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1110 0101
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 a1 a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <- (d\hich\af2\dbch\af18\loch\f2 ata address)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The specified data address contents are copied to the accumulator, and the flag is updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 MOV C,bit address        (
\hich\af2\dbch\af22\loch\f2 Move bit to carry flag)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1010 0010
\par \hich\af2\dbch\af18\loch\f2  \tab b7 b6 b5 b4 b3 b2 b1 b0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (C) <- (bit address)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The specified bit address content is copied to the\hich\af2\dbch\af18\loch\f2  carry flag.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV DPTR,#data        (Move immediate data to data pointer)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1001 0000
\par \hich\af2\dbch\af18\loch\f2  \tab I15 114 I13 I12 I11 I10 I9 I8
\par \hich\af2\dbch\af18\loch\f2  \tab I7 I6 I5 I4 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (DPTR) <- #data
\par \hich\af2\dbch\af18\loch\f2  \tab (DPH)<-I8~15
\par \hich\af2\dbch\af18\loch\f2  \tab (DPL)<-I0~7
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab \hich\af2\dbch\af18\loch\f2 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 A 16-bit immediate data value is copied to the data pointer (DPH / DPL).
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV Rr,#data          (Move immediate data to register)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0111 1 r2 r1 r0
\par \hich\af2\dbch\af18\loch\f2  \tab I7 I6 I5 I4 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (Rr) <- #data   r=0~7
\par \hich\af2\dbch\af18\loch\f2 Numbe\hich\af2\dbch\af18\loch\f2 r of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 An 8-bit immediate data value is copied to the register
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV Rr,A         (Move accumulator to register)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1111 1 r2 r1 r0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (Rr)<- (A)  r=0~7
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator contents are copied to the register r.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV Rr,data address       (Move memory to register)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1010 1 r2 rl r0
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 al a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (Rr) <- (data address)   r=0~7
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The specified data address contents are copied to the register r.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV bit address,C         (Move carry flag to bit)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1001 0010
\par \hich\af2\dbch\af18\loch\f2  \tab b7 b6 b5 b4 b3 b2 b1 b0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (bit add\hich\af2\dbch\af18\loch\f2 ress) <- (C)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The carry flag content is copied to the specified bit address.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV data address,#data       (Move immediate data to memory)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0111 0101
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 al a0
\par \hich\af2\dbch\af18\loch\f2  \tab I7 I6 I5 I4 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (data address) <- #data
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 An 8-bit immediate data value is copied to the specified data address.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV data address,@Rr      (Move indirect address to memory\hich\af2\dbch\af22\loch\f2 )
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \hich\af2\dbch\af18\loch\f2  \tab 1000 011 r
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 al a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (data address)<-((Rr))   r =0 or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The data memory location contents addressed by the register r contents are copied to the\hich\af2\dbch\af18\loch\f2  specified data address.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV data address,A            (Move accumulator to memory)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1111 0101
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 a1 a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (data address) <- (A)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator contents are copied to the specified data address.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV data address,Rr         (Move register to memory)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1000 1 r2 r1 r0
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 al a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (data address) <- (Rr)   r=0~7
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of c\hich\af2\dbch\af18\loch\f2 ycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description: 
\par \tab \hich\af2\dbch\af18\loch\f2 The register r contents are copied to the specified data address.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOV data address 1,data address 2        (Move memory to memory)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1000 0101
\par \hich\af2\dbch\af18\loch\f2  \tab a27 a26 a25 a24 a23 a22 a21 a20
\par \hich\af2\dbch\af18\loch\f2  \tab \hich\af2\dbch\af18\loch\f2 a17 a16 a15 a14 a13 a12 a11 a10
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (data address 1) <- (data address 2)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The source data address (data address 2) contents are copied to the destination data address (data address 1)
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 movc_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOVC A,@A+DPTR    (Move code memory offset from data pointer to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1001 0011
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<-((A) + (DPTR))
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 
The data pointer contents are added to the accumulator contents, and after temporary storage of the sum in program counter, the ROM data contents specified by the program counter are stored in the accumulator. The program counter contents are
\hich\af2\dbch\af18\loch\f2  then restored to former contents, and the flag is also updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOVC A,@A+PC    (Move code memory offset from Program counter to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1000 0011
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+1
\par \hich\af2\dbch\af18\loch\f2  \tab (A)<-((A)+(PC))
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The program counter contents following an increment are added to the accumulator contents, and after temporary storage of the sum in the program counter, the ROM data conte\hich\af2\dbch\af18\loch\f2 
nts specified by the program counter are stored in the accumulator. The program counter contents are then restored to former contents, and the flag is also updated.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 movx_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOVX @DPTR,A   (Move accumulator to external memory addressed by data pointer)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1111 0000
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab ((DPTR))<- (A)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \hich\af2\dbch\af18\loch\f2  \tab The accumulator contents are stored to external data memory (RAM) addressed by the data pointer contents.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 MOVX @Rr,A   (Move accumulato
\hich\af2\dbch\af22\loch\f2 r to external memory addressed by register)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1111 001 r
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab ((Rr))<- (A)   r=0 or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator contents are stored to external data memory (RAM) addressed by the re\hich\af2\dbch\af18\loch\f2 gister r contents.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOVX A,@DPTR (Move external memory addressed by data pointer to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1110 0000
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<- ((DPTR))
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab \hich\af2\dbch\af18\loch\f2                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \hich\af2\dbch\af18\loch\f2  \tab External data memory (RAM) contents addressed by the data pointer are stored to the accumulator, and the flag is updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MOVX A,@Rr       (Move external memory addressed by register to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instructio\hich\af2\dbch\af18\loch\f2 n code:
\tab 1110 001 r
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<-((Rr))   r=0 or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 External data memory (RAM) contents addressed by the register r contents are stor\hich\af2\dbch\af18\loch\f2 ed to the accumulator, and the flag is updated.
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 
\par \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote \pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {
\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0  mul_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
MUL AB        (Multiply accumulator by B)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1010 0100
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (B),(A) <- (A)*(B)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 4
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab \hich\af2\dbch\af18\loch\f2 ?                   ?       ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator contents are multiplied by the arithmetic operation register (B) contents. The operand is always handled as an integer without sign. The lower order byte of the result is stored in the accumulator
\hich\af2\dbch\af18\loch\f2 , and the higher order byte is stored in the arithmetic operation register (B). The carry flag is always cleared. The overflow flag is set to 1 if the product is greater than 00FFH, and to 0 in all other cases.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 nop_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 NOP      (No operation)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instructi\hich\af2\dbch\af18\loch\f2 on code:
\tab 0000 0000
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (PC)<-(PC)+1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The program counter is incremented by 1 without any other change in the CPU. Control is shifted to the next instruction.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 orl_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 ORL A,#data      
\hich\af2\dbch\af22\loch\f2 (Logical OR immediate data to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code: 
\par \tab \hich\af2\dbch\af18\loch\f2 0100 0100
\par \hich\af2\dbch\af18\loch\f2  \tab I7 I6 I5 I4 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <- (A) OR #data
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The\hich\af2\dbch\af18\loch\f2  logical OR between an 8-bit immediate data value and the accumulator contents is determined. The result is stored in the accumulator and the flag is also updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ORL A,@Rr        (Logical OR indirect address to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0100 011 r
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<-(A) OR ((Rr))   r=0 or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The logical OR between the accumulator contents and the data memory location contents addre\hich\af2\dbch\af18\loch\f2 
ssed by the register r contents is determined. The result is stored in the accumulator and the flag is also updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ORL A,Rr       (Logical OR register to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0100 1 r2 r1 r0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<-(A) OR (Rr)   r=0~7
\par \hich\af2\dbch\af18\loch\f2 Number of bytes\hich\af2\dbch\af18\loch\f2 :\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The logical OR between the accumulator contents and the register r contents is determined. The result is stored in the accumulator and the flag is a\hich\af2\dbch\af18\loch\f2 lso updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ORL A,data address    (Logical OR memory to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0100 0101
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 a1 a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <- (A) OR (data address)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab \hich\af2\dbch\af18\loch\f2                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The logical OR between the accumulator contents and the specified data address contents is determined. The result is stored in the accumulator and the flag is also updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ORL C,bit address     (Logical OR bit\hich\af2\dbch\af22\loch\f2  to carry flag)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0111 0010
\par \hich\af2\dbch\af18\loch\f2  \tab b7 b6 b5 b4 b3 b2 b1 b0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (C) <- (C) OR (bit address)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The logical OR between the carry flag and the speci\hich\af2\dbch\af18\loch\f2 fied bit address content is determined. The result is stored in the carry flag.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ORL C,/bit address        (Logical OR complement of bit to carry flag)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1010 0000
\par \hich\af2\dbch\af18\loch\f2  \tab b7 b6 b5 b4 b3 b2 b1 b0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (C) <- (C) OR /(bit address)
\par \hich\af2\dbch\af18\loch\f2 Number o\hich\af2\dbch\af18\loch\f2 f bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The logical OR between the carry flag and the complement of specified bit address content is determined. The result is stored in the carry flag.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ORL data address,#data       (Logical OR immediate data to memory)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0100 0011
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 al a0
\par \hich\af2\dbch\af18\loch\f2  \tab I7 I6 I5 I4 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (data address) -- (data address) OR #data
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Descri\hich\af2\dbch\af18\loch\f2 ption:
\par \tab \hich\af2\dbch\af18\loch\f2 The logical OR between an 8-bit immediate data value and the specified data address contents is determined. The result is stored in the specified data address.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
ORL data address,A    (Logical OR accumulator to memory)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0100 0010
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 al a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (data address) <- (data address) OR (A)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The logical OR between the accumulator and the specified data address contents is determined. The result is stored i\hich\af2\dbch\af18\loch\f2 n the specified data address.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 
\par 
\par \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote \pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {
\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0  pop_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
POP data address     (Pop stack to memory)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1101 0000
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 al a0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (data address) <- ((SP))
\par \hich\af2\dbch\af18\loch\f2  \tab (SP)<- (SP)-1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 Stack contents addressed by the stack pointer are transferred to the specified data address, and the stack pointer is decremented by 1.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 push_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
PUSH data address     (Push memory onto stack)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1100 0000
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 al a0
\par \hich\af2\dbch\af18\loch\f2 Ope\hich\af2\dbch\af18\loch\f2 ration:\tab (SP)<-(SP)+1
\par \hich\af2\dbch\af18\loch\f2   \tab ((SP)) <- (data address)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The stack pointer is incremented by 1,and the specified data address contents are stored in the stack addressed by the stack pointer.
\par }\pard\plain \s17\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1028\kerning2\loch\af22\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 ret_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
RET      (Return from subroutine, non interrupt)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0010 0010
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC8~15)<-((SP))
\par \hich\af2\dbch\af18\loch\f2  \tab (SP)<-(SP)-1
\par \hich\af2\dbch\af18\loch\f2  \tab (PC0~7)<- ((SP))
\par \hich\af2\dbch\af18\loch\f2  \tab (SP)<-(SP)-1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The stack contents addressed \hich\af2\dbch\af18\loch\f2 
by the stack pointer are stored to upper order 8 thru 15 of the program counter, and the stack pointer is decremented by 1. Then the stack contents addressed by the updated stack pointer are stored in the lower order 0 thru 7 of the program counter, again
\hich\af2\dbch\af18\loch\f2  \hich\af2\dbch\af18\loch\f2 decrementing the stack pointer by 1.The program counter is updated with the stack contents, and control is shifted to the address after updating.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 reti_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
RETI      (Return from interrupt routine)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0011 0010
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC8~15)<-((SP)\hich\af2\dbch\af18\loch\f2 )
\par \hich\af2\dbch\af18\loch\f2  \tab (SP)<-(SP)-1
\par \hich\af2\dbch\af18\loch\f2  \tab (PC0~7)<-((SP))
\par \hich\af2\dbch\af18\loch\f2  \tab (SP)<- (SP)-1 
\par \hich\af2\dbch\af18\loch\f2  \tab *INTERRUPT ENABLE
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 This return instruction functions as an interrupt processing routine terminating instruction\hich\af2\dbch\af18\loch\f2 
. If a priority interrupt is generated while a non-priority interrupt processing routine is being executed, the CPU starts to process the priority interrupt. And once processing of this interrupt is started, no other interrupt can be processed until the R
\hich\af2\dbch\af18\loch\f2 E\hich\af2\dbch\af18\loch\f2 TI instruction is executed.
\par 
\par \hich\af2\dbch\af18\loch\f2  \tab 
The stack contents addressed by the stack pointer are stored to upper order 8 thru 15 of the program counter, and the stack pointer is decremented by 1. Then the stack contents addressed by the updated stack pointer are store\hich\af2\dbch\af18\loch\f2 
d in the lower order 0 thru 7 of the program counter, again decrementing the stack pointer by 1.The program counter is updated with the stack contents, and control is shifted to the address after updating. If a new interrupt is generated, the CPU starts t
\hich\af2\dbch\af18\loch\f2 o\hich\af2\dbch\af18\loch\f2  process the interrupt.
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 rl_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
RL A     (Rotate accumulator left) 
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0010 0011
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab ACC left rotate 1 bit
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 All accumulator bits are shifted by one bit to the left. The\hich\af2\dbch\af18\loch\f2  MSB (bit 7) is shifted to the LSB bit position (bit 0).
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 rlc_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
RLC A     (Rotate accumulator and carry flag left)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0011 0011
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab C,ACC left rotate 1 bit
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab ?                           ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator and the carry flag are connected, and all bits are shifted by one bit to the left. The carry flag is shifted to the accumulator LSB (bit 0), and the accumulator MSB (bit 7) is shifted to th
\hich\af2\dbch\af18\loch\f2 e carry flag.
\par }\pard\plain \s17\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1028\kerning2\loch\af22\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 rr_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
RR A     (Rotate accumulator right)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0000 0011
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab ACC rotate right 1 bit
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 All accumu\hich\af2\dbch\af18\loch\f2 lator bits are shifted by one bit to the right. The LSB (bit 0) is shifted to the MSB bit position (bit 7).
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 rrc_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
RRC A    (Rotate accumulator and carry flag right)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0001 0011
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab C,ACC rotate right 1 bit
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Nu\hich\af2\dbch\af18\loch\f2 mber of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab ?                           ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator and the carry flag are connected, and all bits are shifted by one bit to the right. The carry flag is shifted to the accumulator MSB (bit \hich\af2\dbch\af18\loch\f2 
7), and the accumulator LSB (bit 0) is shifted to the carry flag.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 setb_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 SETB C      (Set carry flag)

\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1101 0011
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (C)<-l
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab 1
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The c\hich\af2\dbch\af18\loch\f2 arry flag is set to 1.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 SETB bit address    (Set bit)

\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1101 0010
\par \hich\af2\dbch\af18\loch\f2  \tab b7 b6 b5 b4 b3 b2 bl b0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (bit address) <- 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The specified bit address content is set to 1.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0  sj
\hich\af0\dbch\af18\loch\f0 mp_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 SJMP code address     (Short jump)

\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1000 0000
\par \hich\af2\dbch\af18\loch\f2  \tab R7 R6 R5 R4 R3 R2 R1 R0
\par \hich\af2\dbch\af18\loch\f2 Operation:
\par \tab \hich\af2\dbch\af18\loch\f2 (PC)<-(PC)+2
\par \hich\af2\dbch\af18\loch\f2  \tab (PC)<- (PC) + relative offset
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 Relative offset jump data is added/subt\hich\af2\dbch\af18\loch\f2 
racted to/from the program counter contents following an increment. The program counter contents are updated, and control is then shifted to the updated address. The range in which relative jumps can be executed by this instruction is +127 to -128 in resp
\hich\af2\dbch\af18\loch\f2 e\hich\af2\dbch\af18\loch\f2 cted to the incremented program counter contents. There is no page field restrictions.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 subb_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
SUBB A,#data    (Subtract immediate data from accumulator with borrow)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1001 0100
\par \hich\af2\dbch\af18\loch\f2  \tab I7 I6 I5 I4 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <- (A) - ((C\hich\af2\dbch\af18\loch\f2 ) + #data)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab ?  ?                ?      ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The carry flag contents and an immediate data value are subtracted from the accumulator contents. The result is placed in t\hich\af2\dbch\af18\loch\f2 he accumulator, and the flags are updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
SUBB A,@Rr    (Subtract indirect address from accumulator with borrow)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1001 011 r
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <- (A) -((C)+((Rr)))   r=0 or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 O\hich\af2\dbch\af18\loch\f2 V Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab ?  ?               ?      ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The carry flag contents, and the data memory location contents addressed by the register r contents are subtracted from the accumulator contents. The result is placed in the accumulator, and the flag
\hich\af2\dbch\af18\loch\f2 s are updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
SUBB A,Rr  (Subtract register from accumulator with borrow)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1001 1 r2 r1 r0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <- (A)-((C)+(Rr))
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab ?  ?                ?       ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The carry flag contents and the register r contents are subtracted from the accumulator contents. The result is  placed  in  the  accumulator,  and  the  flags  are updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
SUBB A,data address   (Subtract memory from accumulator with borro\hich\af2\dbch\af22\loch\f2 w)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1001 0101
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 a1 a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <- (A) - ((C) + (data address))
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab ?  ?                ?      ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The carry flag contents and th\hich\af2\dbch\af18\loch\f2 e specified data address contents are subtracted from the accumulator contents. The result is placed in the accumulator, and the flags are updated.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 swap_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
SWAP A   (Exchange nibble in accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1100 0100
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A4~7)<->(A0~3\hich\af2\dbch\af18\loch\f2 )
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The contents of the four higher order bits (4 thru 7) of the accumulator are exchanged with the contents of the four lower order bits (0 thru 3).
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 xch_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
XCH A,@Rr    (Exchange indirect address with accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1100 011 r
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<->((Rr))   r=0 or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumula\hich\af2\dbch\af18\loch\f2 tor contents are exchanged with the data memory location contents addressed by the register r contents, and the flag is updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
XCH A,Rr   (Exchange register with accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1100 1 r2 r1 r0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<->(Rr)  r=0~7
\par \hich\af2\dbch\af18\loch\f2 Number of byte\hich\af2\dbch\af18\loch\f2 s:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator contents are exchanged with the register r contents, and the flag is updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
XCH A,data address   (Exchange memory with accumulat\hich\af2\dbch\af22\loch\f2 or)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 1100 0101
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 a1 a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <-> (data address)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The accumulator contents are exchanged with the specified data address contents, and the flag is updated.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 xchd_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
XCHD A,@Rr     (Exchange low nibbles of indirect address with accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 1101 011 r
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A0~3)= ((Rr)0~3) r=0 \hich\af2\dbch\af18\loch\f2 or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2 (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The lower order bits (0 thru 3) of the accumulator contents are exchanged with the contents of the lower order bits (0 thru 3) of\hich\af2\dbch\af18\loch\f2 
 the data memory location addressed by register r contents. The flag is updated.
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
 xrl_id}}}{\fs20 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
XRL A,#data      (Logical exclusive OR immediate data to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0110 0100
\par \hich\af2\dbch\af18\loch\f2  \tab I7 I6 I5 I4 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <- (A) XOR #data
\par \hich\af2\dbch\af18\loch\f2 Number\hich\af2\dbch\af18\loch\f2  of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 Th\hich\af2\dbch\af18\loch\f2 e exclusive OR operation is executed between an immediate data value and the accumulator contents. The result is placed in the accumulator, and the flag is updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
XRL A,@Rr     (Logical exclusive OR indirect address to accumulator) 
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0
\hich\af2\dbch\af18\loch\f2 110 011 r
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <-(A) XOR ((Rr))   r=0 or 1
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The exclusive OR operation is executed between the accumulator contents and the \hich\af2\dbch\af18\loch\f2 
data memory location contents addressed by the register r contents. The result is placed in the accumulator, and the flag is updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
XRL A,Rr    (Logical exclusive OR register to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:\tab 0110 1 r2 r1 r0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A)<-(A) XOR (Rr\hich\af2\dbch\af18\loch\f2 )  r=0~7
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The exclusive OR between the accumulator contents and the register r contents is determined. The result is stored in the acc\hich\af2\dbch\af18\loch\f2 umulator and the flag is also updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
XRL A,data address     (Logical exclusive OR memory to accumulator)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0110 0101
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 a1 a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (A) <- (A) XOR (data address)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab \hich\af2\dbch\af18\loch\f2 C  AC F0 RS1 RS0 OV Fl  P
\par \hich\af2\dbch\af18\loch\f2  (PSW)\tab                             ?
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The exclusive OR between the accumulator contents and the specified data address contents is determined. The result is stored in the accumulator and the flag is updated.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 XRL dat
\hich\af2\dbch\af22\loch\f2 a address,#data     (Logical exclusive OR immediate data to memory)
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0110 0011
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 al a0
\par \hich\af2\dbch\af18\loch\f2  \tab I7 I6 I5 I4 I3 I2 I1 I0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (data address) <- (data address) XOR #data
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 3
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Desc\hich\af2\dbch\af18\loch\f2 ription:
\par \tab \hich\af2\dbch\af18\loch\f2 The exclusive OR between an immediate data value and the specified data address contents is determined. The result is stored in the specified data address.
\par 
\par 
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\cf6\lang1033\langfe1028\kerning2\loch\af2\hich\af2\dbch\af22\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af22\loch\f2 
XRL data address,A    (Logical exclusive OR accumulator to memory) 
\par }\pard\plain \s19\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af2\hich\af2\dbch\af18\cgrid\langnp1033\langfenp1028 {\hich\af2\dbch\af18\loch\f2 Instruction code:
\par \tab \hich\af2\dbch\af18\loch\f2 0\hich\af2\dbch\af18\loch\f2 110 0010
\par \hich\af2\dbch\af18\loch\f2  \tab a7 a6 a5 a4 a3 a2 a1 a0
\par \hich\af2\dbch\af18\loch\f2 Operation:\tab (data address) <- (data address) XOR (A)
\par \hich\af2\dbch\af18\loch\f2 Number of bytes:\tab 2
\par \hich\af2\dbch\af18\loch\f2 Number of cycles:\tab 1
\par \hich\af2\dbch\af18\loch\f2 Flags:\tab No
\par \hich\af2\dbch\af18\loch\f2 Description:
\par \tab \hich\af2\dbch\af18\loch\f2 The exclus\hich\af2\dbch\af18\loch\f2 ive OR between the accumulator and the specified data address contents is determined. The result is stored in the specified data address.
\par 
\par 
\par }\pard\plain \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs24\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\fs20 \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote 
\pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0 
option_id }}}{\b\fs40\cf6 \hich\af0\dbch\af18\loch\f0 Welcome to SIMLAB-8051}{\fs20 
\par 
\par \hich\af0\dbch\af18\loch\f0 Parameter Setting
\par }\pard \ql \li480\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin480\itap0 {\fs20 \hich\af0\dbch\af18\loch\f0 Assembler
\par }\pard \ql \li960\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin960\itap0 {\fs20 \hich\af0\dbch\af18\loch\f0 SIMLAB-8051 has an Internal Assembler, Your can us\hich\af0\dbch\af18\loch\f0 
e popular assembler ,such as Franklin Assembler, 2500AD Assembler.
\par \hich\af0\dbch\af18\loch\f0 if you want to use Franklin Assembler :
\par }\pard \ql \fi480\li960\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin960\itap0\culi400 {\fs20 \hich\af0\dbch\af18\loch\f0 Franklin Assembler must build at sub-directory  C:\\
C51, and select Franklin Assembler Option in the Parameter Setting of SIMLAB-8051 ,then when you o\hich\af0\dbch\af18\loch\f0 pen assembly  program ,you can assemble it by popup menu
\par }\pard \ql \li960\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin960\itap0 {\fs20 \hich\af0\dbch\af18\loch\f0 if you want to use 2500AD Assembler :
\par }\pard \ql \fi480\li960\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin960\itap0\culi400 {\fs20 \hich\af0\dbch\af18\loch\f0 2500AD Assembler  must build at sub-directory  C:\\
X8051, and select 2500AD Assembler Option in the Parameter Setting of SIMLAB-8051 ,then when you open assembly \hich\af0\dbch\af18\loch\f0  program ,you can assemble it by popup menu
\par }\pard \ql \fi400\li960\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin960\itap0\cufi200\culi400 {\fs20 
\par }\pard \ql \li480\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin480\itap0 {\fs20 \hich\af0\dbch\af18\loch\f0 C Compiler
\par }\pard \ql \li960\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin960\itap0 {\fs20 \hich\af0\dbch\af18\loch\f0 SIMLAB-8051 has none Internal  C Compiler, but  Your can use popular C Compiler ,such as Franklin C Compiler.
\par \hich\af0\dbch\af18\loch\f0 if you want to use Franklin C Compiler :
\par }\pard \ql \fi480\li960\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin960\itap0 {\fs20 \hich\af0\dbch\af18\loch\f0 Franklin C Compiler must build at sub-directory  \hich\af0\dbch\af18\loch\f0 C:\\C51, and select Franklin 
\par }\pard \ql \fi-60\li960\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin960\itap0\cufi-30\culi375 {\fs20 \hich\af0\dbch\af18\loch\f0 
C Compiler Option in the Parameter Setting of SIMLAB-8051,then when you open C program ,you can compiler it by popup menu
\par }\pard \ql \li480\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin480\itap0 {\fs20 \{\hich\af0\dbch\af18\loch\f0 bml setting.bmp\}
\par }\pard \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\fs20 
\par \hich\af0\dbch\af18\loch\f0 How to make a LAB 
\par }\pard \ql \li480\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin480\itap0 {\fs20 \hich\af0\dbch\af18\loch\f0 select one LAB from Fundamental LABs or Functional Project LABs.
\par \{\hich\af0\dbch\af18\loch\f0 bml sellab.bmp\}
\par 
\par \hich\af0\dbch\af18\loch\f0 select example tab from LAB window, first click the left key of the mouse at any filename of example, then click the right key of the mouse to occur a pop-up menu, then select Open File at Cursor to open example program.
\par \{\hich\af0\dbch\af18\loch\f0 bml openfile.bmp\}
\par 
\par \hich\af0\dbch\af18\loch\f0 click the right key of the mouse at source program window, then select
\par }\pard \ql \li960\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin960\itap0 {\fs20 \hich\af0\dbch\af18\loch\f0 Save ,Assembler and Load Program}{\fs20\ul \hich\af0\dbch\af18\loch\f0 (Real Delay Time)}{\v\fs20 \hich\af0\dbch\af18\loch\f0 
realdelay_id}{\fs20 
\par \hich\af0\dbch\af18\loch\f0 Save ,Assembler and Load Program}{\fs20\ul \hich\af0\dbch\af18\loch\f0 (Speed up Delay Time)}{\v\fs20 \hich\af0\dbch\af18\loch\f0 simdelay_id
\par }\pard \ql \li480\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin480\itap0 {\fs20 \{\hich\af0\dbch\af18\loch\f0 bml compiler.bmp\}
\par 
\par \hich\af0\dbch\af18\loch\f0 select Full Speed in Execution menu \hich\af0\dbch\af18\loch\f0 ,the watch the action in Block Diagram.
\par \{\hich\af0\dbch\af18\loch\f0 bml run.bmp\}
\par }\pard \ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 {\fs20 \page }{\cs16\f18\fs20\super \hich\af18\dbch\af18\loch\f18 #{\footnote \pard\plain \s15\ql \li0\ri0\sl360\slmult0
\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {\cs16\f18\super \hich\af18\dbch\af18\loch\f18 #}{\hich\af0\dbch\af18\loch\f0  realdelay_id}}}{\fs20 
\hich\af0\dbch\af18\loch\f0 use real delay subroutine, C program must include Delay.h, otherwise Assembler must include Delay.inc
\par \page }{\cs16\f18\fs20\super \hich\af18\dbch\af18\loch\f18 #{\footnote \pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {
\cs16\f18\super \hich\af18\dbch\af18\loch\f18 #}{\hich\af0\dbch\af18\loch\f0  simdelay_id}}}{\fs20 \hich\af0\dbch\af18\loch\f0  use simulation  delay subroutine, C program must include Delay.h ,\hich\af0\dbch\af18\loch\f0 
 otherwise Assembler must include Delay.inc
\par \page }{\cs16\fs20\super \hich\af0\dbch\af18\loch\f0 #{\footnote \pard\plain \s15\ql \li0\ri0\sl360\slmult0\nowidctlpar\aspalpha\aspnum\faroman\rin0\lin0\itap0 \fs20\lang1033\langfe1028\loch\af0\hich\af0\dbch\af18\cgrid\langnp1033\langfenp1028 {
\cs16\super \hich\af0\dbch\af18\loch\f0 #}{\hich\af0\dbch\af18\loch\f0  group_id}}}{\b\fs36\cf6 \hich\af0\dbch\af18\loch\f0 Working Group}{\fs20 
\par 
\par 
\par }}