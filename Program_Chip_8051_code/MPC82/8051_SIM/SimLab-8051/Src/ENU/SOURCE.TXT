
@{
BuildIn
{
REGEQU
REG
}
Franklin
{
REGEQU
EQU
}
2500AD
{
REGEQU
REG
}
@}


%{access1.a51
;
;   The methods to access internal data memory(address  at 0,8,40h,90h)
;
;
;   three methods to load from internal data memory 0 to ACC
	MOV	A,R0
	CLR	A

	MOV	A,00
	CLR	A

	MOV	R1,#00
	MOV	A,@R1

;   three methods to load from internal data memory 8 to ACC
	SETB	RS0
	MOV	A,R0
	CLR	RS0
	CLR	A

	MOV	A,08
	CLR	A

	MOV	R1,#08
	MOV	A,@R1
	CLR	A

;   two methods to load from internal data memory 40h to ACC

	MOV	A,40h
	CLR	A

	MOV	R1,#40h
	MOV	A,@R1
	CLR	A

;   only one  method to load from internal data memory 90h to ACC

	MOV	A,90h     ; error(access special function register)
	CLR	A

	MOV	R1,#90h
	MOV	A,@R1
	CLR	A

	END
%}


%{access2.a51
;
;   The methods to access bit data (address at 3)
;
;
	SETB	3
	CLR	3
	SETB	20h.3
	CLR	20h.3

	MOV	A,20h
	ORL	A,#008H
	MOV	20h,A

	MOV	A,20h
	ANL	A,#0F7h
	MOV	20h,A


	END
%}


%{adc1.a51
;
;   Read analog voltage from ADC0804(synchronize by delay method),
;       then display voltage on 8 pieces of LED
;
ADCRD	REGEQU	P1.0
ADCWR	REGEQU	P1.1

START:
	CLR	ADCWR
	SETB	ADCWR
	ACALL	DELAY150US
	CLR	ADCRD
	MOV	P2,P0
	SETB	ADCRD
	SJMP	START
DELAY150US:
	MOV	R1,#74
	DJNZ	R1,$
	RET
	END
%}


@1
%{adc1.c
//
//   Read analog voltage from ADC0804(synchronize by delay method),
//     then display voltage on 8 pieces of LED 
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit ADCRD=P1 ^0 ;
sbit ADCWR=P1 ^1 ;
void delay150us()
{
	int i=0 ;
	for(i=0 ; i < 18 ; i++) ;
}
main()
{
	for(;;){
	    // start ADC
	    ADCWR=0 ; ADCWR= 1 ;
	    delay150us() ;
	    ADCRD=0 ;
	    P2=P0 ;
	    ADCRD=1 ;
	}
}
%}


%{adc2.a51
;
;   Read analog voltage from ADC0804 (synchronize by polling method),
;     then display voltage on 8 pieces of LED
;
ADCRD	REGEQU	P1.0
ADCWR	REGEQU	P1.1
ADCINTR	REGEQU	P3.2

START:
	CLR	ADCWR
	SETB	ADCWR
	JB	ADCINTR,$
	CLR	ADCRD
	MOV	P2,P0
	SETB	ADCRD
	SJMP	START
	END
%}


@1
%{adc2.c
//
//   Read analog voltage from ADC0804 (synchronize by polling method),
//     then display voltage on 8 pieces of LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit ADCRD=P1 ^0 ;
sbit ADCWR=P1 ^1 ;
sbit ADCINTR=P3^2 ;
main()
{
	for(;;){
	    // start ADC
	    ADCWR=0 ; ADCWR= 1 ;
	    while(ADCINTR) ;
	    ADCRD=0 ;
	    P2=P0 ;
	    ADCRD=1 ;
	}
}
%}


%{adc3.a51
;
;   Read analog voltage from ADC0804 (synchronize by interrupt method),
;     then display voltage on 8 pieces of LED
;
ADCRD	REGEQU	P1.0
ADCWR	REGEQU	P1.1

	LJMP	START
	LJMP	EXTERNAL0
START:
	SETB	EA
	SETB	IT0
	SETB	EX0
; Start First ADC
	CLR	ADCWR
	SETB	ADCWR
	SJMP	$
EXTERNAL0:
	CLR	ADCRD
	MOV	P2,P0
	SETB	ADCRD
; Start Next ADC
	CLR	ADCWR
	SETB	ADCWR
	RETI
	END
%}


@1
%{adc3.c
//
//   Read analog voltage from ADC0804 (synchronize by interrupt method),
//     then display voltage on 8 pieces of LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit ADCRD=P1 ^0 ;
sbit ADCWR=P1 ^1 ;
main()
{
	EA=1 ;
	IT0=1 ; // detect negative edge trigger
	EX0=1 ; // active INT0
	// start first ADC
	ADCWR=0 ; ADCWR= 1 ;
	for(;;) ;
}
void external0(void ) interrupt 0
{
	ADCRD=0 ;
	P2=P0 ;
	ADCRD=1 ;
	// start next ADC
	ADCWR=0 ; ADCWR= 1 ;
}
%}


%{am.a51
;
;   Addressing Mode Examples
;
TT	EQU	012H
ADDR	EQU	030H
; register Addressing Mode
	MOV	A,R7
	ANL	A,R0
	INC	A
	INC	DPTR
	MUL	AB
	DIV	AB
; Immediate Addressing Mode
	MOV	R5,#012H
	MOV	R5,#18
	MOV	R5,#22O
	MOV	R5,#010010B
	MOV	R5,TT
	MOV	DPTR,#1234H
; Direct Addressing Mode
	MOV	30H,A
	MOV	ADDR,A
	MOV	30H,#12H
	MOV	P0,A
	MOV	P0,#12H
	MOV	P1,#12H
	ANL	C,40H
	ANL	C,ACC.6
	SETB	40H
	SETB	P0.2
	CLR	P0.2
	MOV	C,P0.2
; Register Indirect Addressing Mode
	MOV	@R0,#79H
	MOV	A,@R1
	MOVX	@DPTR,A
	MOVX	A,@DPTR
; Index Addressing Mode(Read Program Memory)
	MOVC	A,@A+DPTR
	MOVC	A,@A+PC
	END
%}


%{basic1a.a51
;
; The addition of two 8-bit numbers
;
%0,2 VAL1:	EQU	40H
%0,2 VAL2:	EQU	VAL1+1
%0,2 RES:	EQU	VAL2+1
%1 	DSEG	AT 40H
%1 VAL1:	DS	1
%1 VAL2:	DS	1
%1 RES:	DS	1

%1 	CSEG
START:
	MOV	A,VAL1
	ADD	A,VAL2
	MOV	RES,A
	AJMP	$
	END
%}


%{basic1b.a51
;
; The addition of two 8-bit numbers
;
%0,2 VAL1:	EQU	40H
%1 	DSEG	AT 40H
%1 VAL1:	DS	1
%1 	DS	1
%1 	DS	1
%1 	CSEG
START:
	MOV	A,VAL1
	ADD	A,VAL1+1
	MOV	VAL1+2,A
	AJMP	$
	END
%}


%{basic1c.a51
;
; The addition of two 8-bit numbers
;
%0,2 VAL1:	EQU	40H
%1 	DSEG	AT 40H
%1 VAL1:	DS	3

%0,2 	ORG	0
%1 	CSEG
START:
	MOV	A,VAL1
	ADD	A,VAL1+1
	MOV	VAL1+2,A
	AJMP	$
	END
%}


%{basic1d.a51
;
; The addition of two 8-bit numbers
;
VAL1	EQU	40H
VAL2	EQU	41H
RES	EQU	42H
;
START:
	MOV	A,VAL1
	ADD	A,VAL2
	MOV	RES,A
	AJMP	$
	END
%}


%{basic1e.a51
;
; The addition of two 8-bit numbers
;
VAL1	EQU	40H
VAL2	EQU	41H
RES	EQU	42H
;
START:
	MOV	R0,#VAL1
	MOV	R1,#VAL2
	MOV	A,@R0
	ADD	A,@R1
	MOV	R0,#RES
	MOV	@R0,A
	AJMP	$
	END
%}


%{basic1f.a51
;
; The addition of two 8-bit numbers
;
VAL1	EQU	40H
;
START:
	MOV	R0,#VAL1
 	MOV	A,@R0
	INC	R0
	ADD	A,@R0
	INC	R0
	MOV	@R0,A
 	AJMP	$
	END
%}


%{basic1g.a51
;
; The addition of two 8-bit numbers (BCD)
;
%0,2 VAL1:	EQU	40H
%0,2 VAL2:	EQU	VAL1+1
%0,2 RES:	EQU	VAL2+1
%1 	DSEG	AT 40H
%1 VAL1:	DS	1
%1 VAL2:	DS	1
%1 RES:	DS	1

%1 	CSEG
START:
	MOV	A,VAL1
	ADD	A,VAL2
	DA	A
	MOV	RES,A
	AJMP	$
	END
%}


@1
%{basic1a.c
//
// The addition of two 8-bit numbers
//
#pragma oe db pw(80) SM SB CD
#include    <reg51.h>
unsigned char val1,val2,res;
main()
{
	res=val1+val2 ;
	for(;;);
}
%}


@1
%{basic1b.c
//
// The addition of two 8-bit numbers
//
#pragma oe db pw(80) SM SB CD
unsigned char data *val1;
unsigned char data *val2;
unsigned char data *res;
main()
{
	val1= 0x40 ;
	val2= 0x41 ;
	res= 0x42 ;
	*res=*val1+*val2 ;
	for(;;);
}
%}


@1
%{basic1c.c
//
// The addition of two 8-bit numbers
//
#pragma oe db pw(80) SM SB CD
unsigned char data *val1;
main()
{
	val1= 0x40 ;
	*(val1+2)=*val1+*(val1+1) ;
	for(;;);
}
%}


@1
%{basic1d.c
//
// The addition of two 8-bit numbers
//
#pragma oe db pw(80) SM SB CD
unsigned char val1,val2,res;
unsigned char  data * pval1 ;
unsigned char  data * pval2 ;
unsigned char  data * pres ;
main()
{
	pval1= &val1 ;
	pval2= &val2 ;
	pres= &res ;
	*pres= *pval1+*pval2 ;
	for(;;);
}
%}


@1
%{basic1e.c
//
// The addition of two 8-bit numbers
//
#pragma oe db pw(80) SM SB CD
unsigned char val1[3];
unsigned char data  * pval1 ;
main()
{
	pval1= val1 ;
	*(pval1+2)= *pval1+*(pval1+1) ;
	for(;;);
}
%}


@1
%{basic1f.c
//
// The addition of two 8-bit numbers
//
#pragma oe db pw(80) SM SB CD
unsigned char val1[3];
unsigned char data  * pval1 ;
main()
{
	pval1= val1 ;
	pval1[2]= pval1[0]+pval1[1] ;
	for(;;);
}
%}


@1
%{basic1g.c
//
// The addition of two 8-bit numbers (BCD)
//
#pragma oe db pw(80) SM SB CD
#include    <reg51.h>
unsigned char val1,val2,res;
main()
{
	unsigned char low4,high4 ,carry ;
	F0=1 ;
	low4=(val1&0xf)+(val2&0xf) ;
	carry=0 ;
	if(low4 >= 10){
	    carry=0x1 ;
	    low4-= 10 ;
	}
	high4=(val1 >> 4)+(val2 >> 4)+carry ;
	carry=0 ;
	if(high4 >=10){
	    carry=1 ;
	    high4-= 10 ;
	}
	res = (high4 << 4)+low4 ;
	for(;;);
}
%}


%{basic2a.a51
;
; The addition of two 16-bit numbers
;
%0,2 VAL1:	EQU	40H ; low address store high byte of 16-bit value
%0,2 VAL2:	EQU	VAL1+2
%0,2 RES:	EQU	VAL2+2
%1 	DSEG	AT 40H
%1 VAL1:	DS	2 ; low address store high byte of 16-bit value
%1 VAL2:	DS	2
%1 RES:	DS	2

%1 	CSEG
START:
	MOV	A,VAL1+1
	ADD	A,VAL2+1
	MOV	RES+1,A

	MOV	A,VAL1
	ADDC	A,VAL2
	MOV	RES,A

	AJMP	$
	END
%}


@1
%{basic2a.c
//
// The addition of two 16-bit numbers
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned int val1,val2,res;
main()
{
	F0=1 ;
	res=val1+val2 ;
	for(;;);
}
%}


@1
%{basic2b.c
//
// The addition of two 16-bit numbers
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
unsigned int val1,val2,res;
unsigned char data *pval1 ;
unsigned char data *pval2 ;
unsigned char data *pres ;
main()
{
	unsigned char carry ;

	F0=1 ;
	pval1= (unsigned char *)&val1 ;
	pval2= (unsigned char *)&val2 ;
	pres = (unsigned char *)&res ;
	*(pres+1)=*(pval1+1)+*(pval2+1) ;
	carry = (*(pres+1) < *(pval1+1)) ? 1:0 ;
	*pres= pval1[0]+pval2[0]+carry ;
	for(;;);
}
%}


%{basic3a.a51
;
; Find the maximum from two 8-bit numbers (unsigned view)
;
%0,2 VAL1:	EQU	40H
%0,2 VAL2:	EQU	VAL1+1
%0,2 RES:	EQU	VAL2+1
%1 	DSEG	AT 40H
%1 VAL1:	DS	1
%1 VAL2:	DS	1
%1 RES:	DS	1

%1 	CSEG
START:
	CLR	C
	MOV	A,VAL1
	SUBB	A,VAL2
	JNC	VAL1G
	MOV	A,VAL2
	MOV	RES,A
	AJMP	CON
VAL1G:
	MOV	A,VAL1
	MOV	RES,A
CON:
	AJMP	$
	END
%}


@1
%{basic3a.c
//
// Find the maximum from two 8-bit numbers (unsigned view)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned char val1,val2,res;
main()
{
	if(val1 >val2){
	    res= val1 ;
	}
	else{
	    res=val2 ;
	}
	for(;;);
}
%}


@1
%{basic3b.c
//
// Find the maximum from two 8-bit numbers (unsigned view)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned char val1,val2,res;
main()
{
	res= (val1 >val2)? val1 : val2 ;
	for(;;);
}
%}


%{basic4a.a51
;
; Find the maximum from two 8-bit numbers (signed view)
;
%0,2 VAL1:	EQU	40H
%0,2 VAL2:	EQU	VAL1+1
%0,2 RES:	EQU	VAL2+1
%1 	DSEG	AT 40H
%1 VAL1:	DS	1
%1 VAL2:	DS	1
%1 RES:	DS	1

%1 	CSEG
START:
	MOV	A,VAL1
	JB	ACC.7,VAL1N
; VAL1 is plus
	MOV	A,VAL2
	JB	ACC.7,VAL1G
; VAL1©MVAL2 same sign
VAL12SS:
	MOV	A,VAL1
	CLR	C
	SUBB	A,VAL2
	JB	ACC.7,VAL2G
VAL1G:
	MOV	A,VAL1
	MOV	RES,A
	AJMP	CON
VAL1N:
	MOV	A,VAL2
	JB	ACC.7,VAL12SS
VAL2G:
	MOV	A,VAL2
	MOV	RES,A
CON:
	AJMP	$
	END
%}


%{basic4b.a51
;
; Find the maximum from two 8-bit numbers (signed view)
;
VAL1:	EQU	40H
VAL2:	EQU	VAL1+1
RES:	EQU	VAL2+1
;
START:
	CLR	C
	MOV	A,VAL2
	XRL	A,#080H
	MOV	R0,A
	MOV	A,VAL1
	XRL	A,#080H
	SUBB	A,R0
	JNC	VAL1G
	MOV	A,VAL2
	MOV	RES,A
	AJMP	CON
VAL1G:
	MOV	A,VAL1
	MOV	RES,A
CON:
	AJMP	$
	END
%}


@1
%{basic4a.c
//
// Find the maximum from two 8-bit numbers (signed view)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char val1,val2,res;
main()
{
	if(val1 >val2){
	    res= val1 ;
	}
	else{
	    res=val2 ;
	}
	for(;;);
}
%}


%{basic5a.a51
;
; Word disassembly
;
%0,2 VAL1:	EQU	40H
%0,2 HIGH4:	EQU	VAL1+1
%0,2 LOW4:	EQU	HIGH4+1
%1 	DSEG	AT 40H
%1 VAL1:	DS	1
%1 HIGH4:	DS	1
%1 LOW4:	DS	1

%1 	CSEG
START:
	MOV	A,VAL1
	RR	A
	RR	A
	RR	A
	RR	A
	ANL	A,#0FH
	MOV	HIGH4,A
	MOV	A,VAL1
	ANL	A,#0FH
	MOV	LOW4,A

	AJMP	$
	END
%}


%{basic5b.a51
;
; Word disassembly
;
%0,2 VAL1:	EQU	40H
%0,2 HIGH4:	EQU	VAL1+1
%0,2 LOW4:	EQU	HIGH4+1
%1 	DSEG	AT 40H
%1 VAL1:	DS	1
%1 HIGH4:	DS	1
%1 LOW4:	DS	1

%1 	CSEG
START:
	MOV	A,VAL1
	SWAP	A
	ANL	A,#0FH
	MOV	HIGH4,A
	MOV	A,VAL1
	ANL	A,#0FH
	MOV	LOW4,A

	AJMP	$
	END
%}


@1
%{basic5a.c
//
// Word disassembly
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char val1,high4,low4;
main()
{
	high4= (val1 >> 4 ) &0xf ;
	low4= val1 & 0xf ;
	for(;;);
}
%}


%{basic6a.a51
;
; The sum of 8-bit numbers (the sum is 8-bit)
;
%0,2 VAL:	EQU	40H ; first byte is NO. of values
%0,2 SUM:	EQU	VAL+10
%1 	DSEG	AT 40H
%1 VAL:	DS	10   ; first byte is NO. of values
%1 SUM:	DS	1

%1 	CSEG
START:
	MOV	R0,VAL
	MOV	R1,#VAL+1
	MOV	A,#0
NEXT1:
	ADD	A,@R1
	INC	R1
	DJNZ	R0,NEXT1
	MOV	SUM,A
	AJMP	$
	END
%}


@1
%{basic6a.c
//
// The sum of 8-bit numbers (the sum is 8-bit)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned char val[10],sum;
main()
{
	unsigned char i ;
	F0=1 ;
	sum=0 ;
	for(i=0 ; i < val[0];i++){
	    sum += val[1+i] ;
	}
	for(;;);
}
%}


%{basic7a.a51
;
; The sum of 8-bit numbers (the sum is 16-bit)
;
%0,2 VAL:	EQU	40H   ; first byte is NO. of values
%0,2 SUM:	EQU	VAL+10
%1 	DSEG	AT 40H
%1 VAL:	DS	10   ; first byte is NO. of values
%1 SUM:	DS	2

%1 	CSEG
START:
	MOV	R0,VAL
	MOV	R1,#VAL+1
	MOV	A,#0
	MOV	B,A
NEXT1:
	ADD	A,@R1
	INC	R1
	JNC	CON1
	INC	B
CON1:
	DJNZ	R0,NEXT1
	MOV	SUM,B
	MOV	SUM+1,A
	AJMP	$
	END
%}


@1
%{basic7a.c
//
// The sum of 8-bit numbers (the sum is 16-bit)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned char val[10];
unsigned int sum;
main()
{
	unsigned char i ;
	F0=1 ;
	sum=0 ;
	for(i=0 ; i < val[0];i++){
	    sum += val[1+i] ;
	}
	for(;;);
}
%}


%{delay1.a51
;
; setting "F0" to compute delay time-----8051 working frequence =12Mhz
;
START:
	LCALL	DELAY1MS
	SETB	F0
	AJMP	$
DELAY1MS:
	MOV	R1,#255
	DJNZ	R1,$
	MOV	R1,#242
	DJNZ R1,$
	RET
DELAY10MS:
	MOV	R0,#9
T1DLY10MS:
	ACALL	DELAY1MS
	DJNZ	R0,T1DLY10MS
	MOV	R1,#255
	DJNZ	R1,$
	MOV	R1,#232
	DJNZ	R1,$
	NOP
	RET


DELAY10MS1:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	MOV	R1,#255
	DJNZ	R1,$
	MOV	R1,#242
	DJNZ	R1,$
	RET

DELAY10MS2:
	MOV	R0,#19
T1DLY10MS2:
	MOV	R1,#255
	DJNZ	R1,$
	DJNZ	R0,T1DLY10MS2
	MOV	R1,#123
	DJNZ	R1,$
	NOP
	RET

DELAY100MS:
	MOV	R0,#194    ;delay time
T1DLY100MS:
	MOV	R1,#255
	DJNZ	R1,$
	DJNZ	R0,T1DLY100MS
	RET

DELAY1S:
	MOV	R2,#10
T2DLY1S:
 	MOV	R0,#194
T1DLY1S:
	MOV	R1,#255
	DJNZ	R1,$
	DJNZ	R0,T1DLY1S
	MOV	R1,#236
	DJNZ	R1,$
	DJNZ	R2,T2DLY1S
	MOV	R1,#7
	DJNZ	R1,$
	RET
TT:	MOV	R6,#250
S1:	MOV	R7,#200
	DJNZ	R7,$
	DJNZ	R6,S1
	RET
	END
%}


@1
%{delay1.c
//
//   setting "F0" to compute delay time-----8051 working frequence =12Mhz
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
void delay1s() ;
void delay1ms() ;
void delay10ms() ;
void delay10ms1() ;
void delay10ms2() ;
void delay100ms() ;
main()
{
	F0=1 ;
	delay100ms() ;
	F0=1 ;
}
void delay1ms()
{
	int i ;
	char  j;
	for(i=0 ; i < 124 ;i++) ;
	j++ ;
}
void delay10ms()
{
	int i ;
	char j ;
	for(i=0 ; i < 9 ; i++){
         delay1ms() ;
	}
	for(i=0 ; i < 114;i++) ;
	j++ ;
	j++ ;
	j++ ;
	j++ ;
	j++ ;
	j++ ;
}
void delay10ms1()
{
	int i ;
	char j;
	delay1ms() ;	
	delay1ms() ;	
	delay1ms() ;	
	delay1ms() ;	
	delay1ms() ;	
	delay1ms() ;	
	delay1ms() ;	
	delay1ms() ;	
	delay1ms() ;	
	for(i=0 ; i < 124 ;i++) ;
	j++ ;
}
void delay10ms2()
{
	int i ;
	char j ;
	for(i=0 ; i < 1938 ;i++) ;
	j++ ;
	j++ ;
}
void delay100ms()
{
	long i ;
	char j ;
	for(i=0 ; i < 709 ; i++) ;  
	for(j=0 ; j < 5 ;j++) ;
	j++ ;
	j++ ;
}
void delay1s()
{
	long i ;
	char j ;
	for(i=0 ; i < 7092 ; i++) ;  // delay time
	for(j=0 ; j < 4 ;j++) ;
	j++ ;
	j++ ;
}
%}


%{mul16a.a51
;
; A(16bit)*B(16bit) Binary unsigned view
;
%0,2 MA:      EQU	40H
%0,2 MB:      EQU	MA+2
%0,2 MP:      EQU	MB+2
%1 	CSEG
%1 	DSEG	AT 40H
%1 MA:      DS	2
%1 MB:      DS	2
%1 MP:      DS	4
%1 	CSEG
DOUBLET	MACRO
	MOV	A,R4
	CLR	C
	RLC	A
	MOV	R4,A
	MOV	A,R3
	RLC	A
	MOV	R3,A
	MOV	A,R2
	RLC	A
	MOV	R2,A
	MOV	A,R1
	RLC	A
	MOV	R1,A
	ENDM
ADDPT	MACRO
	MOV	A,R4
	ADD	A,MP+3
	MOV	MP+3,A
	MOV	A,R3
	ADDC	A,MP+2
	MOV	MP+2,A
	MOV	A,R2
	ADDC	A,MP+1
	MOV	MP+1,A
	MOV	A,R1
	ADDC	A,MP+0
	MOV	MP+0,A
	ENDM


START:
; test data  1234H*5678H=? (6260060H)
	MOV	MA,#12H
	MOV	MA+1,#34H
	MOV	MB,#56H
	MOV	MB+1,#78H


	MOV	R1,#0
	MOV	R2,#0
	MOV	R3,MA
	MOV	R4,MA+1

	MOV	A,MB+1
	JNB	ACC.0,NEXT0
	MOV	MP,R1
	MOV	MP+1,R2
	MOV	MP+2,R3
	MOV	MP+3,R4
	SJMP	NEXT01
NEXT0:
	MOV	MP,#0
	MOV	MP+1,#0
	MOV	MP+2,#0
	MOV	MP+3,#0
NEXT01:
	DOUBLET
	MOV	A,MB+1
	JNB	ACC.1,NEXT1
	ADDPT
NEXT1:
	DOUBLET
	MOV	A,MB+1
	JNB	ACC.2,NEXT2
	ADDPT
NEXT2:
	DOUBLET
	MOV	A,MB+1
	JNB	ACC.3,NEXT3
 	ADDPT
NEXT3:
	DOUBLET
	MOV	A,MB+1
	JNB	ACC.4,NEXT4
	ADDPT
NEXT4:
	DOUBLET
	MOV	A,MB+1
	JNB	ACC.5,NEXT5
	ADDPT
NEXT5:
	DOUBLET
	MOV	A,MB+1
	JNB	ACC.6,NEXT6
	ADDPT
NEXT6:
	DOUBLET
	MOV	A,MB+1
	JNB	ACC.7,NEXT7
	ADDPT
NEXT7:
	DOUBLET
	MOV	A,MB
	JNB	ACC.0,NEXT8
	ADDPT
NEXT8:
	DOUBLET
	MOV	A,MB
	JNB	ACC.1,NEXT9
	ADDPT
NEXT9:
	DOUBLET
	MOV	A,MB
	JNB	ACC.2,NEXT10
	ADDPT
NEXT10:
	DOUBLET
	MOV	A,MB
	JNB	ACC.3,NEXT11
	ADDPT
NEXT11:
	DOUBLET
	MOV	A,MB
	JNB	ACC.4,NEXT12
	ADDPT
NEXT12:
	DOUBLET
	MOV	A,MB
	JNB	ACC.5,NEXT13
	ADDPT
NEXT13:
	DOUBLET
	MOV	A,MB
	JNB	ACC.6,NEXT14
	ADDPT
NEXT14:
	DOUBLET
	MOV	A,MB
	JNB	ACC.7,NEXT15
	ADDPT
NEXT15:

	AJMP	$
	END
%}


%{mul16b.a51
;
; A(16bit)*B(16bit) Binary unsigned view
;
%0,2 MA:	DS	40H
%0,2 MB:	DS	MA+2
%0,2 MP:	DS	MB+2
%0,2 MT:	DS	MP+4
%1 	CSEG
%1 	DSEG	AT 40H
%1 MA:	DS	2
%1 MB:	DS	2
%1 MP:	DS	4
%1 MT:	DS	4
%1 	CSEG

START:
; test data  1234H*5678H=? (6260060H)

	MOV	MA,#12H
	MOV	MA+1,#34H
	MOV	MB,#56H
	MOV	MB+1,#78H
;   t <- A
	MOV	MT,#0
	MOV	MT+1,#0
	MOV	MT+2,MA
	MOV	MT+3,MA+1
;   P <--B0*t
	MOV	A,MB+1
	JNB	ACC.0,NEXT1
;   P<----t
	MOV	MP,MT
	MOV	MP+1,MT+1
	MOV	MP+2,MT+2
	MOV	MP+3,MT+3
	AJMP	NEXT2
NEXT1:
;   P<----0
	MOV	MP,#0
	MOV	MP+1,#0
	MOV	MP+2,#0
	MOV	MP+3,#0
NEXT2:
	MOV	R7,#15     ; repeat 15 times
LOOP1:
;   t <-t*2
	CLR	C
	MOV	A,MT+3
	RLC	A
	MOV	MT+3,A
	MOV	A,MT+2
	RLC	A
	MOV	MT+2,A
	MOV	A,MT+1
	RLC	A
	MOV	MT+1,A
	MOV	A,MT
	RLC	A
	MOV	MT,A
; B <-- shr B
	MOV	A,MB
	RRC	A
	MOV	MB,A
	MOV	A,MB+1
	RRC	A
	MOV	MB+1,A
;   check B0
	MOV	A,MB+1
	JNB	ACC.0,NEXT3
;   P<----P+t
	MOV	A,MT+3
	ADD	A,MP+3
	MOV	MP+3,A
	MOV	A,MT+2
	ADDC	A,MP+2
	MOV	MP+2,A
	MOV	A,MT+1
	ADDC	A,MP+1
	MOV	MP+1,A
	MOV	A,MT+0
	ADDC	A,MP+0
	MOV	MP+0,A
NEXT3:
	DJNZ	R7,LOOP1

	AJMP	$
	END
%}


%{mul16c.a51
;
; A(16bit)*B(16bit) Binary unsigned view
;
%0,2 MA:	EQU	40H
%0,2 MB:	EQU	MA+2
%0,2 MP:	EQU	MB+2
%1 	DSEG	AT 40H
%1 MA:	DS	2
%1 MB:	DS	2
%1 MP:	DS	4
%1 	CSEG

START:
; test data  1234H*5678H=? (6260060H)

	MOV	MA,#12H
	MOV	MA+1,#34H
	MOV	MB,#56H
	MOV	MB+1,#78H
;   P<----0
	MOV	MP,#0
	MOV	MP+1,#0
	MOV	MP+2,#0
	MOV	MP+3,#0

	MOV	R7,#16     ; repeat 16 times
LOOP1:
;   t <-t*2
	CLR	C
	MOV	A,MP+3
	RLC	A
	MOV	MP+3,A
	MOV	A,MP+2
	RLC	A
	MOV	 MP+2,A
	MOV	A,MP+1
	RLC	A
	MOV	MP+1,A
	MOV	A,MP
	RLC	A
	MOV	MP,A
; B <-- shl B
	MOV	A,MB+1
	RLC	A
	MOV	MB+1,A
	MOV	A,MB
	RLC	A
	MOV	MB,A

	JNC	NEXT3
;   P<----P+A
	MOV	A,MA+1
	ADD	A,MP+3
	MOV	MP+3,A
	MOV	A,MA+0
	ADDC	A,MP+2
	MOV	MP+2,A
	MOV	A,#0
	ADDC	A,MP+1
	MOV	MP+1,A
	MOV	A,#0
	ADDC	A,MP+0
	MOV	MP+0,A
NEXT3:
	DJNZ	R7,LOOP1

	AJMP	$
	END
%}


%{mul16d.a51
;
; A(16bit)*B(16bit) Binary unsigned view
;
%0,2 MA:	EQU	40H
%0,2 MB:	EQU	MA+2
%0,2 MP:	EQU	MB+2
%0,2 ALBL:	EQU	MP+4
%0,2 AHBL:	EQU	ALBL+2
%0,2 ALBH:	EQU	AHBL+2
%0,2 AHBH:	EQU	ALBH+2
%1 	DSEG	AT 40H
%1 MA:	DS	2
%1 MB:	DS	2
%1 MP:	DS	4
%1 ALBL:	DS	2
%1 AHBL:	DS	2
%1 ALBH:	DS	2
%1 AHBH:	DS	2
%1 	CSEG

START:
; test data  1234H*5678H=? (6260060H)

	MOV	MA,#12H
	MOV	MA+1,#34H
	MOV	MB,#56H
	MOV	MB+1,#78H

;   AL*BL
	MOV	A,MA+1
	MOV	B,MB+1
	MUL	AB
	MOV	ALBL,B
	MOV	ALBL+1,A
;   AH*BL
	MOV	A,MA
	MOV	B,MB+1
	MUL	AB
	MOV	AHBL,B
	MOV	AHBL+1,A
;   AL*BH
	MOV	A,MA+1
	MOV	B,MB
	MUL	AB
	MOV	ALBH,B
	MOV	ALBH+1,A
;   AH*BH
	MOV	A,MA
	MOV	B,MB
	MUL	AB
	MOV	AHBH,B
	MOV	AHBH+1,A
;
	MOV	MP+3,ALBL+1
;compute MP+2
	MOV	A,ALBL
	ADD	A,AHBL+1
	MOV	R6,A
	CLR	A
	ADDC	A,#0
	MOV	R7,A

	MOV	A,R6
	ADD	A,ALBH+1
	MOV	MP+2,A
	CLR	A
	ADDC	A,R7
;compute MP+1
	ADD	A,AHBL
	MOV	R6,A
	CLR	A
	ADDC	A,#0
	MOV	R7,A

	MOV	A,R6
	ADD	A,ALBH
	MOV	R6,A
	CLR	A
	ADDC	A,R7
	MOV	R7,A

	MOV	A,R6
	ADD	A,AHBH+1
	MOV	MP+1,A
	CLR	A
	ADDC	A,R7

;compute MP
	ADD	A,AHBH
	MOV	MP,A

	AJMP	$
	END
%}


@1
%{mul16a.c
//
//  A(16bit)*B(16bit) Binary unsigned view
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned int MA,MB;
unsigned long MP ;
main()
{
//  test data  0x1234*0x5678=? (0x6260060)
	MA=0x1234;
	MB=0x5678 ;
	
	if(MB&0x1){
	    MP=MA ;
	}
	else{
	    MP=0 ;
	}
	if(MB&0x2){
	    MP= MP+((unsigned long)MA << 1) ;
	}
	if(MB&0x4){
	    MP= MP+((unsigned long)MA << 2) ;
	}
	if(MB&0x8){
	    MP= MP+((unsigned long)MA << 3) ;
	}
	if(MB&0x10){
	    MP= MP+((unsigned long)MA << 4) ;
	}
	if(MB&0x20){
	    MP= MP+((unsigned long)MA << 5) ;
	}
	if(MB&0x40){
	    MP= MP+((unsigned long)MA << 6) ;
	}
	if(MB&0x80){
	    MP= MP+((unsigned long)MA << 7) ;
	}
	if(MB&0x100){
	    MP= MP+((unsigned long)MA << 8) ;
	}
	if(MB&0x200){
	    MP= MP+((unsigned long)MA << 9) ;
	}
	if(MB&0x400){
	    MP= MP+((unsigned long)MA << 10) ;
	}
	if(MB&0x800){
	    MP= MP+((unsigned long)MA << 11) ;
	}
	if(MB&0x1000){
	    MP= MP+((unsigned long)MA << 12) ;
	}
	if(MB&0x2000){
	    MP= MP+((unsigned long)MA << 13) ;
	}
	if(MB&0x4000){
	    MP= MP+((unsigned long)MA << 14) ;
	}
	if(MB&0x8000){
	    MP= MP+((unsigned long)MA << 15) ;
	}
	for(;;);
}
%}


@1
%{mul16b.c
//
//  A(16bit)*B(16bit) Binary unsigned view
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned int MA,MB;
unsigned long MP ;
main()
{
	unsigned int AL,AH,BL,BH ;
	unsigned int ALBL,AHBL,ALBH,AHBH ;
//  test data  0x1234*0x5678=? (0x6260060)
	MA=0x1234;
	MB=0x5678 ;
	AL=MA&0xff ;
	AH=MA >> 8 ;
	BL=MB&0xff ;
	BH=MB >> 8 ;
	ALBL=AL*BL ;
	AHBL=AH*BL ;
	ALBH=AL*BH ;
	AHBH=AH*BH ;
	MP=(unsigned long)(ALBL)+((unsigned long)(AHBL) << 8)+((unsigned long)(ALBH) << 8)+((unsigned long)(AHBH) << 16) ;
	for(;;);
}
%}


@1
%{mul16c.c
//
//  A(16bit)*B(16bit) Binary unsigned view
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned int MA,MB;
unsigned long MP ;
main()
{
//  test data  0x1234*0x5678=? (0x6260060)
	MA=0x1234;
	MB=0x5678 ;
	MP=(unsigned long)MA*(unsigned long)MB ;
	for(;;);
}
%}


%{div32a.a51
;
; M(32bit)/N(16bit)=Q(32bit)...R(16bit) Binary unsigned view
;
%0,2 MM:	EQU	40H
%0,2 MN:	EQU	MM+4
%0,2 MQ:	EQU	MN+2
%0,2 MR:	EQU	MQ+4
%0,2 MT:	EQU	MR+2
%1 	DSEG	AT 40H
%1 MM:	DS	4
%1 MN:	DS	2
%1 MQ:	DS	4
%1 MR:	DS	2
%1 MT:	DS	6

%1 	CSEG
START:
; test data(12345678H/234H)=? (84354H....168H)

	MOV	MM,#12H
	MOV	MM+1,#34H
	MOV	MM+2,#56H
	MOV	MM+3,#78H
	MOV	MN,#02H
	MOV	MN+1,#34H

; T<--2**32*N
	MOV	MT,MN
	MOV	MT+1,MN+1
	MOV	MT+2,#0
	MOV	MT+3,#0
	MOV	MT+4,#0
	MOV	MT+5,#0

	MOV	R0,#32
LOOP1:
;  T <-T/2
	MOV	A,MT
	CLR	C
	RRC	A
	MOV	MT,A
	MOV	A,MT+1
	RRC	A
	MOV	MT+1,A
	MOV	A,MT+2
	RRC	A
	MOV	MT+2,A
	MOV	A,MT+3
	RRC	A
	MOV	MT+3,A
	MOV	A,MT+4
	RRC	A
	MOV	MT+4,A
	MOV	A,MT+5
	RRC	A
	MOV	MT+5,A
;      M >=T
	MOV	A,MT
	ORL	A,MT+1
	JNZ	LESS1
	MOV	A,MM
	CJNE	A,MT+2,NEXT2
	MOV	A,MM+1
	CJNE	A,MT+3,NEXT2
	MOV	A,MM+2
	CJNE	A,MT+4,NEXT2
	MOV	A,MM+3
	CJNE	A,MT+5,NEXT2
	SJMP	GREATER

NEXT2:
	JC	LESS1
GREATER:
; M<-M-T
	MOV	A,MM+3
	CLR	C
	SUBB	A,MT+5
	MOV	MM+3,A
	MOV	A,MM+2
	SUBB	A,MT+4
	MOV	MM+2,A
	MOV	A,MM+1
	SUBB	A,MT+3
	MOV	MM+1,A
	MOV	A,MM+0
	SUBB	A,MT+2
	MOV	MM+0,A
	SETB	C
	SJMP	CON1
LESS1:
	CLR	C
CON1:
	MOV	A,MQ+3
	RLC	A
	MOV	MQ+3,A
	MOV	A,MQ+2
	RLC	A
	MOV	MQ+2,A
	MOV	A,MQ+1
	RLC	A
	MOV	MQ+1,A
	MOV	A,MQ+0
	RLC	A
	MOV	MQ+0,A
	DJNZ	R0,LOOP1

	MOV	MR,MM+2
	MOV	MR+1,MM+3

	AJMP	$
	END
%}


%{div32b.a51
;
; M(32bit)/N(16bit)=Q(32bit)...R(16bit) Binary unsigned view
;
%0,2 MM:	EQU	40H
%0,2 MN:	EQU	MM+4
%0,2 MQ:	EQU	MN+2
%0,2 MR:	EQU	MQ+4
%0,2 MT:	EQU	MR+2
%1 	DSEG	AT 40H
%1 MM:	DS	4
%1 MN:	DS	2
%1 MQ:	DS	4
%1 MR:	DS	2
%1 MT:	DS	3
%1 	CSEG
START:
; test data (12345678H/234H)=? (84354H....168H)

	MOV	MM,#12H
	MOV	MM+1,#34H
	MOV	MM+2,#56H
	MOV	MM+3,#78H
	MOV	MN,#02H
	MOV	MN+1,#34H

; T<--0
	MOV	MT,#0
	MOV	MT+1,#0
	MOV	MT+2,#0

	MOV	R0,#32
LOOP1:
;  T <- T*2
	MOV	A,MT+2
	CLR	C
	RLC	A
	MOV	MT+2,A
	MOV	A,MT+1
	RLC	A
	MOV	MT+1,A
	MOV	A,MT+0
	RLC	A
	MOV	MT+0,A
; C,M <-shl M
	MOV	A,MM+3
	CLR	C
	RLC	A
	MOV	MM+3,A
	MOV	A,MM+2
	RLC	A
	MOV	MM+2,A
	MOV	A,MM+1
	RLC	A
	MOV	MM+1,A
	MOV	A,MM+0
	RLC	A
	MOV	MM+0,A
;    T <- T+C
	JNC	NEXT1
	INC	MT+2
NEXT1:
;      T >=N
	MOV	A,MT
	JNZ	GREATER
	CLR	C
	MOV	A,MT+2
	SUBB	A,MN+1
	MOV	A,MT+1
	SUBB	A,MN
	JC	LESS1
GREATER:
	MOV	A,MT+2
	SUBB	A,MN+1
	MOV	MT+2,A
	MOV	A,MT+1
	SUBB	A,MN
	MOV	MT+1,A
	MOV	A,MT
	SUBB	A,#0
	MOV	MT,A
	SETB	C
	SJMP	CON1
LESS1:
	CLR	C
CON1:
	MOV	A,MQ+3
	RLC	A
	MOV	MQ+3,A
	MOV	A,MQ+2
	RLC	A
	MOV	MQ+2,A
	MOV	A,MQ+1
	RLC	A
	MOV	MQ+1,A
	MOV	A,MQ+0
	RLC	A
	MOV	MQ+0,A
	DJNZ	R0,LOOP1

	MOV	MR,MT+1
	MOV	MR+1,MT+2

	AJMP	$
	END
%}


%{div32c.a51
;
; M(32bit)/N(16bit)=Q(32bit)...R(16bit) Binary unsigned view
;
%0,2 MM:	EQU	40H
%0,2 MN:	EQU	MM+4
%0,2 MQ:	EQU	MN+2
%0,2 MR:	EQU	MQ+4
%0,2 MT:	EQU	MR+2
%1 	DSEG	AT 40H
%1 MM:	DS	4
%1 MN:	DS	2
%1 MQ:	DS	4
%1 MR:	DS	2
%1 MT:	DS	3
%1 	 CSEG
START:
; test data (12345678H/234H)=? (84354H....168H)

	MOV	MM,#12H
	MOV	MM+1,#34H
	MOV	MM+2,#56H
	MOV	MM+3,#78H
	MOV	MN,#02H
	MOV	MN+1,#34H

; T<--0
	MOV	MT,#0
	MOV	MT+1,#0
	MOV	MT+2,#0

	MOV	R0,#32
LOOP1:
;  T <- T*2
	MOV	A,MT+2
	CLR	C
	RLC	A
	MOV	MT+2,A
	MOV	A,MT+1
	RLC	A
	MOV	MT+1,A
	MOV	A,MT+0
	RLC	A
	MOV	MT+0,A
; C,M <-shl M
	MOV	A,MM+3
	CLR	C
	RLC	A
	MOV	MM+3,A
	MOV	A,MM+2
	RLC	A
	MOV	MM+2,A
	MOV	A,MM+1
	RLC	A
	MOV	MM+1,A
	MOV	A,MM+0
	RLC	A
	MOV	MM+0,A
;    T <- T+C
	JNC	NEXT1
	INC	MT+2
NEXT1:
;      T >=N
	MOV	A,MT
	JNZ	GREATER
	CLR	C
	MOV	A,MT+2
	SUBB	A,MN+1
	MOV	A,MT+1
	SUBB	A,MN
	JC	LESS1
GREATER:
	MOV	A,MT+2
	SUBB	A,MN+1
	MOV	MT+2,A
	MOV	A,MT+1
	SUBB	A,MN
	MOV	MT+1,A
	MOV	A,MT
	SUBB	A,#0
	MOV	MT,A
	INC	MM+3
LESS1:
	DJNZ	R0,LOOP1

	MOV	MQ,MM
	MOV	MQ+1,MM+1
	MOV	MQ+2,MM+2
	MOV	MQ+3,MM+3

	MOV	MR,MT+1
	MOV	MR+1,MT+2

	AJMP	$
	END
%}


@1
%{div32a.c
//
//  M(32bit)/N(16bit)=Q(32bit)...R(16bit) Binary unsigned view
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned long MM,MQ;
unsigned int MN,MR ;
unsigned int MTH ;
unsigned long MTL ;
main()
{
	unsigned char i ;
	//  test data (0x12345678/0x234)=?  (0x84354....0x168)

	MM=0x12345678;
	MN=0x234 ;
	
	MTH=MN ;
	MTL=0 ;
	for(i=0 ; i < 32 ; i++){
	    // T <=T /2 
	    MTL >>= 1 ;
	    if(MTH&0x1){
		MTL |=0x80000000 ;
	    }
	    MTH >>=1 ;
	    MQ <<=1 ;
	    if((MTH ==0) && (MM >=  MTL)){
		MQ++ ;
		MM-=MTL ;
	    }
	}
	MR=MM ;
	for(;;);
}
%}


@1
%{div32b.c
//
//  M(32bit)/N(16bit)=Q(32bit)...R(16bit) Binary unsigned view
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned long MM,MQ;
unsigned int MN,MR ;
unsigned long MT ;
main()
{
	unsigned char i ;
	//  test data (0x12345678/0x234)=?  (0x84354....0x168)

	MM=0x12345678;
	MN=0x234 ;
	
	MT=0 ;
	for(i=0 ; i < 32 ; i++){
	    // T <=T *2 
	    MT <<= 1 ;
	    if(MM&0x80000000){
		MT++ ;
	    }
	    MM <<=1 ;

	    MQ <<=1 ;
	    if(MT >=MN){
		MT-=MN ;
		MQ++ ;
	    }
	}
	MR=MT ;
	for(;;);
}
%}


@1
%{div32c.c
//
//  M(32bit)/N(16bit)=Q(32bit)...R(16bit) Binary unsigned view
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned long MM,MQ;
unsigned int MN,MR ;
main()
{
	//  test data (0x12345678/0x234)=?  (0x84354....0x168)

	MM=0x12345678;
	MN=0x234 ;
	
	MQ=MM/MN ;
	MR=MM-MQ*MN ;
	for(;;);
}
%}


@1
%{bz.c
//
//       P0.0 control ON/OFF Speaker operation 
//        Sequence sound Do~Si, each sound continue 1 sec..
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"

char tbl1[]={19,17,15,14,12,11,10,9};
int  tbl2[]={523,587,659,698,785,880,988,1047};
main()
{
	char j, t1;
	int  i, k, t2;

	P0 =0;
	
	for(i=0; i<8; i++){
	    t2=tbl2[i];
	    t1=tbl1[i];	
	    for(k=0; k<t2; k++){
		for(j=0; j<t1; j++){
		    Delay100us();
		}
		P0 = ~P0;
	    }
	}
	for(;;);
}
%}


@1
%{dac1.c
//
//   Read  the value setting in DIP Switch ,then send to the DAC0800
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
main()
{
	for(;;){
	    P0=~P1 ;
	}
}
%}


@1
%{dac2.c
//
//   The DAC0800 send out SIN wave
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code sintbl[]= {
	128,167,203,231,249,
	255,249,231,203,167,
	127,88 , 52, 24,  6,
	0  ,6  , 24, 52, 88
} ;
main()
{
	char i ;
	for(;;){
	    for(i=0;i < 20;i++){
		P0=sintbl[i];
		Delay1ms() ;
	    }
	}
}
%}


%{dipsw1.a51
;
;   ON/OFF setting in DIP Switch control Light/Dark of 8 pieces of LED
;
START:
	MOV	A,P1
	CPL	A	;complement switch setting value (0->1,1->0)
	MOV	P0,A
	AJMP	START
	END
%}


@1
%{dipsw1.c
//
//    ON/OFF setting in DIP Switch control Light/Dark of 8 pieces of LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
main()
{
	for(;;){
	    P0=~P1 ;  //complement switch setting value(0->1,1->0)
	}
}
%}


%{dipsw2.a51
;
;   The value setting in DIP Switch control  8 pieces of LED counting speed
;
START:
	INC	P0
	MOV	A,P1
	CPL	A
	JZ	START
DLY1:
	ACALL	DELAY10MS
	DEC	A
	JNZ	DLY1
	AJMP	START

	$include (delay.inc)

	END
%}


@1
%{dipsw2.c
//
//   The value setting in DIP Switch control  8 pieces of LED counting speed
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
main()
{
	unsigned char i;
	for(;;){
	    P0++ ;
	    for(i=0 ; i < ~P1 ; i++){
		Delay10ms() ;
	    }
	}
}
%}


%{dt1.a51
;
%0,2 ;    using EQU
%1 ;    using DSEG,DS©ÎEQU
;   Demonstrate the assembler directive of reserved internal data memory
;
%1 	DSEG	AT 30H
%1 DT1:	DS	2
%1 DT2:	DS	1

TDT1	EQU	30H
TDT2	EQU	32H

%0,2 	ORG	0
%1 	CSEG

%1 	MOV	A,DT1
	MOV	A,TDT1
%1 	MOV	A,DT2
	MOV	A,TDT2
	END
%}


%{dt2.a51
;
%0,2 ;       using EQU
%1 ;       using BSEG,EQU,DBIT
;  Demonstrate the assembler directive of reserved bit data  memory
;
%1 	BSEG	AT 30H
%1 DT1:	DBIT	3
%1 DT2:	DBIT	1
TDT1	EQU	30H
%0,2 ADT1	REG	26h.0
%1 ADT1	EQU	26h.0
TDT2	EQU	33H
%0,2 ADT2	REG	26h.3
%1 ADT2	EQU	26h.3

%0,2 	ORG 0
%1 	CSEG
%1 	MOV	C,DT1
	MOV	C,TDT1
	MOV	C,ADT1
	MOV	C,26h.0
%1 	MOV	C,DT2
	MOV	C,TDT2
	MOV	C,ADT2
	MOV	C,26h.3
	END
%}


%{dt3.a51
;
%0,2 ;       using ORG,EQU,DB,DW
%1 ;       using CSEG,EQU,DB,DW
; Demonstrate the assembler directive of  reserved program  memory
;
%0,2 	ORG	0
%1 	CSEG
	MOV	DPTR,#DT1
	MOV	DPTR,#TDT1
	MOV	DPTR,#DT2
	MOV	DPTR,#TDT2
TDT1	EQU	$
DT1:	DB	1,2,3,4
TDT2	EQU	$
DT2:	DW	1,2,3,4
	END
%}


%{dt4a.a51
;
;       using MACRO,MEND
;   Demonstrate the assembler directive of MACRO design
;
%1 $GEN   ; generate macro list
ADD3	MACRO	T1,T2,T3
	MOV	A,T1
	ADD	A,T2
	ADD	A,T3
	ENDM

%0,2 	ORG	0
%1 	CSEG

	ADD3	10,11,12
	END
%}
%{dt4b.a51
;
;       Demonstrate  the assembler directive of Local label in Macro design(error)
;  because macro call TM1 2 times , so generate two label name LOOP
; 
%1 $GEN   ; generate macro list

TM1	MACRO
LOOP:	NOP
	AJMP	LOOP
	ENDM


%0,2 	ORG	0
%1 	CSEG

	TM1
	TM1
	END
%}
%{dt4c.a51
;
%0 ;       local label $n
%1 ;       using LOCAL
%2 ;       local label suffix with #
;  Demonstrate  the assembler directive of Local label in Macro design
;
%1 $GEN   ; generate macro list

TM2	MACRO
%0 $1:	NOP
%0 	AJMP	$1
%1 	LOCAL	LOOP
%1 LOOP:	NOP
%1 	AJMP	LOOP
%2  LOOP#:	NOP
%2 	AJMP	LOOP#
	ENDM

%0,2 	ORG	0
%1 	CSEG

	TM2
	TM2
	END
%}


%{dt5.a51
;
%0,2 ;       using INCLUDE 
%1 ;        using $INCLUDE
;
;    Demonstrate  the assembler directive of include file
%1 $GEN  ; generate macro list
%0,2 	INCLUDE	dt5a.a51
%1 	$INCLUDE	(dt5a.a51)
%0,2 	ORG	0
%1 	CSEG
	ADD3	10,11,12
	END
%}


%{dt5a.a51
ADD3	MACRO	T1,T2,T3
	MOV	A,T1
	ADD	A,T2
	ADD	A,T3
	ENDM
%}


%{dt6a.a51
;
;       using PUBLIC,EXTRN
;    Demonstrate  the assembler directive of linking  Multiple files
%0,2 ;      no such function for  this assembler 
;
%1 	DSEG	AT	30H
%1 	PUBLIC   DT1
%1 DT1:	DS	1
%1 	CSEG	AT 200H
%1 	PUBLIC	SUB1,SUB2
%1 SUB1:
%1 	NOP
%1 	RET
%1 SUB2: NOP
%1 	RET
%1 	END
%}


%{dt6b.a51
;
;       using PUBLIC,EXTRN
;    Demonstrate  the assembler directive of linking  Multiple files
%0,2 ;      no such function for  this assembler 
;
%1 	CSEG	AT   0
%1 	EXTRN	CODE(SUB1),CODE(SUB2),DATA(DT1)
%1 	LCALL	SUB1
%1 	LCALL	SUB2
%1 	MOV	A,DT1
%1 	END
%}


@1
%{dism1.c
//
//   Get keycode from keyboard ,then display on Text LCD
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
void delay20ms() ;
unsigned char code IdxCol[]= {
	0 , 1 , 0 , 2 ,
	0 , 1 , 0 , 3 ,
	0 , 1 , 0 , 2 ,
	0 , 1 , 0 , 4
} ;
char code *keycode[]= {
	"0","1","2","3" ,
	"4","5","6","7" ,
	"8","9","A","B" ,
	"C","D","E","F" ,
	"F1","F2","F3","CR" ,
} ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0 set to input port 
	do{
	    RS=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0
}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
main()
{
	unsigned char row ;
	char keyflag ;
	char tP1 ;
	char key ;
	char code *ptr ;

	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // 8 bits data length/2 lines/5*10 dots
	Command(0xe) ;     // display ON
	Command(0x1) ;     // clear display
	Command(0x80) ;    // DD RAM address  is  0
	for(;;){
	    do{
		for(P1=tP1=0xf7,row=0 ,keyflag=0 ; (row < 5);row++){
		    if((P2&0xf) != 0xf){
			keyflag=1 ;
			break ;
		    }
		    tP1 <<=1 ;
		    tP1 |=0x7 ;
		    P1=tP1 ;
		}
		if(keyflag== 1){
		    delay20ms() ;
		    if((P2&0xf) ==0xf){
			keyflag= 0 ;
		    }
		}
	    }
	    while(keyflag==0) ;
	    key=row*4+IdxCol[P2&0xf];
	    do{
		while((P2&0xf) != 0xf) ;
		delay20ms() ;
	    }
	    while((P2 &  0xf) != 0xf) ;
	    ptr= keycode[key] ;
	    while(*ptr !=0){
		Data(*ptr++);
	    }
	}
}
void delay20ms()
{
	char i ;
	for(i=0 ; i < 2 ;i++) Delay10ms();
}
%}


%{dotmtx1a.a51
;
;   Display Chinese word "da" on 8*8 Mono Dot-matrix LED
;
START:
	MOV	R2,#0
	MOV	R4,#080H
	MOV	DPTR,#DAI
LOOP:
	MOV	P1,#0FFH   ;  close common anode
	MOV	A,R2
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R2

	MOV	A,R4
	XRL	A,#0FFH
	MOV	P1,A

	MOV	A,R4
	RR	A
	MOV	R4,A

	CJNE	R2,#8,DELAY
	MOV	R2,#0
;	MOV	R4,#080H

DELAY:
	MOV	R3,#3
NEXT2:
	ACALL	DELAY1MS
	DJNZ	R3,NEXT2

	AJMP  	LOOP

%0,2 	include	delay.inc
%1 	$include	(delay.inc)

DAI:
	DB	0FDH,0DBH,0D7H,00FH,0D7H
	DB	0DBH,0DDH,0FFH
	END

%}


%{dotmtx1b.a51
;
;   Display Chinese word "da" on 8*8 Mono Dot-matrix LED
;
START:
	MOV	R2,#0
	MOV	R4,#07FH
	MOV	DPTR,#DAI
LOOP:
	MOV	P1,#0FFH   ;  close common anode
	MOV	A,R2
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R2

	MOV	A,R4
	MOV	P1,A

	RR	A
	MOV	R4,A

	CJNE	R2,#8,DELAY
	MOV	R2,#0

DELAY:
	MOV	R3,#3
NEXT2:
	ACALL	DELAY1MS
	DJNZ	R3,NEXT2

	AJMP  LOOP

%0,2 	include	delay.inc
%1 	$include	(delay.inc)

DAI:
	DB	0FDH,0DBH,0D7H,00FH,0D7H
	DB	0DBH,0DDH,0FFH
	END
%}


%{dotmtx1c.a51
;
;   Display Chinese word "da" on 8*8 Mono Dot-matrix LED
;
START:
	MOV	R4,#07FH
	MOV	DPTR,#DAI
LOOP:
	MOV	P1,#0FFH   ;  close common anode
	CLR	A
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	DPTR

	MOV	A,R4
	MOV	P1,A

	RR	A
	MOV	R4,A

	CJNE	A,#07FH,DELAY
	MOV	DPTR,#DAI

DELAY:
	MOV	R3,#3
NEXT2:
	ACALL 	DELAY1MS
	DJNZ	R3,NEXT2

	AJMP	LOOP

%0,2 	include	delay.inc
%1 	$include	(delay.inc)

DAI:
	DB	0FDH,0DBH,0D7H,00FH,0D7H
	DB	0DBH,0DDH,0FFH
	END
%}


@1
%{dotmtx1a.c
//
//   Display Chinese word "da" on 8*8 Mono Dot-matrix LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code dai[]= { 0xfd,0xdb,0xd7,0x0f,0xd7,0xdb,0xdd,0xff} ;
delay3ms()
{
	Delay1ms() ;
	Delay1ms() ;
	Delay1ms() ;
}
main()
{
	unsigned char com ,idx;

	com=0x80 ;
	idx=0 ;
	for( ;;){
	    P1=0xff ;
	    P0=dai[idx++] ;
	    P1=~com ;
	    com >>=1 ;
	    if(idx==8){
   		idx=0;
		com=0x80 ;
	    }
	    delay3ms() ;
	}
}
%}


@1
%{dotmtx1b.c
//
//   Display Chinese word "da" on 8*8 Mono Dot-matrix LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code dai[]= { 0xfd,0xdb,0xd7,0x0f,0xd7,0xdb,0xdd,0xff} ;
delay3ms()
{
	Delay1ms() ;
	Delay1ms() ;
	Delay1ms() ;
}
main()
{
	unsigned char com ;
	unsigned char code *ptr =dai;


	com=0x80 ;
	for( ;;){
	    P1=0xff ;
	    P0=*ptr++ ;
	    P1=~com ;
	    com >>=1 ;
	    if(com==0){
		com=0x80 ;
		ptr= dai ;
	    }
	    delay3ms() ;
	}
}
%}


%{dotmtx2a.a51
;
;   Display Chinese word "da" (three color) on 8*8 Color Dot-matrix LED
;
INTERVAL	EQU	25
INTERVAL1	EQU	INTERVAL*1
INTERVAL2	EQU	INTERVAL*2
INTERVAL3	EQU	INTERVAL*3

START:
	MOV	R2,#0      ;idx
	MOV	R4,#07FH   ;com
	MOV	R5,#0      ;interval
	MOV	R6,#0      ;color
	MOV	DPTR,#DAI
LOOP:
	MOV	P1,#0FFH   ;  close common anode
	CJNE	R6,#0,CHKCOLOR1
	SJMP	CHKCOLOR2
CHKCOLOR1:
	CJNE	R6,#2,CHKCOLOR3
CHKCOLOR2:
	MOV	A,R2
	MOVC	A,@A+DPTR
	MOV	P0,A
	SJMP	CHKCOLOR4
CHKCOLOR3:
	MOV	P0,#0FFH
CHKCOLOR4:

	CJNE	R6,#1,CHKCOLOR5
	SJMP	CHKCOLOR6
CHKCOLOR5:
	CJNE	R6,#2,CHKCOLOR7
CHKCOLOR6:
	MOV	A,R2
	MOVC	A,@A+DPTR
	MOV	P2,A
	SJMP	CHKCOLOR8
CHKCOLOR7:
	MOV	P2,#0FFH
CHKCOLOR8:
	INC	R2

	MOV	A,R4
	MOV	P1,A

	RR	A
	MOV	R4,A



	CJNE	R2,#8,CHKINTERVAL
	MOV	R2,#0
	INC	R5

CHKINTERVAL:
	CJNE	R5,#INTERVAL1,CHKINTERVAL1
	MOV	R6,#1
	SJMP	DELAY
CHKINTERVAL1:
	CJNE	R5,#INTERVAL2,CHKINTERVAL2
	MOV	R6,#2
	SJMP	DELAY
CHKINTERVAL2:
	CJNE	R5,#INTERVAL3,DELAY
	MOV	R5,#0
	MOV	R6,#0

DELAY:
	MOV	R3,#3
NEXT2:
	ACALL	DELAY1MS
	DJNZ	R3,NEXT2

	AJMP	LOOP
%0,2 	include	delay.inc
%1 	$include	(delay.inc)

DAI:
	DB	0FDH,0DBH,0D7H,00FH,0D7H
	DB	0DBH,0DDH,0FFH
	END
%}


%{dotmtx2b.a51
;
;   Display Chinese word "da" (three color) on 8*8 Color Dot-matrix LED
;
BASEINT	EQU	25
INTERVAL1	EQU	BASEINT*1
INTERVAL2	EQU	BASEINT*2
INTERVAL3	EQU	BASEINT*3
IDX	REGEQU	R2
COM	REGEQU	R4
INTERVAL	REGEQU	R5
COLOR	REGEQU	R6
DELAYCNT	REGEQU	R3

START:
	MOV	IDX,#0
	MOV	COM,#07FH
	MOV	INTERVAL,#0
	MOV	COLOR,#0
	MOV	DPTR,#DAI
LOOP:
	MOV	P1,#0FFH   ;  close common anode
	CJNE	COLOR,#0,CHKCOLOR1
	SJMP	CHKCOLOR2
CHKCOLOR1:
	CJNE	COLOR,#2,CHKCOLOR3
CHKCOLOR2:
	MOV	A,IDX
	MOVC	A,@A+DPTR
	MOV	P0,A
	SJMP	CHKCOLOR4
CHKCOLOR3:
	 MOV	P0,#0FFH
CHKCOLOR4:

	CJNE	COLOR,#1,CHKCOLOR5
	SJMP	CHKCOLOR6
CHKCOLOR5:
	CJNE	COLOR,#2,CHKCOLOR7
CHKCOLOR6:
	MOV	A,IDX
	MOVC	A,@A+DPTR
	MOV	P2,A
	SJMP	CHKCOLOR8
CHKCOLOR7:
	MOV	P2,#0FFH
CHKCOLOR8:
	INC	IDX

	MOV	A,COM
	MOV	P1,A

	RR	A
	MOV	COM,A



	CJNE	IDX,#8,CHKINTERVAL
	MOV	IDX,#0
	INC	INTERVAL

CHKINTERVAL:
	CJNE	INTERVAL,#INTERVAL1,CHKINTERVAL1
	MOV	COLOR,#1
	SJMP	DELAY
CHKINTERVAL1:
	CJNE	INTERVAL,#INTERVAL2,CHKINTERVAL2
	MOV	COLOR,#2
	SJMP	DELAY
CHKINTERVAL2:
	CJNE	INTERVAL,#INTERVAL3,DELAY
	MOV	INTERVAL,#0
	MOV	COLOR,#0

DELAY:
	MOV	DELAYCNT,#3
NEXT2:
	ACALL	DELAY1MS
	DJNZ	DELAYCNT,NEXT2

	AJMP	LOOP

%0,2 	include	delay.inc
%1 	$include	(delay.inc)

DAI:
	DB	0FDH,0DBH,0D7H,00FH,0D7H
	DB	0DBH,0DDH,0FFH
	END
%}


@1
%{dotmtx2.c
//
//   Display Chinese word "da" (three color) on 8*8 Color Dot-matrix LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code dai[]= { 0xfd,0xdb,0xd7,0x0f,0xd7,0xdb,0xdd,0xff} ;
#define BASEINT	25
#define INTERVAL1	BASEINT*1
#define INTERVAL2	BASEINT*2
#define INTERVAL3	BASEINT*3
delay3ms()
{
	Delay1ms() ;
	Delay1ms() ;
	Delay1ms() ;
}
main()
{
	char idx ;
	unsigned char com ;
	unsigned int interval ;
	unsigned char color ;
	idx=0 ;
	com=0x80 ;
	interval=0 ;
	color=0 ;
	for( ; ;){
	    P1=0xff ;
	    if((color== 0) || (color== 2)){
 		P0=dai[idx] ;
	    }
	    else{
		P0=0xff ;
	    }
	    if((color == 1) || (color== 2)){
		P2=dai[idx] ;
	    }
	    else{
		P2=0xff ;
	    }
	    idx++ ;
	    P1=~com ;
	    com >>=1 ;
	    if(idx >=8){
		interval++ ;
		idx=0 ;
		com=0x80 ;
	    }
	    if(interval ==  INTERVAL1){
		color=1 ;
	    }
	    else if(interval == INTERVAL2){
		color=2 ;
	    }
	    else if(interval == INTERVAL3){
		interval=0 ;
		color=0 ;
	    }
	    delay3ms() ;
	}
}
%}


%{dotmtx3.a51
;
;   Display Chinese word "huan" (three color) on 16*16 Color Dot-matrix LED
;
BASEINT	EQU	25
INTERVAL1	EQU	BASEINT*1
INTERVAL2	EQU	BASEINT*2
INTERVAL3	EQU	BASEINT*3

IDX	REGEQU	R2
INTERVAL	REGEQU	R5
COLOR	REGEQU	R6
CTRLLED	REGEQU	P2.0
LRED1	REGEQU	P1.4
LGREEN1	REGEQU	P1.5
LRED2	REGEQU	P1.6
LGREEN2	REGEQU	P1.7

START:
	MOV	IDX,#0
	MOV	INTERVAL,#0
	MOV	COLOR,#0
	MOV	DPTR,#HWAN
LOOP:
	SETB	CTRLLED
	CJNE	COLOR,#0,CHKCOLOR1
	SJMP	CHKCOLOR2
CHKCOLOR1:
	CJNE	COLOR,#2,CHKCOLOR3
CHKCOLOR2:
	MOV	A,IDX
	ADD	A,ACC
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	LRED1
	SETB	LRED1

	MOV	A,IDX
	ADD	A,ACC
	INC	A
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	LRED2
	SETB	LRED2
	SJMP	CHKCOLOR4
CHKCOLOR3:
	MOV	P0,#0FFH
	CLR	LRED1
	SETB	LRED1
	CLR	LRED2
	SETB	LRED2
CHKCOLOR4:

	CJNE	COLOR,#1,CHKCOLOR5
	SJMP	CHKCOLOR6
CHKCOLOR5:
	CJNE	COLOR,#2,CHKCOLOR7
CHKCOLOR6:
	MOV	A,IDX
	ADD	A,ACC
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	LGREEN1
	SETB	LGREEN1

	MOV	A,IDX
	ADD	A,ACC
	INC	A
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	LGREEN2
	SETB	LGREEN2
	SJMP	CHKCOLOR8
CHKCOLOR7:
	MOV	P0,#0FFH
	CLR	LGREEN1
	SETB	LGREEN1
	CLR	LGREEN2
	SETB	LGREEN2
CHKCOLOR8:
	MOV	A,P1
	ANL	A,#0F0H
	ORL	A,IDX
	MOV	P1,A
	CLR	CTRLLED

	INC	IDX

	CJNE	IDX,#16,CHKINTERVAL
	MOV	IDX,#0
	INC	INTERVAL

CHKINTERVAL:
	CJNE	INTERVAL,#INTERVAL1,CHKINTERVAL1
	MOV	COLOR,#1
	SJMP	DELAY
CHKINTERVAL1:
	CJNE	INTERVAL,#INTERVAL2,CHKINTERVAL2
	MOV	COLOR,#2
	SJMP	DELAY
CHKINTERVAL2:
	CJNE	INTERVAL,#INTERVAL3,DELAY
	MOV	INTERVAL,#0
	MOV	COLOR,#0

DELAY:
	ACALL	DELAY1MS

	AJMP	LOOP

%0,2 	include	delay.inc
%1 	$include	(delay.inc)

HWAN:
	DB	0FFH,0FFH
	DB	0DFH,0EFH
	DB	0D1H,09FH
	DB	084H,000H
	DB	0D1H,055H
	DB	0DEH,055H
	DB	0D1H,001H
	DB	085H,055H
	DB	0D1H,055H
	DB	0DEH,0FEH
	DB	0F9H,0F9H
	DB	087H,0E7H
	DB	0B4H,01FH
	DB	0F7H,0E7H
	DB	0F5H,0F9H
	DB	0E3H,0FEH
	END
%}


@1
%{dotmtx3.c
//
//   Display Chinese word "huan" (three color) on 16*16 Color Dot-matrix LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code hwan[]= {
	0xFF,0xFF,
	0xDF,0xEF,
	0xD1,0x9F,
	0x84,0x00,
	0xD1,0x55,
	0xDE,0x55,
	0xD1,0x01,
	0x85,0x55,
	0xD1,0x55,
	0xDE,0xFE,
	0xF9,0xF9,
	0x87,0xE7,
	0xB4,0x1F,
	0xF7,0xE7,
	0xF5,0xF9,
	0xE3,0xFE,
} ;
sbit CTRLLED= P2^0 ;
sbit LRED1=P1^4 ;
sbit LGREEN1=P1^5 ;
sbit LRED2=P1^6 ;
sbit LGREEN2=P1^7 ;
#define BASEINT	25
#define INTERVAL1	BASEINT*1
#define INTERVAL2	BASEINT*2
#define INTERVAL3	BASEINT*3
main()
{
	char idx ;
	unsigned int interval ;
	unsigned char color ;
	idx=0 ;
	interval=0 ;
	color=0 ;
	for( ; ;){
	    CTRLLED=1 ;
	    if((color== 0) || (color== 2)){
 		P0=hwan[idx*2] ;
		LRED1=0 ;
		LRED1=1 ;
		P0=hwan[idx*2+1] ;
		LRED2=0 ;
		LRED2=1 ;
	    }
	    else{
		P0=0xff ;
		LRED1=0 ;
		LRED1=1 ;
		LRED2=0 ;
		LRED2=1 ;
	    }
	    if((color == 1) || (color== 2)){
 		P0=hwan[idx*2] ;
		LGREEN1=0 ;
		LGREEN1=1 ;
		P0=hwan[idx*2+1] ;
		LGREEN2=0 ;
		LGREEN2=1 ;
	    }
	    else{
		P0=0xff ;
		LGREEN1=0 ;
		LGREEN1=1 ;
		LGREEN2=0 ;
		LGREEN2=1 ;
	    }
	    P1 &=0xf0 ;
	    P1 |=idx ;
	    CTRLLED=0 ;
	    idx++ ;
	    if(idx >=16){
		interval++ ;
		idx=0 ;
	    }
	    if(interval ==  INTERVAL3){
		interval=0 ;
		color=0 ;
	    }
	    else if(interval == INTERVAL2){
		color=2 ;
	    }
	    else if(interval == INTERVAL1){
		color=1 ;
	    }
 	    Delay1ms() ;
	}
}
%}


%{dotmtx4.a51
;
;   Display Chinese word on 16*16 Color Dot-matrix LED,
; sequence by Chinese word "huan"(red),Chinese word "ying"(green),
;    Chinese word "can"(orange) , Chinese word "guan"(red)
;
BASEINT	EQU	25
INTERVAL1	EQU	BASEINT*1
INTERVAL2	EQU	BASEINT*2
INTERVAL3	EQU	BASEINT*3
INTERVAL4	EQU	BASEINT*4

IDX	REGEQU	R2
INTERVAL	REGEQU	R5
COLOR	REGEQU	R6
WOFFSET	REGEQU	R4
CTRLLED	REGEQU	P2.0
LRED1	REGEQU	P1.4
LGREEN1	REGEQU	P1.5
LRED2	REGEQU	P1.6
LGREEN2	REGEQU	P1.7

START:
	MOV	IDX,#0
	MOV	WOFFSET,#0
	MOV	INTERVAL,#0
	MOV	COLOR,#0
	MOV	DPTR,#HWAN
LOOP:
	SETB	CTRLLED
	CJNE	COLOR,#0,CHKCOLOR1
	SJMP	CHKCOLOR2
CHKCOLOR1:
	CJNE	COLOR,#2,CHKCOLOR3
CHKCOLOR2:
	MOV	A,IDX
	ADD	A,ACC
	ADD	A,WOFFSET
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	   LRED1
	SETB	LRED1

	MOV	A,IDX
	ADD	A,ACC
	ADD	A,WOFFSET
	INC	A
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	LRED2
	SETB	LRED2
	SJMP	CHKCOLOR4
CHKCOLOR3:
	MOV	P0,#0FFH
	CLR	LRED1
	SETB	LRED1
	CLR	LRED2
	SETB	LRED2
CHKCOLOR4:

	CJNE	COLOR,#1,CHKCOLOR5
	SJMP	CHKCOLOR6
CHKCOLOR5:
	CJNE	COLOR,#2,CHKCOLOR7
CHKCOLOR6:
	MOV	A,IDX
	ADD	A,ACC
	ADD	A,WOFFSET
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	LGREEN1
	SETB	LGREEN1

	MOV	A,IDX
	ADD	A,ACC
	ADD	A,WOFFSET
	INC	A
	MOVC	A,@A+DPTR
	MOV	P0,A
	CLR	LGREEN2
	SETB	LGREEN2
	SJMP	CHKCOLOR8
CHKCOLOR7:
	MOV	P0,#0FFH
	CLR	LGREEN1
	SETB	LGREEN1
	CLR	LGREEN2
	SETB	LGREEN2
CHKCOLOR8:
	MOV	A,P1
	ANL	A,#0F0H
	ORL	A,IDX
	MOV	P1,A
	CLR	CTRLLED

	INC	IDX

	CJNE	IDX,#16,CHKINTERVAL
	MOV	IDX,#0
	INC	INTERVAL

CHKINTERVAL:
	CJNE	INTERVAL,#INTERVAL1,CHKINTERVAL1
	MOV	COLOR,#1
	MOV	WOFFSET,#1*32
	SJMP	DELAY
CHKINTERVAL1:
	CJNE	INTERVAL,#INTERVAL2,CHKINTERVAL2
	MOV	COLOR,#2
	MOV	WOFFSET,#2*32
	SJMP	DELAY
CHKINTERVAL2:
	CJNE	INTERVAL,#INTERVAL3,CHKINTERVAL3
	MOV	COLOR,#0
	MOV	WOFFSET,#3*32
	SJMP	DELAY
CHKINTERVAL3:
	CJNE	INTERVAL,#INTERVAL4,DELAY
	MOV	INTERVAL,#0
	MOV	COLOR,#0
	MOV	WOFFSET,#0

DELAY:
	ACALL	DELAY1MS
	AJMP	LOOP

%0,2 	include	delay.inc
%1 	$include	(delay.inc)

HWAN:
	DB	0FFH,0FFH         ;'huan'
	DB	0DFH,0EFH
	DB	0D1H,09FH
	DB	084H,000H
	DB	0D1H,055H
	DB	0DEH,055H
	DB	0D1H,001H
	DB	085H,055H
	DB	0D1H,055H
	DB	0DEH,0FEH
	DB	0F9H,0F9H
	DB	087H,0E7H
	DB	0B4H,01FH
	DB	0F7H,0E7H
	DB	0F5H,0F9H
	DB	0E3H,0FEH

	DB	0FFH,0FFH             ;'ying'
	DB	0F7H,0BEH
	DB	0BBH,0B9H
	DB	0DBH,007H
	DB	0DFH,0BBH
	DB	0FFH,0DDH
	DB	080H,00DH
	DB	0DFH,0DEH
	DB	0BFH,0BEH
	DB	0BFH,07EH
	DB	0FFH,0FEH
	DB	080H,002H
	DB	0DFH,0DEH
	DB	0DFH,0CEH
	DB	080H,01DH
	DB	0DFH,0FDH


	DB	0FFH,0FFH             ;'can'
	DB	0FDH,0BFH
	DB	0FCH,0ABH
	DB	0E9H,0AAH
	DB	0E5H,06AH
	DB	0EDH,056H
	DB	08BH,055H
	DB	0ACH,0B5H
	DB	0EEH,0ADH
	DB	0ADH,06BH
	DB	0D9H,05BH
	DB	0E5H,057H
	DB	0FDH,0B7H
	DB	0FBH,0BFH
	DB	0FCH,0BFH
	DB	0FFH,0BFH


	DB	0FFH,0FFH       ;'guan'
	DB	0D1H,0DFH
	DB	085H,000H
	DB	0D0H,055H
	DB	0DFH,055H
	DB	0D1H,001H
	DB	084H,055H
	DB	0D1H,055H
	DB	0FFH,0FEH
	DB	080H,01DH
	DB	0D6H,0C3H
	DB	0D6H,0DFH
	DB	0D6H,0C1H
	DB	080H,01EH
	DB	0DFH,0F0H
	DB	0FFH,0FDH


	END
%}


@1
%{dotmtx4.c
//
//   Display Chinese word on 16*16 Color Dot-matrix LED,
//  sequence by Chinese word "huan"(red),Chinese word "ying"(green),
//    Chinese word "can"(orange) , Chinese word "guan"(red)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code hwan[]= {
	0xFF,0xFF,              //'huan'
	0xDF,0xEF,
	0xD1,0x9F,
	0x84,0x00,
	0xD1,0x55,
	0xDE,0x55,
	0xD1,0x01,
	0x85,0x55,
	0xD1,0x55,
	0xDE,0xFE,
	0xF9,0xF9,
	0x87,0xE7,
	0xB4,0x1F,
	0xF7,0xE7,
	0xF5,0xF9,
	0xE3,0xFE,

	0xFF,0xFF,              //'ying'
	0xF7,0xBE,
	0xBB,0xB9,
	0xDB,0x07,
	0xDF,0xBB,
	0xFF,0xDD,
	0x80,0x0D,
	0xDF,0xDE,
	0xBF,0xBE,
	0xBF,0x7E,
	0xFF,0xFE,
	0x80,0x02,
	0xDF,0xDE,
	0xDF,0xCE,
	0x80,0x1D,
	0xDF,0xFD,


	0xFF,0xFF,              //'can'
	0xFD,0xBF,
	0xFC,0xAB,
	0xE9,0xAA,
	0xE5,0x6A,
	0xED,0x56,
	0x8B,0x55,
	0xAC,0xB5,
	0xEE,0xAD,
	0xAD,0x6B,
	0xD9,0x5B,
	0xE5,0x57,
	0xFD,0xB7,
	0xFB,0xBF,
	0xFC,0xBF,
	0xFF,0xBF,


	0xFF,0xFF,        //'guan'
	0xD1,0xDF,
	0x85,0x00,
	0xD0,0x55,
	0xDF,0x55,
	0xD1,0x01,
	0x84,0x55,
	0xD1,0x55,
	0xFF,0xFE,
	0x80,0x1D,
	0xD6,0xC3,
	0xD6,0xDF,
	0xD6,0xC1,
	0x80,0x1E,
	0xDF,0xF0,
	0xFF,0xFD,

} ;
sbit CTRLLED= P2^0 ;
sbit LRED1=P1^4 ;
sbit LGREEN1=P1^5 ;
sbit LRED2=P1^6 ;
sbit LGREEN2=P1^7 ;
#define BASEINT	25
#define INTERVAL1	BASEINT*1
#define INTERVAL2	BASEINT*2
#define INTERVAL3	BASEINT*3
#define INTERVAL4	BASEINT*4
main()
{
	char idx ;
	unsigned int interval ;
	unsigned char color ;
	unsigned char woffset ;
	idx=0 ;
	woffset=0 ;
	interval=0 ;
	color=0 ;
	for( ; ;){
	    CTRLLED=1 ;
	    if((color== 0) || (color== 2)){
 		P0=hwan[woffset+idx*2] ;
		LRED1=0 ;
		LRED1=1 ;
		P0=hwan[woffset+idx*2+1] ;
		LRED2=0 ;
		LRED2=1 ;
	    }
	    else{
		P0=0xff ;
		LRED1=0 ;
		LRED1=1 ;
		LRED2=0 ;
		LRED2=1 ;
	    }
	    if((color == 1) || (color== 2)){
 		P0=hwan[woffset+idx*2] ;
		 LGREEN1=0 ;
		LGREEN1=1 ;
		P0=hwan[woffset+idx*2+1] ;
		LGREEN2=0 ;
		LGREEN2=1 ;
	    }
	    else{
		P0=0xff ;
		LGREEN1=0 ;
		LGREEN1=1 ;
		LGREEN2=0 ;
		LGREEN2=1 ;
	    }

	    P1 &=0xf0 ;
	    P1 |=(idx &0xf);
	    CTRLLED=0 ;
	    idx++ ;
	    if(idx ==16){
		interval++ ;
		idx=0 ;
	    }
	    if(interval ==  INTERVAL1){
		color=1 ;
		woffset=1*32 ;
	    }
	    else if(interval == INTERVAL2){
		color=2 ;
		woffset=2*32 ;
	    }
	    else if(interval == INTERVAL3){
		color=0 ;
		woffset=3*32 ;
	    }
	    else if(interval == INTERVAL4){
		interval=0 ;
		color=0 ;
		woffset=0 ;
	    }
	    Delay1ms() ;
	}
}
%}


@1
%{dotmtx71.c
//
//   Display Chinese word "da" on 5*7 Mono Dot-matrix LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code dai[]= { 0x6d,0x6b,0x07,0x6b,0x6d} ;
delay3ms()
{
	Delay1ms() ;
	Delay1ms() ;
	Delay1ms() ;
}
main()
{
	unsigned char com ,idx;

	com=0x10 ;
	idx=0 ;
	for( ;;){
	    P1=0xff ;
	    P0=dai[idx++] ;
	    P1=~com ;
	    com >>=1 ;
	    if(idx==5){
		idx=0;
		com=0x10 ;
	    }
	    delay3ms() ;
	}
}
%}


@1
%{e93c461.c
//
//   Read the content of 93C46 at address 00
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit EEPROMCS=P0 ^0 ;
sbit EEPROMSK=P0 ^1 ;
sbit EEPROMDI=P0 ^2 ;
sbit EEPROMDO=P0 ^3 ;
#define CLOCK  EEPROMSK=0 ; EEPROMSK=1 ;
#define SEND(DI)   EEPROMDI=DI ;CLOCK ;
main()
{
	unsigned int Data ;
	unsigned char i ;

	P0=0xff ;
	//  Setting CS,SK to initial state
EEPROMCS=0 ;
EEPROMSK=0 ;


	EEPROMCS=1 ;
	// start bit
	SEND(1) ;
	// command  10
	SEND(1) ; SEND(0) ;
	// address 000000
	for(i=0 ; i < 6 ; i++){
	    SEND(0) ;
	}
	if(EEPROMDO==0){
	    Data=0 ;
	    for(i=0 ; i < 16 ; i++){
		CLOCK ;
		Data <<=1 ;
		if(EEPROMDO== 1){
		    Data++ ;
		}
	    }
	}
	EEPROMCS=0 ;
	for(;;) ;
}
%}


@1
%{e93c462.c
//
//   Write the value (5678h) to  93C46 at address 00
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit EEPROMCS=P0 ^0 ;
sbit EEPROMSK=P0 ^1 ;
sbit EEPROMDI=P0 ^2 ;
sbit EEPROMDO=P0 ^3 ;
#define CLOCK  EEPROMSK=0 ; EEPROMSK=1 ;
#define SEND(DI)   EEPROMDI=DI ;CLOCK ;
main()
{
	unsigned int Data ;
	unsigned char i ;
	P0=0xff ;
	//  Setting CS,SK to initial state
EEPROMCS=0 ;
EEPROMSK=0 ;

	// write enable
	EEPROMCS=1 ;
	// start bit
	SEND(1) ;
	// command  00
	SEND(0) ; SEND(0) ;
	// sub-command 11
	SEND(1) ; SEND(1) ;
	// 4-'X' Bit
	for(i=0 ; i < 4 ; i++){
	    SEND(0) ;
	}
	EEPROMCS=0 ;


	//  Write the value (5678h) to  93C46 at address 00
	EEPROMCS=1 ;
	// start bit
	SEND(1) ;
	// command  01
	SEND(0) ; SEND(1) ;
	// address 000000
	for(i=0 ; i < 6 ; i++){
	    SEND(0) ;
	}
	// send out data
	Data=0x5678 ;
	for(i=0 ; i < 16 ; i++){
	    if(Data & 0x8000){
		SEND(1) ;
	    }
	    else{
		SEND(0) ;
	    }
	    Data <<=1 ;
	}
	EEPROMCS=0 ;
	// wait ready
	EEPROMCS=1 ;
	while(!EEPROMDO){
	    CLOCK ;
	}
	for(;;) ;
}
%}


@1
%{e93c661.c
//
//   Read the content of 93C66 at address 00
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit EEPROMCS=P0 ^0 ;
sbit EEPROMSK=P0 ^1 ;
sbit EEPROMDI=P0 ^2 ;
sbit EEPROMDO=P0 ^3 ;
#define CLOCK  EEPROMSK=0 ; EEPROMSK=1 ;
#define SEND(DI)   EEPROMDI=DI ;CLOCK ;
main()
{
	unsigned int Data ;
	unsigned char i ;

	P0=0xff ;
	//  Setting CS,SK to initial state
EEPROMCS=0 ;
EEPROMSK=0 ;

	EEPROMCS=1 ;
	// start bit
	SEND(1) ;
	// command  10
	SEND(1) ; SEND(0) ;
	// address 00000000
	for(i=0 ; i < 8 ; i++){
	    SEND(0) ;
	}
	if(EEPROMDO==0){
	    Data=0 ;
	    for(i=0 ; i < 16 ; i++){
		CLOCK ;
		Data <<=1 ;
		if(EEPROMDO== 1){
		    Data++ ;
		}
	    }
	}
	EEPROMCS=0 ;
	for(;;) ;
}
%}


@1
%{e93c662.c
//
//   Write the value (5678h) to  93C66 at address 00
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit EEPROMCS=P0 ^0 ;
sbit EEPROMSK=P0 ^1 ;
sbit EEPROMDI=P0 ^2 ;
sbit EEPROMDO=P0 ^3 ;
#define CLOCK  EEPROMSK=0 ; EEPROMSK=1 ;
#define SEND(DI)   EEPROMDI=DI ;CLOCK ;
main()
{
	unsigned int Data ;
	unsigned char i ;

	P0=0xff ;
	//  Setting CS,SK to initial state
EEPROMCS=0 ;
EEPROMSK=0 ;

	// write enable
	EEPROMCS=1 ;
	// start bit
	SEND(1) ;
	// command  00
	SEND(0) ; SEND(0) ;
	// sub-command 11
	SEND(1) ; SEND(1) ;
	// 6-'X' Bit
	for(i=0 ; i < 6 ; i++){
	    SEND(0) ;
	}
	EEPROMCS=0 ;


	//  Write the value (5678h) to  93C66 at address 00
	EEPROMCS=1 ;
	// start bit
	SEND(1) ;
	// command  01
	SEND(0) ; SEND(1) ;
	// address 00000000
	for(i=0 ; i < 8 ; i++){
	    SEND(0) ;
	}
	// send out data
	Data=0x5678 ;
	for(i=0 ; i < 16 ; i++){
	    if(Data & 0x8000){
		SEND(1) ;
	    }
	    else{
		SEND(0) ;
	    }
	    Data <<=1 ;
	}
	EEPROMCS=0 ;
	// wait ready
	EEPROMCS=1 ;
	while(!EEPROMDO){
	    CLOCK ;
	}
	for(;;) ;
}
%}


%{glcd1.a51
;
;   Display a horizontal line (at top)  on Graphic LCD
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
DI	REGEQU	P1.0
CS1	REGEQU	P1.3
CS2	REGEQU	P1.4

START:
	SETB	CS1
	SETB	CS2
	ACALL	DELAY5MS
	MOV	A,#0111111B  ; wait for LCD Power-on Ready & Display ON
	ACALL	COMMAND

	MOV	A,#010111000B   ;³]©wX addr=0
	ACALL	COMMAND
	MOV	A,#001000000B   ;³]©wY addr=0
	ACALL	COMMAND
	MOV	R0,#64
LOOP:
	MOV	A,#01H
	ACALL	SDATA
	DJNZ	R0,LOOP
	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	DI
	CLR	E
	SETB	RW
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	DI
	CLR	E
	SETB	RW
WAITLCD:
	MOV	P0,#0FFH  ; P0 set to input port
WAITLCD1:
	CLR	DI
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


@1
%{glcd1.c
//
//   Display a horizontal line (at top)  on Graphic LCD
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit DI=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
sbit CS1=P1^3 ;
sbit CS2=P1^4 ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0 set to input port
	do{
  	    DI=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0

}
void Command(cmd){
	P0=cmd ;
	DI=0 ;RW=0; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	DI=1 ;RW=0; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
main()
{
	unsigned char i ;

	CS1=CS2=1 ;
	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // DISPLAY ON

	Command(0xb8+0) ; // X addr = 0 ;
	Command(0x40+0) ; // Y Addr= 0 ;

	for(i=0; i< 64  ;i++){
	    Data(0x01);
	}
	for(;;) ;
}
%}


%{glcd2.a51
;
;   Display Chinese word "huan ying can guan" on Graphic LCD
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
DI	REGEQU	P1.0
CS1	REGEQU	P1.3
CS2	REGEQU	P1.4
Y	REGEQU	R0
SPAGE	REGEQU	R1
IDX	REGEQU	R2

START:
	SETB	CS1
	SETB	CS2
	ACALL	DELAY5MS
	MOV	A,#0111111B  ; wait for LCD Power-on Ready & Display ON
	ACALL	COMMAND

	SETB	CS1
	CLR	CS2
	MOV	DPTR,#HWAN
	ACALL	FILLHWAN
	CLR	CS1
	SETB	CS2
	ACALL	FILLHWAN
	SJMP	$
FILLHWAN:
	MOV	Y,#0
NEXT3:
	MOV	SPAGE,#0
NEXT2:
	MOV	A,#010111000b
	ORL	A,SPAGE
	ACALL	COMMAND
	MOV	A,#001000000B
	ORL	A,Y
	ACALL	COMMAND
	MOV	IDX,#32
NEXT1:
	CLR	A
	MOVC	A,@A+DPTR
	ACALL	SDATA
	INC	DPTR
	DJNZ	IDX,NEXT1
	INC	SPAGE
	CJNE	SPAGE,#8,NEXT2
	MOV	A,Y
	ADD	A,#32
	MOV	Y,A
	CJNE	A,#64,NEXT3
	RET
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	DI
	CLR	E
	SETB	RW
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	DI
	CLR	E
	SETB	RW
WAITLCD:
	MOV	P0,#0FFH  ; P0 set to input port
WAITLCD1:
	CLR	DI
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

HWAN:
                                                      ;'huan'(font 1)
      DB    000H,008H,048H,088H,088H,088H,0FEH,0BEH
      DB    0CAH,088H,0C8H,088H,0BEH,0BEH,08AH,088H
      DB    0CCH,08CH,088H,000H,0E0H,0FEH,086H,086H
      DB    080H,080H,080H,080H,0C0H,0C0H,080H,000H
      DB    000H,000H,000H,01FH,01FH,0E8H,068H,068H
      DB    01FH,00FH,080H,0FFH,06FH,048H,008H,088H
      DB    09FH,01FH,018H,006H,001H,000H,0FCH,0FCH
      DB    004H,000H,010H,00EH,003H,000H,000H,000H
      DB    010H,008H,00CH,006H,0FFH,0FFH,089H,089H
      DB    089H,089H,0FFH,0FFH,089H,089H,0CDH,0CDH
      DB    089H,001H,000H,000H,080H,0F0H,03FH,003H
      DB    00FH,070H,0C0H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,03FH,03FH,008H,008H
      DB    008H,008H,00FH,00FH,008H,008H,008H,02CH
      DB    01CH,018H,00CH,006H,003H,000H,000H,000H
      DB    000H,000H,001H,007H,00EH,01CH,018H,010H
                                                      ;'ying' (font 1)
      DB    000H,080H,080H,002H,004H,004H,00CH,018H
      DB    010H,000H,004H,0F8H,0F8H,008H,008H,00CH
      DB    006H,006H,004H,000H,0FCH,0F8H,008H,008H
      DB    008H,008H,008H,008H,0FCH,0FCH,00CH,000H
      DB    000H,000H,000H,001H,003H,006H,086H,080H
      DB    000H,000H,000H,0FFH,0FFH,000H,000H,000H
      DB    000H,000H,000H,000H,0FFH,0FFH,000H,000H
      DB    000H,000H,000H,000H,0FFH,0FFH,000H,000H
      DB    000H,001H,001H,001H,001H,001H,0FFH,0FFH
      DB    001H,060H,0E0H,07FH,03FH,010H,018H,008H
      DB    004H,004H,002H,000H,0FFH,0FFH,000H,010H
      DB    010H,010H,070H,030H,03FH,01FH,000H,000H
      DB    000H,008H,038H,00CH,006H,002H,001H,002H
      DB    004H,004H,008H,008H,008H,018H,018H,010H
      DB    010H,010H,010H,010H,013H,013H,010H,010H
      DB    010H,010H,018H,018H,018H,018H,008H,000H
                                                      ;'can' (font 1)
      DB    000H,000H,000H,000H,000H,0E0H,060H,060H
      DB    060H,020H,030H,038H,02CH,027H,022H,022H
      DB    020H,020H,020H,028H,024H,018H,098H,0B0H
      DB    070H,060H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,070H,030H,030H,038H,01EH,017H
      DB    013H,012H,094H,0CCH,078H,030H,038H,01CH
      DB    08CH,018H,030H,070H,050H,09CH,097H,013H
      DB    011H,008H,00AH,00CH,038H,010H,000H,000H
      DB    000H,010H,008H,008H,044H,044H,026H,022H
      DB    023H,031H,010H,018H,088H,08CH,086H,043H
      DB    063H,021H,031H,018H,01CH,008H,009H,081H
      DB    0E3H,0C2H,0C6H,006H,00CH,004H,004H,000H
      DB    000H,000H,000H,020H,022H,022H,022H,022H
      DB    022H,023H,011H,011H,011H,010H,008H,008H
      DB    008H,004H,004H,006H,002H,003H,001H,001H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
                                                      ;'guan' (font 1)
      DB    000H,010H,090H,090H,010H,07EH,07EH,096H
      DB    090H,090H,090H,07EH,03EH,016H,090H,098H
      DB    010H,002H,0FCH,0FCH,004H,004H,004H,004H
      DB    004H,004H,004H,0FCH,0FEH,00CH,000H,000H
      DB    000H,000H,01FH,01FH,009H,0E9H,049H,05FH
      DB    01FH,01FH,0DFH,049H,049H,009H,01FH,01FH
      DB    001H,000H,0FFH,0FFH,021H,021H,021H,021H
      DB    021H,021H,021H,0FFH,0FFH,000H,000H,000H
      DB    000H,010H,008H,006H,0FFH,0FFH,092H,092H
      DB    092H,0FEH,0FFH,092H,092H,0DBH,0DBH,092H
      DB    000H,000H,01FH,01FH,0C4H,0FCH,00CH,004H
      DB    0FCH,0FCH,004H,01FH,01FH,080H,000H,000H
      DB    000H,000H,000H,000H,03FH,03FH,008H,008H
      DB    008H,00FH,00FH,008H,008H,008H,00CH,02CH
      DB    030H,010H,00CH,006H,003H,000H,000H,000H
      DB    01FH,01FH,010H,010H,010H,01FH,010H,000H
                                                      ;'huan' (font 2)
      DB    000H,000H,000H,000H,080H,080H,080H,090H
      DB    0F0H,080H,000H,000H,000H,0FCH,07CH,068H
      DB    020H,020H,000H,000H,0C0H,0F8H,078H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,008H,078H,0C8H
      DB    0A6H,03DH,00CH,084H,0BCH,025H,024H,03EH
      DB    02EH,044H,030H,01EH,007H,0CDH,0C4H,004H
      DB    026H,01EH,01EH,00CH,004H,000H,000H,000H
      DB    000H,000H,020H,020H,010H,008H,006H,0FFH
      DB    093H,092H,0D2H,0FEH,0FFH,04AH,04BH,04BH
      DB    000H,000H,000H,0C0H,0F8H,01FH,00DH,030H
      DB    0E0H,080H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,00CH,01FH
      DB    004H,006H,002H,003H,003H,002H,002H,002H
      DB    006H,006H,003H,001H,000H,000H,000H,000H
      DB    000H,003H,007H,006H,006H,004H,004H,000H
                                                      ;'ying' (font 2)
      DB    000H,000H,000H,000H,000H,020H,060H,0C0H
      DB    0C0H,080H,000H,000H,000H,000H,000H,000H
      DB    080H,0E0H,078H,038H,010H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,020H,020H,030H,030H,0F8H
      DB    071H,031H,000H,000H,000H,0FFH,0FFH,001H
      DB    000H,080H,080H,000H,0FEH,0FEH,002H,081H
      DB    001H,001H,0FFH,0FFH,000H,000H,000H,000H
      DB    000H,000H,000H,0C0H,0C0H,0C0H,041H,046H
      DB    07CH,058H,0C0H,080H,080H,08FH,007H,003H
      DB    001H,000H,000H,000H,0FFH,03FH,000H,000H
      DB    003H,003H,003H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,001H,001H,003H
      DB    003H,003H,006H,006H,00FH,00EH,00EH,01EH
      DB    00EH,00EH,00EH,006H,006H,006H,002H,000H
                                                      ;'can' (font 2)
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,080H,080H,060H,060H,070H,07CH,02EH
      DB    024H,028H,0F8H,0F8H,030H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,038H,018H
      DB    01EH,01BH,009H,008H,08AH,0CEH,07CH,070H
      DB    07CH,0CEH,08FH,08DH,004H,005H,006H,00EH
      DB    00CH,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,020H,020H,010H,018H
      DB    008H,004H,026H,013H,011H,088H,0CCH,067H
      DB    033H,098H,0D0H,0C1H,003H,007H,006H,00EH
      DB    00EH,00CH,00CH,00CH,00CH,004H,004H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    020H,020H,010H,011H,009H,008H,00CH,006H
      DB    003H,003H,001H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
                                                      ;'guan' (font 2)
      DB    000H,000H,080H,080H,080H,0C0H,070H,0F0H
      DB    000H,000H,000H,0E0H,07CH,048H,060H,020H
      DB    000H,080H,080H,080H,080H,080H,080H,040H
      DB    0C0H,0C0H,080H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,038H,028H,0E4H,0B5H
      DB    01CH,024H,0C3H,0DCH,012H,092H,09EH,096H
      DB    000H,0FFH,04BH,048H,04CH,044H,064H,064H
      DB    04FH,0FFH,001H,000H,000H,000H,000H,000H
      DB    000H,020H,010H,018H,00CH,0FEH,0FBH,029H
      DB    029H,029H,0FFH,0FFH,0A5H,0A5H,0A4H,080H
      DB    000H,0CFH,0F2H,03EH,00AH,006H,0FEH,00EH
      DB    002H,007H,000H,000H,000H,080H,000H,000H
      DB    000H,000H,000H,000H,000H,01FH,01FH,003H
      DB    001H,001H,001H,001H,001H,009H,005H,007H
      DB    003H,001H,000H,000H,000H,000H,00FH,018H
      DB    018H,018H,018H,018H,018H,01FH,00EH,000H
	END
%}


@1
%{glcd2a.c
//
//   Display Chinese word "huan ying can guan" on Graphic LCD
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit DI=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
sbit CS1=P1^3 ;
sbit CS2=P1^4 ;
unsigned char code hwan[]={
//'huan' (font 1)
0x00,0x08,0x48,0x88,0x88,0x88,0xFE,0xBE,
0xCA,0x88,0xC8,0x88,0xBE,0xBE,0x8A,0x88,
0xCC,0x8C,0x88,0x00,0xE0,0xFE,0x86,0x86,
0x80,0x80,0x80,0x80,0xC0,0xC0,0x80,0x00,
0x00,0x00,0x00,0x1F,0x1F,0xE8,0x68,0x68,
0x1F,0x0F,0x80,0xFF,0x6F,0x48,0x08,0x88,
0x9F,0x1F,0x18,0x06,0x01,0x00,0xFC,0xFC,
0x04,0x00,0x10,0x0E,0x03,0x00,0x00,0x00,
0x10,0x08,0x0C,0x06,0xFF,0xFF,0x89,0x89,
0x89,0x89,0xFF,0xFF,0x89,0x89,0xCD,0xCD,
0x89,0x01,0x00,0x00,0x80,0xF0,0x3F,0x03,
0x0F,0x70,0xC0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x3F,0x3F,0x08,0x08,
0x08,0x08,0x0F,0x0F,0x08,0x08,0x08,0x2C,
0x1C,0x18,0x0C,0x06,0x03,0x00,0x00,0x00,
0x00,0x00,0x01,0x07,0x0E,0x1C,0x18,0x10,
//'ying' (font 1)
0x00,0x80,0x80,0x02,0x04,0x04,0x0C,0x18,
0x10,0x00,0x04,0xF8,0xF8,0x08,0x08,0x0C,
0x06,0x06,0x04,0x00,0xFC,0xF8,0x08,0x08,
0x08,0x08,0x08,0x08,0xFC,0xFC,0x0C,0x00,
0x00,0x00,0x00,0x01,0x03,0x06,0x86,0x80,
0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,
0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,
0x00,0x01,0x01,0x01,0x01,0x01,0xFF,0xFF,
0x01,0x60,0xE0,0x7F,0x3F,0x10,0x18,0x08,
0x04,0x04,0x02,0x00,0xFF,0xFF,0x00,0x10,
0x10,0x10,0x70,0x30,0x3F,0x1F,0x00,0x00,
0x00,0x08,0x38,0x0C,0x06,0x02,0x01,0x02,
0x04,0x04,0x08,0x08,0x08,0x18,0x18,0x10,
0x10,0x10,0x10,0x10,0x13,0x13,0x10,0x10,
0x10,0x10,0x18,0x18,0x18,0x18,0x08,0x00,
//'can' (font 1)
0x00,0x00,0x00,0x00,0x00,0xE0,0x60,0x60,
0x60,0x20,0x30,0x38,0x2C,0x27,0x22,0x22,
0x20,0x20,0x20,0x28,0x24,0x18,0x98,0xB0,
0x70,0x60,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x70,0x30,0x30,0x38,0x1E,0x17,
0x13,0x12,0x94,0xCC,0x78,0x30,0x38,0x1C,
0x8C,0x18,0x30,0x70,0x50,0x9C,0x97,0x13,
0x11,0x08,0x0A,0x0C,0x38,0x10,0x00,0x00,
0x00,0x10,0x08,0x08,0x44,0x44,0x26,0x22,
0x23,0x31,0x10,0x18,0x88,0x8C,0x86,0x43,
0x63,0x21,0x31,0x18,0x1C,0x08,0x09,0x81,
0xE3,0xC2,0xC6,0x06,0x0C,0x04,0x04,0x00,
0x00,0x00,0x00,0x20,0x22,0x22,0x22,0x22,
0x22,0x23,0x11,0x11,0x11,0x10,0x08,0x08,
0x08,0x04,0x04,0x06,0x02,0x03,0x01,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//'guan' (font 1)
0x00,0x10,0x90,0x90,0x10,0x7E,0x7E,0x96,
0x90,0x90,0x90,0x7E,0x3E,0x16,0x90,0x98,
0x10,0x02,0xFC,0xFC,0x04,0x04,0x04,0x04,
0x04,0x04,0x04,0xFC,0xFE,0x0C,0x00,0x00,
0x00,0x00,0x1F,0x1F,0x09,0xE9,0x49,0x5F,
0x1F,0x1F,0xDF,0x49,0x49,0x09,0x1F,0x1F,
0x01,0x00,0xFF,0xFF,0x21,0x21,0x21,0x21,
0x21,0x21,0x21,0xFF,0xFF,0x00,0x00,0x00,
0x00,0x10,0x08,0x06,0xFF,0xFF,0x92,0x92,
0x92,0xFE,0xFF,0x92,0x92,0xDB,0xDB,0x92,
0x00,0x00,0x1F,0x1F,0xC4,0xFC,0x0C,0x04,
0xFC,0xFC,0x04,0x1F,0x1F,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x3F,0x3F,0x08,0x08,
0x08,0x0F,0x0F,0x08,0x08,0x08,0x0C,0x2C,
0x30,0x10,0x0C,0x06,0x03,0x00,0x00,0x00,
0x1F,0x1F,0x10,0x10,0x10,0x1F,0x10,0x00,
//'huan' (font 2)
0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x90,
0xF0,0x80,0x00,0x00,0x00,0xFC,0x7C,0x68,
0x20,0x20,0x00,0x00,0xC0,0xF8,0x78,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x08,0x78,0xC8,
0xA6,0x3D,0x0C,0x84,0xBC,0x25,0x24,0x3E,
0x2E,0x44,0x30,0x1E,0x07,0xCD,0xC4,0x04,
0x26,0x1E,0x1E,0x0C,0x04,0x00,0x00,0x00,
0x00,0x00,0x20,0x20,0x10,0x08,0x06,0xFF,
0x93,0x92,0xD2,0xFE,0xFF,0x4A,0x4B,0x4B,
0x00,0x00,0x00,0xC0,0xF8,0x1F,0x0D,0x30,
0xE0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x1F,
0x04,0x06,0x02,0x03,0x03,0x02,0x02,0x02,
0x06,0x06,0x03,0x01,0x00,0x00,0x00,0x00,
0x00,0x03,0x07,0x06,0x06,0x04,0x04,0x00,
//'ying' (font 2)
0x00,0x00,0x00,0x00,0x00,0x20,0x60,0xC0,
0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x80,0xE0,0x78,0x38,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x20,0x20,0x30,0x30,0xF8,
0x71,0x31,0x00,0x00,0x00,0xFF,0xFF,0x01,
0x00,0x80,0x80,0x00,0xFE,0xFE,0x02,0x81,
0x01,0x01,0xFF,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xC0,0xC0,0xC0,0x41,0x46,
0x7C,0x58,0xC0,0x80,0x80,0x8F,0x07,0x03,
0x01,0x00,0x00,0x00,0xFF,0x3F,0x00,0x00,
0x03,0x03,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x03,
0x03,0x03,0x06,0x06,0x0F,0x0E,0x0E,0x1E,
0x0E,0x0E,0x0E,0x06,0x06,0x06,0x02,0x00,
//'can' (font 2)
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x80,0x60,0x60,0x70,0x7C,0x2E,
0x24,0x28,0xF8,0xF8,0x30,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x18,
0x1E,0x1B,0x09,0x08,0x8A,0xCE,0x7C,0x70,
0x7C,0xCE,0x8F,0x8D,0x04,0x05,0x06,0x0E,
0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x20,0x20,0x10,0x18,
0x08,0x04,0x26,0x13,0x11,0x88,0xCC,0x67,
0x33,0x98,0xD0,0xC1,0x03,0x07,0x06,0x0E,
0x0E,0x0C,0x0C,0x0C,0x0C,0x04,0x04,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x20,0x20,0x10,0x11,0x09,0x08,0x0C,0x06,
0x03,0x03,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//'guan' (font 2)
0x00,0x00,0x80,0x80,0x80,0xC0,0x70,0xF0,
0x00,0x00,0x00,0xE0,0x7C,0x48,0x60,0x20,
0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x40,
0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x38,0x28,0xE4,0xB5,
0x1C,0x24,0xC3,0xDC,0x12,0x92,0x9E,0x96,
0x00,0xFF,0x4B,0x48,0x4C,0x44,0x64,0x64,
0x4F,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x20,0x10,0x18,0x0C,0xFE,0xFB,0x29,
0x29,0x29,0xFF,0xFF,0xA5,0xA5,0xA4,0x80,
0x00,0xCF,0xF2,0x3E,0x0A,0x06,0xFE,0x0E,
0x02,0x07,0x00,0x00,0x00,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x1F,0x1F,0x03,
0x01,0x01,0x01,0x01,0x01,0x09,0x05,0x07,
0x03,0x01,0x00,0x00,0x00,0x00,0x0F,0x18,
0x18,0x18,0x18,0x18,0x18,0x1F,0x0E,0x00,


} ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++)  Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0 set to input port
	do{
	    DI=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0

}
void Command(cmd){
	P0=cmd ;
	DI=0 ;RW=0; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	DI=1 ;RW=0; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
void FillHWAN(unsigned int pidx)
{
	char i ,page,y;
	for(y=0 ; y < 64 ; y+=32){
	    for(page=0 ; page < 8 ; page++){
		Command(0xb8+page) ; // X addr  ;
		Command(0x40+y) ;    // Y Addr ;
		for(i=0; i< 32  ;i++){
		    Data(hwan[pidx++]);
		}
	    }
	}
}
main()
{

	CS1=CS2=1 ;
	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // DISPLAY ON

	CS1=1; CS2=0 ;
	FillHWAN(0) ;
	CS1=0 ; CS2=1 ;
	FillHWAN(128*4) ;
	for(;;) ;
}
%}


@1
%{glcd2b.c
//
//   Display Chinese word "huan ying can guan" on Graphic LCD
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit DI=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
sbit CS1=P1^3 ;
sbit CS2=P1^4 ;
unsigned char code hwan[]={
//'huan' (font 1)
0x00,0x08,0x48,0x88,0x88,0x88,0xFE,0xBE,
0xCA,0x88,0xC8,0x88,0xBE,0xBE,0x8A,0x88,
0xCC,0x8C,0x88,0x00,0xE0,0xFE,0x86,0x86,
0x80,0x80,0x80,0x80,0xC0,0xC0,0x80,0x00,
0x00,0x00,0x00,0x1F,0x1F,0xE8,0x68,0x68,
0x1F,0x0F,0x80,0xFF,0x6F,0x48,0x08,0x88,
0x9F,0x1F,0x18,0x06,0x01,0x00,0xFC,0xFC,
0x04,0x00,0x10,0x0E,0x03,0x00,0x00,0x00,
0x10,0x08,0x0C,0x06,0xFF,0xFF,0x89,0x89,
0x89,0x89,0xFF,0xFF,0x89,0x89,0xCD,0xCD,
0x89,0x01,0x00,0x00,0x80,0xF0,0x3F,0x03,
0x0F,0x70,0xC0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x3F,0x3F,0x08,0x08,
0x08,0x08,0x0F,0x0F,0x08,0x08,0x08,0x2C,
0x1C,0x18,0x0C,0x06,0x03,0x00,0x00,0x00,
0x00,0x00,0x01,0x07,0x0E,0x1C,0x18,0x10,
//'ying' (font 1)
0x00,0x80,0x80,0x02,0x04,0x04,0x0C,0x18,
0x10,0x00,0x04,0xF8,0xF8,0x08,0x08,0x0C,
0x06,0x06,0x04,0x00,0xFC,0xF8,0x08,0x08,
0x08,0x08,0x08,0x08,0xFC,0xFC,0x0C,0x00,
0x00,0x00,0x00,0x01,0x03,0x06,0x86,0x80,
0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,
0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,
0x00,0x01,0x01,0x01,0x01,0x01,0xFF,0xFF,
0x01,0x60,0xE0,0x7F,0x3F,0x10,0x18,0x08,
0x04,0x04,0x02,0x00,0xFF,0xFF,0x00,0x10,
0x10,0x10,0x70,0x30,0x3F,0x1F,0x00,0x00,
0x00,0x08,0x38,0x0C,0x06,0x02,0x01,0x02,
0x04,0x04,0x08,0x08,0x08,0x18,0x18,0x10,
0x10,0x10,0x10,0x10,0x13,0x13,0x10,0x10,
0x10,0x10,0x18,0x18,0x18,0x18,0x08,0x00,
//'can' (font 1)
0x00,0x00,0x00,0x00,0x00,0xE0,0x60,0x60,
0x60,0x20,0x30,0x38,0x2C,0x27,0x22,0x22,
0x20,0x20,0x20,0x28,0x24,0x18,0x98,0xB0,
0x70,0x60,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x70,0x30,0x30,0x38,0x1E,0x17,
0x13,0x12,0x94,0xCC,0x78,0x30,0x38,0x1C,
0x8C,0x18,0x30,0x70,0x50,0x9C,0x97,0x13,
0x11,0x08,0x0A,0x0C,0x38,0x10,0x00,0x00,
0x00,0x10,0x08,0x08,0x44,0x44,0x26,0x22,
0x23,0x31,0x10,0x18,0x88,0x8C,0x86,0x43,
0x63,0x21,0x31,0x18,0x1C,0x08,0x09,0x81,
0xE3,0xC2,0xC6,0x06,0x0C,0x04,0x04,0x00,
0x00,0x00,0x00,0x20,0x22,0x22,0x22,0x22,
0x22,0x23,0x11,0x11,0x11,0x10,0x08,0x08,
0x08,0x04,0x04,0x06,0x02,0x03,0x01,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//'guan' (font 1)
0x00,0x10,0x90,0x90,0x10,0x7E,0x7E,0x96,
0x90,0x90,0x90,0x7E,0x3E,0x16,0x90,0x98,
0x10,0x02,0xFC,0xFC,0x04,0x04,0x04,0x04,
0x04,0x04,0x04,0xFC,0xFE,0x0C,0x00,0x00,
0x00,0x00,0x1F,0x1F,0x09,0xE9,0x49,0x5F,
0x1F,0x1F,0xDF,0x49,0x49,0x09,0x1F,0x1F,
0x01,0x00,0xFF,0xFF,0x21,0x21,0x21,0x21,
0x21,0x21,0x21,0xFF,0xFF,0x00,0x00,0x00,
0x00,0x10,0x08,0x06,0xFF,0xFF,0x92,0x92,
0x92,0xFE,0xFF,0x92,0x92,0xDB,0xDB,0x92,
0x00,0x00,0x1F,0x1F,0xC4,0xFC,0x0C,0x04,
0xFC,0xFC,0x04,0x1F,0x1F,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x3F,0x3F,0x08,0x08,
0x08,0x0F,0x0F,0x08,0x08,0x08,0x0C,0x2C,
0x30,0x10,0x0C,0x06,0x03,0x00,0x00,0x00,
0x1F,0x1F,0x10,0x10,0x10,0x1F,0x10,0x00,
//'huan' (font 2)
0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x90,
0xF0,0x80,0x00,0x00,0x00,0xFC,0x7C,0x68,
0x20,0x20,0x00,0x00,0xC0,0xF8,0x78,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x08,0x78,0xC8,
0xA6,0x3D,0x0C,0x84,0xBC,0x25,0x24,0x3E,
0x2E,0x44,0x30,0x1E,0x07,0xCD,0xC4,0x04,
0x26,0x1E,0x1E,0x0C,0x04,0x00,0x00,0x00,
0x00,0x00,0x20,0x20,0x10,0x08,0x06,0xFF,
0x93,0x92,0xD2,0xFE,0xFF,0x4A,0x4B,0x4B,
0x00,0x00,0x00,0xC0,0xF8,0x1F,0x0D,0x30,
0xE0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x1F,
0x04,0x06,0x02,0x03,0x03,0x02,0x02,0x02,
0x06,0x06,0x03,0x01,0x00,0x00,0x00,0x00,
0x00,0x03,0x07,0x06,0x06,0x04,0x04,0x00,
//'ying' (font 2)
0x00,0x00,0x00,0x00,0x00,0x20,0x60,0xC0,
0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x80,0xE0,0x78,0x38,0x10,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x20,0x20,0x30,0x30,0xF8,
0x71,0x31,0x00,0x00,0x00,0xFF,0xFF,0x01,
0x00,0x80,0x80,0x00,0xFE,0xFE,0x02,0x81,
0x01,0x01,0xFF,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xC0,0xC0,0xC0,0x41,0x46,
0x7C,0x58,0xC0,0x80,0x80,0x8F,0x07,0x03,
0x01,0x00,0x00,0x00,0xFF,0x3F,0x00,0x00,
0x03,0x03,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x03,
0x03,0x03,0x06,0x06,0x0F,0x0E,0x0E,0x1E,
0x0E,0x0E,0x0E,0x06,0x06,0x06,0x02,0x00,
//'can' (font 2)
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x80,0x60,0x60,0x70,0x7C,0x2E,
0x24,0x28,0xF8,0xF8,0x30,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x18,
0x1E,0x1B,0x09,0x08,0x8A,0xCE,0x7C,0x70,
0x7C,0xCE,0x8F,0x8D,0x04,0x05,0x06,0x0E,
0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x20,0x20,0x10,0x18,
0x08,0x04,0x26,0x13,0x11,0x88,0xCC,0x67,
0x33,0x98,0xD0,0xC1,0x03,0x07,0x06,0x0E,
0x0E,0x0C,0x0C,0x0C,0x0C,0x04,0x04,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x20,0x20,0x10,0x11,0x09,0x08,0x0C,0x06,
0x03,0x03,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//'guan' (font 2)
0x00,0x00,0x80,0x80,0x80,0xC0,0x70,0xF0,
0x00,0x00,0x00,0xE0,0x7C,0x48,0x60,0x20,
0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x40,
0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x38,0x28,0xE4,0xB5,
0x1C,0x24,0xC3,0xDC,0x12,0x92,0x9E,0x96,
0x00,0xFF,0x4B,0x48,0x4C,0x44,0x64,0x64,
0x4F,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x20,0x10,0x18,0x0C,0xFE,0xFB,0x29,
0x29,0x29,0xFF,0xFF,0xA5,0xA5,0xA4,0x80,
0x00,0xCF,0xF2,0x3E,0x0A,0x06,0xFE,0x0E,
0x02,0x07,0x00,0x00,0x00,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x1F,0x1F,0x03,
0x01,0x01,0x01,0x01,0x01,0x09,0x05,0x07,
0x03,0x01,0x00,0x00,0x00,0x00,0x0F,0x18,
0x18,0x18,0x18,0x18,0x18,0x1F,0x0E,0x00,


} ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0 set to input port
	do{
	    DI=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0

}
void Command(cmd){
	P0=cmd ;
	DI=0 ;RW=0; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	DI=1 ;RW=0; E=1;E=0 ;RW=1 ;
 	waitlcd() ;
}
void FillHWAN(unsigned char code *pp)
{
	char i ,page,y;
	for(y=0 ; y < 64 ; y+=32){
	    for(page=0 ; page < 8 ; page++){
		Command(0xb8+page) ; // X addr  ;
		Command(0x40+y) ;    // Y Addr ;
		for(i=0; i< 32  ;i++){
		    Data(*pp++);
		}
	    }
	}
}
main()
{

	CS1=CS2=1 ;
	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // DISPLAY ON

	CS1=1; CS2=0 ;
	FillHWAN(&hwan[0]) ;
	CS1=0 ; CS2=1 ;
	FillHWAN(&hwan[128*4]) ;
	for(;;) ;
}
%}


%{glcds1.a51
;
;   Display a horizontal line (at top)  on Graphic LCD
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
DI	REGEQU	P1.0
CS1	REGEQU	P1.3
CS2	REGEQU	P1.4
SPAGE	REGEQU	R0

START:
	SETB	CS1
	CLR	CS2
	ACALL	DELAY5MS
	MOV	A,#0111111B  ; wait for LCD Power-on Ready & Display ON
	ACALL	COMMAND

	MOV	SPAGE,#7
LOOP:
	MOV	A,#010111000B   ; X addr=0
	ORL	A,SPAGE
	ACALL	COMMAND
	MOV	A,#001000000B   ; Y addr=0
	ACALL	COMMAND
	MOV	A,#0FFH
	ACALL	SDATA
	DEC	SPAGE
	CJNE	SPAGE,#0FFH,LOOP
	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	DI
	CLR	E
	SETB	RW
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	DI
	CLR	E
	SETB	RW
WAITLCD:
	MOV	P0,#0FFH  ; P0 set to input port
WAITLCD1:
	CLR	DI
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


@1
%{glcds1.c
//
//   Display a horizontal line (at top)  on Graphic LCD
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit DI=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
sbit CS1=P1^3 ;
sbit CS2=P1^4 ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0 set to input port
	do{
	    DI=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0
}
void Command(cmd){
	P0=cmd ;
	DI=0 ;RW=0; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	DI=1 ;RW=0; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
main()
{
	char page ;

	CS1=1;CS2=0 ;
	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // DISPLAY ON


	for(page=7; page >= 0  ;page--){
	    Command(0xb8+page) ; // X addr = 0 ;
	    Command(0x40+0) ; // Y Addr= 0 ;
	    Data(0xff);
	}
	for(;;) ;
}
%}


%{glcds2.a51
;
;   Display Chinese word "huan ying can guan" on Graphic LCD
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
DI	REGEQU	P1.0
CS1	REGEQU	P1.3
CS2	REGEQU	P1.4
Y	REGEQU	R0
SPAGE	REGEQU	R1
IDX	REGEQU	R2

START:
	SETB	CS1
	SETB	CS2
	ACALL	DELAY5MS
	MOV	A,#0111111B  ; wait for LCD Power-on Ready & Display ON
	ACALL	COMMAND

	SETB	CS1
	CLR	CS2
	MOV	DPTR,#HWAN
	ACALL	FILLHWAN
	CLR	CS1
	SETB	CS2
	ACALL	FILLHWAN
	SJMP	$
FILLHWAN:
	MOV	Y,#0
NEXT3:
	MOV	SPAGE,#7
NEXT2:
	MOV	A,#010111000b
	ORL	A,SPAGE
	ACALL	COMMAND
	MOV	A,#001000000B
	ORL	A,Y
	ACALL	COMMAND
	MOV	IDX,#32
NEXT1:
	CLR	A
	MOVC	A,@A+DPTR
	ACALL	SDATA
	INC	DPTR
	DJNZ	IDX,NEXT1
	DEC	SPAGE
	CJNE	SPAGE,#0FFH,NEXT2
	MOV	A,Y
	ADD	A,#32
	MOV	Y,A
	CJNE	A,#64,NEXT3
	RET
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	DI
	CLR	E
	SETB	RW
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	DI
	CLR	E
	SETB	RW
WAITLCD:
	MOV	P0,#0FFH  ; P0 set to input port
WAITLCD1:
	CLR	DI
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

HWAN:
                                                      ;'huan' (font 1)
      DB    000H,000H,003H,003H,07FH,003H,003H,022H
      DB    01FH,018H,018H,018H,01FH,018H,007H,007H
      DB    004H,00FH,01CH,03CH,06FH,08CH,00CH,00CH
      DB    00FH,00CH,00CH,00CH,00FH,00CH,00CH,000H
      DB    000H,000H,08EH,00CH,0FFH,00CH,00CH,0A0H
      DB    0FFH,0D8H,0D8H,0D8H,0DFH,090H,018H,01CH
      DB    031H,0FFH,030H,033H,0FFH,030H,030H,033H
      DB    0FFH,030H,030H,031H,0FFH,000H,001H,000H
      DB    000H,000H,007H,0C7H,0E4H,004H,00CH,08CH
      DB    0EFH,0C8H,0D0H,0D3H,0E3H,0E3H,003H,003H
      DB    083H,0C3H,003H,002H,082H,006H,006H,004H
      DB    08CH,008H,018H,0B0H,0E0H,0C0H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,00CH
      DB    0FEH,008H,018H,090H,010H,020H,000H,000H
      DB    000H,080H,080H,080H,080H,040H,040H,060H
      DB    020H,030H,018H,01CH,00EH,007H,000H,000H
                                                                       ;'ying' (font 1)
      DB    000H,000H,010H,00EH,003H,001H,000H,000H
      DB    060H,018H,00EH,006H,000H,000H,000H,000H
      DB    003H,07FH,003H,003H,003H,003H,003H,003H
      DB    003H,002H,00DH,018H,070H,020H,020H,000H
      DB    000H,000H,000H,021H,01FH,098H,018H,018H
      DB    018H,018H,018H,018H,018H,018H,018H,018H
      DB    018H,098H,018H,018H,01BH,01EH,078H,070H
      DB    020H,000H,000H,0C0H,03EH,007H,000H,000H
      DB    000H,000H,0C0H,0E8H,00FH,00CH,00CH,00CH
      DB    00CH,00CH,00CH,00CH,00CH,00CH,00CH,00CH
      DB    00CH,00CH,02CH,0CCH,00CH,00DH,00CH,00CH
      DB    00CH,00CH,00CH,000H,000H,0FFH,000H,000H
      DB    000H,000H,000H,00EH,0FEH,00CH,00CH,00CH
      DB    00CH,00CH,00CH,00CH,00CH,00CH,00CH,00CH
      DB    00CH,00CH,00CH,00CH,00CH,0FCH,038H,020H
      DB    000H,000H,000H,000H,03EH,0FCH,000H,000H
                                                                       ;'can' (font 1)
      DB    000H,000H,000H,000H,000H,000H,007H,007H
      DB    004H,001H,003H,003H,006H,03FH,03CH,020H
      DB    000H,000H,003H,00EH,030H,040H,003H,00CH
      DB    000H,000H,00FH,000H,000H,000H,01FH,000H
      DB    000H,004H,007H,00CH,018H,030H,0FFH,080H
      DB    000H,080H,0C0H,031H,01BH,0EFH,00EH,018H
      DB    030H,0C1H,083H,006H,01CH,070H,0C0H,001H
      DB    00EH,078H,0C0H,000H,003H,03CH,0C0H,000H
      DB    000H,000H,000H,008H,016H,007H,0F9H,000H
      DB    003H,003H,003H,086H,0C4H,07FH,030H,018H
      DB    086H,0E3H,080H,008H,01EH,038H,0E0H,080H
      DB    001H,007H,01CH,070H,080H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,080H,0C0H,0C0H
      DB    000H,080H,020H,010H,078H,08CH,008H,000H
      DB    000H,080H,0F0H,03EH,008H,000H,080H,0E0H
      DB    0E0H,000H,000H,000H,000H,000H,000H,000H
                                                                       ;'guan' (font 1)
      DB    000H,000H,007H,007H,006H,07FH,006H,006H
      DB    031H,03FH,031H,031H,03FH,031H,004H,007H
      DB    004H,00CH,01FH,01CH,02CH,04FH,00CH,00CH
      DB    00FH,00CH,00CH,00CH,00FH,00CH,00CH,000H
      DB    000H,000H,01CH,01CH,019H,0FFH,018H,010H
      DB    0E3H,0FFH,0E3H,0E3H,0FFH,0E3H,000H,038H
      DB    020H,026H,0FFH,060H,066H,0FFH,060H,066H
      DB    0FFH,060H,060H,063H,0FFH,000H,001H,000H
      DB    000H,000H,040H,03FH,030H,0B0H,030H,030H
      DB    030H,0BFH,030H,030H,030H,030H,03FH,030H
      DB    030H,030H,030H,03FH,036H,034H,004H,00CH
      DB    00CH,008H,018H,030H,020H,0C0H,080H,000H
      DB    000H,000H,008H,0FCH,01CH,018H,018H,018H
      DB    018H,0F8H,018H,018H,018H,018H,0F8H,018H
      DB    018H,018H,018H,0F8H,0D8H,0D8H,0C0H,0C0H
      DB    0C4H,0C4H,0C4H,0C4H,0C4H,0FEH,000H,000H
                                                                       ;'huan' (font 2)
      DB    000H,000H,000H,000H,000H,001H,000H,000H
      DB    00FH,000H,000H,000H,007H,002H,002H,003H
      DB    001H,001H,003H,003H,005H,009H,031H,001H
      DB    001H,001H,001H,003H,003H,001H,000H,000H
      DB    000H,000H,000H,006H,007H,086H,087H,087H
      DB    0C4H,044H,081H,0FFH,069H,049H,0CFH,000H
      DB    098H,08BH,0FFH,018H,01FH,0F8H,018H,03FH
      DB    0F8H,018H,07FH,0C0H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,006H,006H,0C6H,00EH
      DB    00CH,00CH,098H,0DFH,094H,030H,0A0H,046H
      DB    006H,006H,004H,006H,00EH,00DH,009H,018H
      DB    018H,030H,0E0H,0C0H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,0E0H,0F8H,070H,060H,080H,000H
      DB    000H,000H,000H,000H,000H,000H,080H,080H
      DB    0C0H,060H,078H,03EH,000H,000H,000H,000H
                                                                       ;'ying' (font 2)
      DB    000H,000H,000H,000H,000H,000H,006H,003H
      DB    001H,000H,000H,000H,001H,007H,01FH,001H
      DB    001H,002H,001H,001H,000H,000H,000H,01FH
      DB    01CH,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,080H
      DB    0C0H,0C7H,006H,006H,006H,0C6H,0C6H,086H
      DB    006H,007H,007H,086H,0C4H,0C0H,080H,0E0H
      DB    03CH,007H,001H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,030H,038H,070H,060H
      DB    0C0H,001H,00EH,00CH,00CH,00CH,00CH,00CH
      DB    06DH,08CH,00CH,00CH,00CH,00CH,00CH,008H
      DB    008H,0C8H,0FFH,03FH,00FH,001H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,0F0H,030H,030H,030H,030H,030H,030H
      DB    030H,0E0H,0E0H,000H,000H,000H,000H,000H
      DB    000H,000H,0FEH,0FCH,0E0H,000H,000H,000H
                                                                       ;'can' (font 2)
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,003H,003H,002H,000H
      DB    000H,000H,000H,000H,001H,003H,00CH,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,001H,003H,003H,006H,01FH,01EH
      DB    060H,060H,0CCH,086H,0FEH,0C3H,003H,007H
      DB    00CH,019H,031H,063H,086H,018H,021H,003H
      DB    006H,018H,001H,003H,00EH,030H,0C0H,000H
      DB    000H,000H,000H,080H,070H,038H,0F8H,030H
      DB    030H,034H,063H,0FFH,0F1H,080H,080H,0C0H
      DB    070H,09CH,08FH,007H,041H,0E0H,080H,030H
      DB    070H,0E0H,0C0H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
      DB    000H,000H,000H,080H,080H,000H,000H,000H
      DB    000H,000H,080H,0FEH,0F8H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,000H
                                                                       ;'guan' (font 2)
      DB    000H,000H,000H,000H,000H,003H,003H,007H
      DB    03DH,001H,000H,003H,00CH,009H,00FH,002H
      DB    003H,003H,006H,00CH,01FH,036H,047H,006H
      DB    006H,007H,007H,006H,006H,006H,000H,000H
      DB    000H,000H,000H,008H,00CH,008H,01BH,01EH
      DB    010H,020H,02FH,0D3H,092H,09FH,040H,030H
      DB    037H,0FCH,030H,03EH,0F0H,030H,0FEH,030H
      DB    03FH,0FFH,001H,003H,004H,000H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,001H
      DB    07EH,060H,060H,04FH,078H,040H,043H,07FH
      DB    040H,040H,07FH,057H,05BH,032H,032H,062H
      DB    062H,0C2H,082H,002H,003H,001H,000H,000H
      DB    000H,000H,000H,000H,000H,000H,000H,0C0H
      DB    0E0H,0E0H,0C0H,0C0H,0C0H,040H,040H,0C0H
      DB    040H,040H,0C0H,040H,000H,000H,000H,000H
      DB    004H,004H,006H,006H,0FEH,0FCH,000H,000H

	END
%}


@1
%{glcds2a.c
//
//   Display Chinese word "huan ying can guan" on Graphic LCD
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit DI=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
sbit CS1=P1^3 ;
sbit CS2=P1^4 ;
unsigned char code hwan[]={
//'huan' (font 1)
0x00,0x00,0x03,0x03,0x7F,0x03,0x03,0x22,
0x1F,0x18,0x18,0x18,0x1F,0x18,0x07,0x07,
0x04,0x0F,0x1C,0x3C,0x6F,0x8C,0x0C,0x0C,
0x0F,0x0C,0x0C,0x0C,0x0F,0x0C,0x0C,0x00,
0x00,0x00,0x8E,0x0C,0xFF,0x0C,0x0C,0xA0,
0xFF,0xD8,0xD8,0xD8,0xDF,0x90,0x18,0x1C,
0x31,0xFF,0x30,0x33,0xFF,0x30,0x30,0x33,
0xFF,0x30,0x30,0x31,0xFF,0x00,0x01,0x00,
0x00,0x00,0x07,0xC7,0xE4,0x04,0x0C,0x8C,
0xEF,0xC8,0xD0,0xD3,0xE3,0xE3,0x03,0x03,
0x83,0xC3,0x03,0x02,0x82,0x06,0x06,0x04,
0x8C,0x08,0x18,0xB0,0xE0,0xC0,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,
0xFE,0x08,0x18,0x90,0x10,0x20,0x00,0x00,
0x00,0x80,0x80,0x80,0x80,0x40,0x40,0x60,
0x20,0x30,0x18,0x1C,0x0E,0x07,0x00,0x00,
//'ying' (font 1)
0x00,0x00,0x10,0x0E,0x03,0x01,0x00,0x00,
0x60,0x18,0x0E,0x06,0x00,0x00,0x00,0x00,
0x03,0x7F,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x02,0x0D,0x18,0x70,0x20,0x20,0x00,
0x00,0x00,0x00,0x21,0x1F,0x98,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x98,0x18,0x18,0x1B,0x1E,0x78,0x70,
0x20,0x00,0x00,0xC0,0x3E,0x07,0x00,0x00,
0x00,0x00,0xC0,0xE8,0x0F,0x0C,0x0C,0x0C,
0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
0x0C,0x0C,0x2C,0xCC,0x0C,0x0D,0x0C,0x0C,
0x0C,0x0C,0x0C,0x00,0x00,0xFF,0x00,0x00,
0x00,0x00,0x00,0x0E,0xFE,0x0C,0x0C,0x0C,
0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
0x0C,0x0C,0x0C,0x0C,0x0C,0xFC,0x38,0x20,
0x00,0x00,0x00,0x00,0x3E,0xFC,0x00,0x00,
//'can' (font 1)
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x07,
0x04,0x01,0x03,0x03,0x06,0x3F,0x3C,0x20,
0x00,0x00,0x03,0x0E,0x30,0x40,0x03,0x0C,
0x00,0x00,0x0F,0x00,0x00,0x00,0x1F,0x00,
0x00,0x04,0x07,0x0C,0x18,0x30,0xFF,0x80,
0x00,0x80,0xC0,0x31,0x1B,0xEF,0x0E,0x18,
0x30,0xC1,0x83,0x06,0x1C,0x70,0xC0,0x01,
0x0E,0x78,0xC0,0x00,0x03,0x3C,0xC0,0x00,
0x00,0x00,0x00,0x08,0x16,0x07,0xF9,0x00,
0x03,0x03,0x03,0x86,0xC4,0x7F,0x30,0x18,
0x86,0xE3,0x80,0x08,0x1E,0x38,0xE0,0x80,
0x01,0x07,0x1C,0x70,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,
0x00,0x80,0x20,0x10,0x78,0x8C,0x08,0x00,
0x00,0x80,0xF0,0x3E,0x08,0x00,0x80,0xE0,
0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//'guan' (font 1)
0x00,0x00,0x07,0x07,0x06,0x7F,0x06,0x06,
0x31,0x3F,0x31,0x31,0x3F,0x31,0x04,0x07,
0x04,0x0C,0x1F,0x1C,0x2C,0x4F,0x0C,0x0C,
0x0F,0x0C,0x0C,0x0C,0x0F,0x0C,0x0C,0x00,
0x00,0x00,0x1C,0x1C,0x19,0xFF,0x18,0x10,
0xE3,0xFF,0xE3,0xE3,0xFF,0xE3,0x00,0x38,
0x20,0x26,0xFF,0x60,0x66,0xFF,0x60,0x66,
0xFF,0x60,0x60,0x63,0xFF,0x00,0x01,0x00,
0x00,0x00,0x40,0x3F,0x30,0xB0,0x30,0x30,
0x30,0xBF,0x30,0x30,0x30,0x30,0x3F,0x30,
0x30,0x30,0x30,0x3F,0x36,0x34,0x04,0x0C,
0x0C,0x08,0x18,0x30,0x20,0xC0,0x80,0x00,
0x00,0x00,0x08,0xFC,0x1C,0x18,0x18,0x18,
0x18,0xF8,0x18,0x18,0x18,0x18,0xF8,0x18,
0x18,0x18,0x18,0xF8,0xD8,0xD8,0xC0,0xC0,
0xC4,0xC4,0xC4,0xC4,0xC4,0xFE,0x00,0x00,
//'huan' (font 2)
0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,
0x0F,0x00,0x00,0x00,0x07,0x02,0x02,0x03,
0x01,0x01,0x03,0x03,0x05,0x09,0x31,0x01,
0x01,0x01,0x01,0x03,0x03,0x01,0x00,0x00,
0x00,0x00,0x00,0x06,0x07,0x86,0x87,0x87,
0xC4,0x44,0x81,0xFF,0x69,0x49,0xCF,0x00,
0x98,0x8B,0xFF,0x18,0x1F,0xF8,0x18,0x3F,
0xF8,0x18,0x7F,0xC0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x06,0x06,0xC6,0x0E,
0x0C,0x0C,0x98,0xDF,0x94,0x30,0xA0,0x46,
0x06,0x06,0x04,0x06,0x0E,0x0D,0x09,0x18,
0x18,0x30,0xE0,0xC0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xE0,0xF8,0x70,0x60,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,
0xC0,0x60,0x78,0x3E,0x00,0x00,0x00,0x00,
//'ying' (font 2)
0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x03,
0x01,0x00,0x00,0x00,0x01,0x07,0x1F,0x01,
0x01,0x02,0x01,0x01,0x00,0x00,0x00,0x1F,
0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0xC0,0xC7,0x06,0x06,0x06,0xC6,0xC6,0x86,
0x06,0x07,0x07,0x86,0xC4,0xC0,0x80,0xE0,
0x3C,0x07,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x30,0x38,0x70,0x60,
0xC0,0x01,0x0E,0x0C,0x0C,0x0C,0x0C,0x0C,
0x6D,0x8C,0x0C,0x0C,0x0C,0x0C,0x0C,0x08,
0x08,0xC8,0xFF,0x3F,0x0F,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xF0,0x30,0x30,0x30,0x30,0x30,0x30,
0x30,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xFE,0xFC,0xE0,0x00,0x00,0x00,
//'can' (font 2)
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x03,0x03,0x02,0x00,
0x00,0x00,0x00,0x00,0x01,0x03,0x0C,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x03,0x03,0x06,0x1F,0x1E,
0x60,0x60,0xCC,0x86,0xFE,0xC3,0x03,0x07,
0x0C,0x19,0x31,0x63,0x86,0x18,0x21,0x03,
0x06,0x18,0x01,0x03,0x0E,0x30,0xC0,0x00,
0x00,0x00,0x00,0x80,0x70,0x38,0xF8,0x30,
0x30,0x34,0x63,0xFF,0xF1,0x80,0x80,0xC0,
0x70,0x9C,0x8F,0x07,0x41,0xE0,0x80,0x30,
0x70,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x00,
0x00,0x00,0x80,0xFE,0xF8,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//'guan' (font 2)
0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x07,
0x3D,0x01,0x00,0x03,0x0C,0x09,0x0F,0x02,
0x03,0x03,0x06,0x0C,0x1F,0x36,0x47,0x06,
0x06,0x07,0x07,0x06,0x06,0x06,0x00,0x00,
0x00,0x00,0x00,0x08,0x0C,0x08,0x1B,0x1E,
0x10,0x20,0x2F,0xD3,0x92,0x9F,0x40,0x30,
0x37,0xFC,0x30,0x3E,0xF0,0x30,0xFE,0x30,
0x3F,0xFF,0x01,0x03,0x04,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
0x7E,0x60,0x60,0x4F,0x78,0x40,0x43,0x7F,
0x40,0x40,0x7F,0x57,0x5B,0x32,0x32,0x62,
0x62,0xC2,0x82,0x02,0x03,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,
0xE0,0xE0,0xC0,0xC0,0xC0,0x40,0x40,0xC0,
0x40,0x40,0xC0,0x40,0x00,0x00,0x00,0x00,
0x04,0x04,0x06,0x06,0xFE,0xFC,0x00,0x00,

} ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0 set to input port
	do{
	    DI=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0

}
void Command(cmd){
	P0=cmd ;
	DI=0 ;RW=0; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	DI=1 ;RW=0; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
void FillHWAN(unsigned int pidx)
{
	char i ,page,y;

	for(y=0 ; y < 64 ; y+=32){
	    for(page=7 ; page >= 0 ; page--){
		Command(0xb8+page) ; // X addr  ;
		Command(0x40+y) ;    // Y Addr ;
		for(i=0; i< 32  ;i++){
		    Data(hwan[pidx++]);
		}
	    }
	}
}
main()
{

	CS1=CS2=1 ;
	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // DISPLAY ON

	CS1=1; CS2=0 ;
	FillHWAN(0) ;
	CS1=0 ; CS2=1 ;
	FillHWAN(128*4) ;
	for(;;) ;
}
%}


@1
%{glcds2b.c
//
//   Display Chinese word "huan ying can guan" on Graphic LCD
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit DI=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
sbit CS1=P1^3 ;
sbit CS2=P1^4 ;
unsigned char code hwan[]={
//'huan' (font 1)
0x00,0x00,0x03,0x03,0x7F,0x03,0x03,0x22,
0x1F,0x18,0x18,0x18,0x1F,0x18,0x07,0x07,
0x04,0x0F,0x1C,0x3C,0x6F,0x8C,0x0C,0x0C,
0x0F,0x0C,0x0C,0x0C,0x0F,0x0C,0x0C,0x00,
0x00,0x00,0x8E,0x0C,0xFF,0x0C,0x0C,0xA0,
0xFF,0xD8,0xD8,0xD8,0xDF,0x90,0x18,0x1C,
0x31,0xFF,0x30,0x33,0xFF,0x30,0x30,0x33,
0xFF,0x30,0x30,0x31,0xFF,0x00,0x01,0x00,
0x00,0x00,0x07,0xC7,0xE4,0x04,0x0C,0x8C,
0xEF,0xC8,0xD0,0xD3,0xE3,0xE3,0x03,0x03,
0x83,0xC3,0x03,0x02,0x82,0x06,0x06,0x04,
0x8C,0x08,0x18,0xB0,0xE0,0xC0,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,
0xFE,0x08,0x18,0x90,0x10,0x20,0x00,0x00,
0x00,0x80,0x80,0x80,0x80,0x40,0x40,0x60,
0x20,0x30,0x18,0x1C,0x0E,0x07,0x00,0x00,
//'ying' (font 1)
0x00,0x00,0x10,0x0E,0x03,0x01,0x00,0x00,
0x60,0x18,0x0E,0x06,0x00,0x00,0x00,0x00,
0x03,0x7F,0x03,0x03,0x03,0x03,0x03,0x03,
0x03,0x02,0x0D,0x18,0x70,0x20,0x20,0x00,
0x00,0x00,0x00,0x21,0x1F,0x98,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x98,0x18,0x18,0x1B,0x1E,0x78,0x70,
0x20,0x00,0x00,0xC0,0x3E,0x07,0x00,0x00,
0x00,0x00,0xC0,0xE8,0x0F,0x0C,0x0C,0x0C,
0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
0x0C,0x0C,0x2C,0xCC,0x0C,0x0D,0x0C,0x0C,
0x0C,0x0C,0x0C,0x00,0x00,0xFF,0x00,0x00,
0x00,0x00,0x00,0x0E,0xFE,0x0C,0x0C,0x0C,
0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
0x0C,0x0C,0x0C,0x0C,0x0C,0xFC,0x38,0x20,
0x00,0x00,0x00,0x00,0x3E,0xFC,0x00,0x00,
//'can' (font 1)
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x07,
0x04,0x01,0x03,0x03,0x06,0x3F,0x3C,0x20,
0x00,0x00,0x03,0x0E,0x30,0x40,0x03,0x0C,
0x00,0x00,0x0F,0x00,0x00,0x00,0x1F,0x00,
0x00,0x04,0x07,0x0C,0x18,0x30,0xFF,0x80,
0x00,0x80,0xC0,0x31,0x1B,0xEF,0x0E,0x18,
0x30,0xC1,0x83,0x06,0x1C,0x70,0xC0,0x01,
0x0E,0x78,0xC0,0x00,0x03,0x3C,0xC0,0x00,
0x00,0x00,0x00,0x08,0x16,0x07,0xF9,0x00,
0x03,0x03,0x03,0x86,0xC4,0x7F,0x30,0x18,
0x86,0xE3,0x80,0x08,0x1E,0x38,0xE0,0x80,
0x01,0x07,0x1C,0x70,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,
0x00,0x80,0x20,0x10,0x78,0x8C,0x08,0x00,
0x00,0x80,0xF0,0x3E,0x08,0x00,0x80,0xE0,
0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//'guan' (font 1)
0x00,0x00,0x07,0x07,0x06,0x7F,0x06,0x06,
0x31,0x3F,0x31,0x31,0x3F,0x31,0x04,0x07,
0x04,0x0C,0x1F,0x1C,0x2C,0x4F,0x0C,0x0C,
0x0F,0x0C,0x0C,0x0C,0x0F,0x0C,0x0C,0x00,
0x00,0x00,0x1C,0x1C,0x19,0xFF,0x18,0x10,
0xE3,0xFF,0xE3,0xE3,0xFF,0xE3,0x00,0x38,
0x20,0x26,0xFF,0x60,0x66,0xFF,0x60,0x66,
0xFF,0x60,0x60,0x63,0xFF,0x00,0x01,0x00,
0x00,0x00,0x40,0x3F,0x30,0xB0,0x30,0x30,
0x30,0xBF,0x30,0x30,0x30,0x30,0x3F,0x30,
0x30,0x30,0x30,0x3F,0x36,0x34,0x04,0x0C,
0x0C,0x08,0x18,0x30,0x20,0xC0,0x80,0x00,
0x00,0x00,0x08,0xFC,0x1C,0x18,0x18,0x18,
0x18,0xF8,0x18,0x18,0x18,0x18,0xF8,0x18,
0x18,0x18,0x18,0xF8,0xD8,0xD8,0xC0,0xC0,
0xC4,0xC4,0xC4,0xC4,0xC4,0xFE,0x00,0x00,
//'huan' (font 2)
0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,
0x0F,0x00,0x00,0x00,0x07,0x02,0x02,0x03,
0x01,0x01,0x03,0x03,0x05,0x09,0x31,0x01,
0x01,0x01,0x01,0x03,0x03,0x01,0x00,0x00,
0x00,0x00,0x00,0x06,0x07,0x86,0x87,0x87,
0xC4,0x44,0x81,0xFF,0x69,0x49,0xCF,0x00,
0x98,0x8B,0xFF,0x18,0x1F,0xF8,0x18,0x3F,
0xF8,0x18,0x7F,0xC0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x06,0x06,0xC6,0x0E,
0x0C,0x0C,0x98,0xDF,0x94,0x30,0xA0,0x46,
0x06,0x06,0x04,0x06,0x0E,0x0D,0x09,0x18,
0x18,0x30,0xE0,0xC0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xE0,0xF8,0x70,0x60,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,
0xC0,0x60,0x78,0x3E,0x00,0x00,0x00,0x00,
//'ying' (font 2)
0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x03,
0x01,0x00,0x00,0x00,0x01,0x07,0x1F,0x01,
0x01,0x02,0x01,0x01,0x00,0x00,0x00,0x1F,
0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0xC0,0xC7,0x06,0x06,0x06,0xC6,0xC6,0x86,
0x06,0x07,0x07,0x86,0xC4,0xC0,0x80,0xE0,
0x3C,0x07,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x30,0x38,0x70,0x60,
0xC0,0x01,0x0E,0x0C,0x0C,0x0C,0x0C,0x0C,
0x6D,0x8C,0x0C,0x0C,0x0C,0x0C,0x0C,0x08,
0x08,0xC8,0xFF,0x3F,0x0F,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xF0,0x30,0x30,0x30,0x30,0x30,0x30,
0x30,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xFE,0xFC,0xE0,0x00,0x00,0x00,
//'can' (font 2)
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x03,0x03,0x02,0x00,
0x00,0x00,0x00,0x00,0x01,0x03,0x0C,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x03,0x03,0x06,0x1F,0x1E,
0x60,0x60,0xCC,0x86,0xFE,0xC3,0x03,0x07,
0x0C,0x19,0x31,0x63,0x86,0x18,0x21,0x03,
0x06,0x18,0x01,0x03,0x0E,0x30,0xC0,0x00,
0x00,0x00,0x00,0x80,0x70,0x38,0xF8,0x30,
0x30,0x34,0x63,0xFF,0xF1,0x80,0x80,0xC0,
0x70,0x9C,0x8F,0x07,0x41,0xE0,0x80,0x30,
0x70,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x00,
0x00,0x00,0x80,0xFE,0xF8,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//'guan' (font 2)
0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x07,
0x3D,0x01,0x00,0x03,0x0C,0x09,0x0F,0x02,
0x03,0x03,0x06,0x0C,0x1F,0x36,0x47,0x06,
0x06,0x07,0x07,0x06,0x06,0x06,0x00,0x00,
0x00,0x00,0x00,0x08,0x0C,0x08,0x1B,0x1E,
0x10,0x20,0x2F,0xD3,0x92,0x9F,0x40,0x30,
0x37,0xFC,0x30,0x3E,0xF0,0x30,0xFE,0x30,
0x3F,0xFF,0x01,0x03,0x04,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
0x7E,0x60,0x60,0x4F,0x78,0x40,0x43,0x7F,
0x40,0x40,0x7F,0x57,0x5B,0x32,0x32,0x62,
0x62,0xC2,0x82,0x02,0x03,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,
0xE0,0xE0,0xC0,0xC0,0xC0,0x40,0x40,0xC0,
0x40,0x40,0xC0,0x40,0x00,0x00,0x00,0x00,
0x04,0x04,0x06,0x06,0xFE,0xFC,0x00,0x00,

} ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // P0 set to input port
	do{
	    DI=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0

}
void Command(cmd){
	P0=cmd ;
	DI=0 ;RW=0; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	DI=1 ;RW=0; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
void FillHWAN(unsigned char code *pp)
{
	char i ,page,y;

	for(y=0 ; y < 64 ; y+=32){
	    for(page=7 ; page >= 0 ; page--){
		Command(0xb8+page) ; // X addr  ;
		Command(0x40+y) ;    // Y Addr ;
		for(i=0; i< 32  ;i++){
		    Data(*pp++);
		}
	    }
	}
}
main()
{

	CS1=CS2=1 ;
	delay5ms() ;       // wait for LCD Power-on Ready
	Command(0x3f) ;    // DISPLAY ON

	CS1=1; CS2=0 ;
	FillHWAN(&hwan[0]) ;
	CS1=0 ; CS2=1 ;
	FillHWAN(&hwan[128*4]) ;
	for(;;) ;
}
%}


@1
%{gscop.c
//
//   P0 control horizontal position(X),
//   P1 control vertical position(Y),
//     Display "HELLO !!" and  twinkle
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>

char code tbl[8][8]=
{
{0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x00},
{0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00},
{0xf0, 0x60, 0x60, 0x60, 0x60, 0x62, 0xfe, 0x00},
{0xf0, 0x60, 0x60, 0x60, 0x60, 0x62, 0xfe, 0x00},
{0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x18, 0x3c, 0x3c, 0x18, 0x18, 0x00, 0x18, 0x00},
{0x18, 0x3c, 0x3c, 0x18, 0x18, 0x00, 0x18, 0x00},
};


main()
{
	char t;
	int i,j, x=20, y=20;

	P0 =0;
	P1 =0;
	
	for(;;){
	    for(i=0;i<8 ;i++){
		for(j=0; j<8*8; j++){
		    t=tbl[j>>3][i];
		    t=t<<(j&7);
		    if(t&0x80){
			P0 = j+x;	
			P1 = i+y;
		    }
		}
	    }
	    P0=0;
	    P1=0;
	    for(i=0; i < 30000; i++);
	}
}
%}


@1
%{int0.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char Count ;
main()
{
	P0=Count=0 ;
	IT0=1 ; // detect negative edge trigger
	EA=1;
	EX0=1 ;
	for(;;) ;
}
void external0(void ) interrupt 0
{
	Count++ ;
	P0=Count ;
}
%}


@1
%{int1.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char Shift ;
main()
{
	P0=Shift=1 ;
	IT1=1 ; // Detect negative edge trigger 	
	EA=1;
	EX1=1 ;
	for(;;) ;
}
void external1(void ) interrupt 2
{
	Shift <<=1 ;
	if(Shift == 0){
	    Shift=1 ;
	}
	P0=Shift;
}
%}


%{key1.a51
;
;   The phenomenon of Key bounce
;
KEY1	REGEQU	P1.0
START:
	MOV	P0,#0
LOOP:
	JB	KEY1,$
	INC	P0
	JNB	KEY1,$
	SJMP	LOOP
	END
%}


@1
%{key1.c
//
//   The phenomenon of Key bounce
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
sbit KEY1=P1 ^0 ;
main()
{
	P0=0 ;
	for(;;){
	    while(KEY1 ==1) ;
	    P0++;
	    while(KEY1==0) ;
	}
}
%}


%{key2.a51
;
;   Using debounce technique on key-scanning design
;
KEY1	REGEQU	P1.0
START:
	MOV	P0,#0
LOOP1:
	JB	KEY1,$
	ACALL	DELAY20MS
	JB	KEY1,LOOP1
	INC	P0
LOOP2:
	JNB	KEY1,$
	ACALL	DELAY20MS
	JNB	KEY1,LOOP2
	SJMP	LOOP1
DELAY20MS:
	ACALL	DELAY10MS
	ACALL	DELAY10MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


@1
%{key2.c
//
//   Using debounce technique on key-scanning design
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit KEY1=P1 ^0 ;
void delay20ms()
{
	Delay10ms();
	Delay10ms();
}

main()
{
	P0=0 ;
	for(;;){
	    do{
		while(KEY1 ==1) ;
		delay20ms() ;
	    }
	    while(KEY1 == 1) ;
	    P0++;
	    do{
		while(KEY1==0) ;
		delay20ms() ;
	    }
	    while(KEY1== 0) ;    
	}
}
%}


%{key3.a51
;
;   Keyboard-scanning design
;
KEY1	REGEQU	P1.0
ROW	REGEQU	R2
KEYFLAG	REGEQU	R3

START:
	MOV	P0,#0
LOOP1:
	MOV	P1,#0FEH
	MOV	ROW,#0
NEXT1:
	MOV	A,P2
	ANL	A,#0FH
	CJNE	A,#0FH,OUT1
	MOV	A,P1
	RL	A
	MOV	P1,A
 	INC	ROW
	CJNE	ROW,#5,NEXT1
	SJMP	LOOP1
OUT1:
	ACALL	DELAY20MS
	MOV	A,P2
	ANL	A,#0FH
	CJNE	A,#0FH,OUT2
	SJMP	LOOP1
OUT2:
	MOV	DPTR,#IDXCOL
	MOVC	A,@A+DPTR
	MOV	B,A
	MOV	A,ROW
;         setb   F0
	RL	A
	RL	A
	ANL	A,#011111100B
	ADD	A,B
	MOV	P0,A
LOOP2:
	MOV	A,P2
	ANL	A,#0FH
	CJNE	A,#0FH,LOOP2
	ACALL	DELAY20MS
	MOV	A,P2
	ANL	A,#0FH
	CJNE	A,#0FH,LOOP2
	SJMP	LOOP1
DELAY20MS:
	ACALL	DELAY10MS
	ACALL	DELAY10MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

IDXCOL:
	DB 0,1,0,2
	DB 0,1,0,3
	DB 0,1,0,2
	DB 0,1,0,4
	END
%}


@1
%{key3.c
//
//   Keyboard-scanning design
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"

void delay20ms() ;
unsigned char code IdxCol[]= {
	0 , 1 , 0 , 2 ,
	0 , 1 , 0 , 3 ,
	0 , 1 , 0 , 2 ,
	0 , 1 , 0 , 4
} ;
main()
{
	char row ;
	char keyflag ;
	char tP1 ;
	P0=0 ;
	for(;;){
	    do{
		for(P1=tP1=0xfe,row=0 ,keyflag=0 ; (row < 5);row++){
		    if((P2&0xf) != 0xf){
			keyflag=1 ;
			break ;
		    }
		    tP1 <<=1 ;
		    tP1 +=1 ;
		    P1=tP1 ;
		}
		if(keyflag== 1){
		    delay20ms() ;
		    if((P2&0xf) ==0xf){
			keyflag= 0 ;
		    }
		}
	    }
	    while(keyflag==0) ;
	    P0=row*4+IdxCol[P2&0xf];
	    do{
		while((P2&0xf) != 0xf) ;
		delay20ms() ;
	    }
	    while((P2 &  0xf) != 0xf) ;
	}
}
void delay20ms()
{
	Delay10ms();
	Delay10ms();
}
%}


%{lcd1a.a51
;
;   Display "Hello!!" on Text LCD (synchronize by delay method)
;
START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ; 8bits data bus/2 lines/5*10dots
	ACALL	COMMAND
	MOV	A,#01110B   ; display ON
	ACALL	COMMAND
	MOV	A,#1     ;clear display
	ACALL	COMMAND
	ACALL	DELAY2MS
	MOV	A,#010000000B   ;DD RAM address =0
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP
ENDMES:
	SJMP	$
COMMAND:
	MOV	P0,A
	MOV	P1,#0100B    ;E=1 , RW=0 , RS=0
	MOV	P1,#0000B    ;E=0 , RW=0 , RS=0
	ACALL	DELAY40US
	RET
SDATA:
	MOV	P0,A
	MOV	P1,#0101B    ;E=1 , RW=0 , RS=1
	MOV	P1,#0001B    ;E=0 , RW=0 , RS=1
	ACALL	DELAY40US
	RET

DELAY40US:
	MOV	R1,#20
	DJNZ	R1,$
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
	END
%}


%{lcd1b.a51
;
;   Display "Hello!!" on Text LCD (synchronize by delay method)
;
START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B    ; display ON
	ACALL	COMMAND
	MOV	A,#1     ;clear display
	ACALL	COMMAND
	ACALL	DELAY2MS
	MOV	A,#010000000B   ;DD RAM address =0
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP
ENDMES:
	SJMP	$
COMMAND:
	MOV	P0,A
	MOV	P1,#0100B    ;E=1 , RW=0 , RS=0
	MOV	P1,#0000B    ;E=0 , RW=0 , RS=0
	ACALL	DELAY40US
	RET
SDATA:
	MOV	P0,A
	MOV	P1,#0101B    ;E=1 , RW=0 , RS=1
	MOV	P1,#0001B    ;E=0 , RW=0 , RS=1
;	ACALL	DELAY40US
;	RET

DELAY40US:
	MOV	R1,#20
	DJNZ	R1,$
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
	END
%}


@1
%{lcd1.c
//
//   Display "Hello!!" on Text LCD (synchronize by delay method)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
char code mes[]="Hello!!" ;
void delay2ms()
{
	Delay1ms() ;
	Delay1ms() ;
}
void delay5ms()
{
	delay2ms() ;
	delay2ms() ;
	Delay1ms() ;
}
void delay40us()
{
	int i ;
	for(i=0 ; i < 5 ;i++) ;
}
void Command(cmd){
	P0=cmd ;
	P1=0x4 ;    //E=1 , RW=0 , RS=0
	P1=0;       //E=0 , RW=0 , RS=0
	delay40us() ;
}
void Data(char data1){
	P0=data1;
	P1=0x5;     //E=1 , RW=0 , RS=1
	P1=0x1 ;    //E=0 , RW=0 , RS=1
	delay40us() ;
}
main()
{
	char code1 ;
	char i ;
	char code *pp=mes ;
	delay5ms() ;            // wait for LCD Power-on Ready
	Command(0x3f) ;         // 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;          // display ON
	Command(0x1) ;          // clear display
	delay2ms() ;
	Command(0x80) ;         // DD RAM address=0
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	for(;;) ;
}
%}


%{lcd2.a51
;
;   Display "Hello!!" on Text LCD ( synchronize by delay method , and bit operation instruction)
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B    ; display ON
	ACALL	COMMAND
	MOV	A,#1     ;clear display
	ACALL	COMMAND
	ACALL	DELAY2MS
	MOV	A,#010000000B   ;DD RAM address =0
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP
ENDMES:
	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	ACALL	DELAY40US
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
DELAY40US:
	MOV	R1,#20
	DJNZ	R1,$
	RET

DELAY5MS:
 	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
	END
%}


@1
%{lcd2.c
//
//   Display "Hello!!" on Text LCD ( synchronize by delay method , and bit operation instruction)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes[]="Hello!!" ;
void delay2ms()
{
	Delay1ms() ;
	Delay1ms() ;
}
void delay5ms()
{
	delay2ms() ;
	delay2ms() ;
	Delay1ms() ;
}
void delay40us()
{
	int i ;
	for(i=0 ; i < 5 ;i++) ;
}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ;
	delay40us() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ;
	delay40us() ;
}
main()
{
	char code1 ;
	char i ;
	char code *pp=mes ;

	delay5ms() ;            // wait for LCD Power-on Ready
	Command(0x3f) ;         // 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;          // display ON
	Command(0x1) ;          // clear display
	delay2ms() ;
	Command(0x80) ;         // DD RAM address=0
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	for(;;) ;
}
%}


%{lcd3.a51
;
;   Display "Hello!!" on Text LCD ( synchronize by checking BF method , and bit operation instruction)
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B    ; display ON
	ACALL	COMMAND
	MOV	A,#1     ;clear display
	ACALL	COMMAND
	ACALL	DELAY2MS
	MOV	A,#010000000B   ;DD RAM address =0
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP
ENDMES:
	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	SETB	RW
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
	SETB	RW
WAITLCD:
	MOV	P0,#0FFH  ; 
WAITLCD1:
	CLR	RS
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
	END
%}


@1
%{lcd3.c
//
//   Display "Hello!!" on Text LCD ( synchronize by checking BF method , and bit operation instruction)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes[]="Hello!!" ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // 
	do{
  	    RS=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0

}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
main()
{
	char code *pp=mes ;

	delay5ms() ;            // wait for LCD Power-on Ready
	Command(0x3f) ;         // 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;          // display ON
	Command(0x1) ;          // clear display
	delay2ms() ;
	Command(0x80) ;         // DD RAM address=0
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	for(;;) ;
}
%}


%{lcd4a.a51
;
;   Display 4 "Hello!!" on Text LCD, 
;      at line 1 location 1 , line 1 location 11 ,
;         line 2 location 1 , and line 2 location 11
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B    ; display ON
	ACALL	COMMAND
	MOV	A,#1     ;clear display
	ACALL	COMMAND
	ACALL	DELAY2MS
	MOV	A,#010000000B   ;DD RAM address =0
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP1:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES1
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP1
ENDMES1:

	MOV	A,#010000000B+10   ; DD RAM address=10-->line 1 location 11
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP2:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES2
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP2
ENDMES2:
	MOV	A,#010000000B+40H   ; DD RAM address=40H--->line 2 location 1
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP3:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES3
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP3
ENDMES3:
	MOV	A,#010000000B+40H+10   ;DD RAM address=40H+10--->line 2 location 11
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP4:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES4
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP4
ENDMES4:
	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
WAITLCD:
	MOV	P0,#0FFH  ; 
WAITLCD1:
	CLR	RS
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
	END
%}


%{lcd4b.a51
;
;   Display 4 "Hello!!" on Text LCD, 
;      at line 1 location 1 , line 1 location 11 ,
;         line 2 location 1 , and line 2 location 11
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

DSPSTR	MACRO	LOC
%1 	LOCAL	LOOP,ENDMES
	MOV	A,#LOC
	ACALL	COMMAND
	MOV	DPTR,#MES
%0 $1:
%1 LOOP:
%2 LOOP#:
	CLR	A
	MOVC	A,@A+DPTR
%0 	JZ	$2
%1 	JZ	ENDMES
%2 	JZ	ENDMES#
	ACALL	SDATA
	INC	DPTR
%0 	SJMP	$1
%0 $2:
%1 	SJMP	LOOP
%1 ENDMES:
%2 	SJMP   LOOP#
%2 ENDMES#:
	ENDM

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B    ; display ON
	ACALL	COMMAND
	MOV	A,#1     ;clear display
	ACALL	COMMAND

	DSPSTR	010000000B      ; DD RAM address = 0-->line 1 location 1
	DSPSTR	010000000B+10   ; DD RAM address =10--> line 1 location 11
	DSPSTR	010000000B+40H   ; DD RAM address =40H---> line 2 location 1
	DSPSTR	010000000B+40H+10   ; DD RAM address =40H+10---> line 2 location 11

	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
WAITLCD:
	MOV	P0,#0FFH  ; 
WAITLCD1:
	CLR	RS
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
	END
%}


%{lcd4c.a51
;
;   Display 4 "Hello!!" on Text LCD,
;     at line 1 location 1 , line 1 location 11 ,
;      line 2 location 1 , and line 2 location 11
;
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B    ; display ON
	ACALL	COMMAND
	MOV	A,#1     ;clear display
	ACALL	COMMAND

	MOV	R0,#0
NEXT1:
	MOV	DPTR,#LOC
	MOV	A,R0
	MOVC	A,@A+DPTR
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP
ENDMES:
	INC	R0
	CJNE	R0,#4,NEXT1

	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
WAITLCD:
	MOV	P0,#0FFH  ; 
WAITLCD1:
	CLR	RS
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET

DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
LOC:	DB	010000000B
	DB	010000000B+10
	DB	010000000B+40H
	DB	010000000B+40H+10
	END
%}


%{lcd4d.a51
;
; Display 4 "Hello!!" on Text LCD,
;     at line 1 location 1 , line 1 location 11 ,
;       line 2 location 1 , and line 2 location 11
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B    ; display ON
	ACALL	COMMAND
	MOV	A,#1     ;clear display
	ACALL	COMMAND

	MOV	R0,#4
NEXT1:
	MOV	DPTR,#LOC-1
	MOV	A,R0
	MOVC	A,@A+DPTR
	ACALL	COMMAND
	MOV	DPTR,#MES
LOOP:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP
ENDMES:
	DJNZ	R0,NEXT1
	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
WAITLCD:
	MOV	P0,#0FFH  ; 
WAITLCD1:
	CLR	RS
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"Hello!!",0
LOC:	DB	010000000B+40H+10
	DB	010000000B+40H
	DB	010000000B+10
	DB	010000000B
	END
%}


@1
%{lcd4a.c
//
//   Display 4 "Hello!!" on Text LCD,
//     at line 1 location 1 , line 1 location 11 ,
//      line 2 location 1 , and line 2 location 11
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes[]="Hello!!" ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++)  Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // 
	do{
	    RS=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0
}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
main()
{
	char code *pp=mes ;

	delay5ms() ;            // wait for LCD Power-on Ready
	Command(0x3f) ;         // 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;          // display ON
	Command(0x1) ;          // clear display
	delay2ms() ;
	Command(0x80) ;         // DD RAM address=0
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	Command(0x80+10) ;  // DD RAM address=10-->line 1 location 11
	pp=mes ;
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	Command(0x80+0x40) ;  // DD RAM address=0x40--> line 2 location 1
	pp=mes ;
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	Command(0x80+0x40+10) ;  // DD RAM address=0x40+10--> line 2 location 11
	pp=mes ;
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	for(;;) ;
}
%}


@1
%{lcd4b.c
//
//   Display 4 "Hello!!" on Text LCD,
//     at line 1 location 1 , line 1 location 11 ,
//       line 2 location 1 , and line 2 location 11
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes[]="Hello!!" ;
#define DSPSTR(loc)		\
	Command(loc) ;		\
	for(pp=mes; *pp !=0 ;){	\
	    Data(*pp++);		\
	}

void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // 
	do{
	    RS=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0
}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
main()
{
	char code *pp ;

	delay5ms() ;            // wait for LCD Power-on Ready
	Command(0x3f) ;         // 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;          // display ON
	Command(0x1) ;          // clear display

	DSPSTR(0x80) ;          // line 1 location 1
	DSPSTR(0x80+10) ;       // line 1 location 11
	DSPSTR(0x80+0x40) ;     // line 2 location 1
	DSPSTR(0x80+0x40+10) ;  // line 2 location 11
	for(;;) ;
}
%}


@1
%{lcd4c.c
//
//   Display 4 "Hello!!" on Text LCD,
//     at line 1 location 1 , line 1 location 11 ,
//       line 2 location 1 , and line 2 location 11
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes[]="Hello!!" ;
unsigned char code loc[]= {0x80,0x80+10 , 0x80+0x40,0x80+0x40+10} ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++)  Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // 
	do{
	    RS=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0
}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ; RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
main()
{
	char code *pp ;
	char i ;	

	delay5ms() ;            // wait for LCD Power-on Ready
	Command(0x3f) ;         // 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;          // display ON
	Command(0x1) ;          // clear display
	for(i=0 ; i < 4 ; i++){
   	    Command(loc[i]) ;
	    for(pp=mes; *pp !=0 ;){
		Data(*pp++);
	    }
	}
	for(;;) ;
}
%}


%{lcd5.a51
;
;   Display "1998"nian"10"yue"16"ri"" on Text LCD
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B    ; display ON
	ACALL	COMMAND
	MOV	A,#1     ;clear display
	ACALL	COMMAND

;      define font of  "nian" "yue" "ri"
	MOV	A,#001000000B   ;CG RAM address=0
	ACALL	COMMAND
	MOV	DPTR,#CG
	MOV	R0,#3*8
LOOP1:
	CLR	A
	MOVC	A,@A+DPTR
	ACALL	SDATA
	INC	DPTR
	DJNZ	R0,LOOP1

	MOV	A,#010000000B   ; DD RAM address=0
	ACALL	COMMAND
	MOV	DPTR,#MES
	MOV	R0,#11
LOOP2:
	CLR	A
	MOVC	A,@A+DPTR
	ACALL	SDATA
	INC	DPTR
	DJNZ	R0,LOOP2

	SJMP	$
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	SETB	RW
	ACALL	WAITLCD
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
	SETB	RW
WAITLCD:
	MOV	P0,#0FFH  ; 
WAITLCD1:
	CLR	RS
	SETB	RW
	SETB	E
	MOV	A,P0
	CLR	E
	ANL	A,#80H
	JNZ	WAITLCD1
	RET
DELAY5MS:
	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES:	DB	"1998",0,"10",1,"16",2
CG:	DB	010H , 01fH , 002H , 00fH , 00aH , 0ffH , 002H , 000H  ; "nian"
	DB	00fH , 009H , 00fH , 009H , 00fH , 009H , 013H , 000H  ; "yue"
	DB	00fH , 009H , 009H , 00fH , 009H , 009H , 00fH , 000H  ; "ri"

	END
%}


@1
%{lcd5.c
//
//   Display "1998"nian"10"yue"16"ri"" on Text LCD
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes[]="1998\00010\00116\002" ;
char code CG[]={
	0x10 , 0x1f , 0x02 , 0x0f , 0x0a , 0xff , 0x02 , 0x00 , // "nian"
	0x0f , 0x09 , 0x0f , 0x09 , 0x0f , 0x09 , 0x13 , 0x00 , // "yue"
	0x0f , 0x09 , 0x09 , 0x0f , 0x09 , 0x09 , 0x0f , 0x00 , // "ri"
} ;
void delay5ms()
{
	char i=0 ;
	for(i=0 ; i < 5 ; i++) Delay1ms();
}
void waitlcd()
{
	unsigned char status;

	P0=0xff ; // 
	do{
	    RS=0;RW=1;E=1;
	    status= P0 ;
	    E=0 ;
	}
	while(status&0x80) ; // wait until BF=0

}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ;RW=1 ;
	waitlcd() ;
}
main()
{
	char code *pp ;
	char i ;

	delay5ms() ;            // wait for LCD Power-on Ready
	Command(0x3f) ;         // 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;          // display ON
	Command(0x1) ;          // clear display
	// define font of  "nian" "yue" "ri"
	Command(0x40) ;   // CG RAM address=0
	pp= CG ;
	for(i=0 ; i < 3*8 ; i++){
	    Data(*pp++) ;
	}
	Command(0x80) ;    // DD RAM address=0
	for(pp= mes,i=0; i<11 ;i++){
	    Data(*pp++);
	}
	for(;;) ;
}
%}

%{lcd6.a51
;
;   Test Text LCD in double-line shift the left(right) mode
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0111111B  ; 8 bits data bus/2 lines/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B    ; display ON
	ACALL	COMMAND
	MOV	A,#1     ;clear display
	ACALL	COMMAND
	ACALL	DELAY2MS
	MOV	A,#010000000B   ;DD RAM address =0
	ACALL	COMMAND
	MOV	DPTR,#MES1
LOOP1:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES1
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP1
ENDMES1:

	MOV	A,#011000000B   ; DD RAM address=40h(line 2)
	ACALL	COMMAND
	MOV	DPTR,#MES2
LOOP2:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES2
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP2
ENDMES2:
LOOP3:
	MOV	A,#18H     ;18H---left shift/1CH---right shift
	ACALL	COMMAND
	LCALL	Delay1s
	SJMP	LOOP3
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	ACALL	DELAY40US
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
DELAY40US:
	MOV	R1,#20
	DJNZ	R1,$
	RET

DELAY5MS:
 	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES1:	DB	"          111111111122222222223333333333",0
MES2:	DB	"0123456789012345678901234567890123456789",0
	END
%}


@1
%{lcd6.c
//
//   Test Text LCD in double-line shift the left(right) mode
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes1[]="          111111111122222222223333333333" ;
char code mes2[]="0123456789012345678901234567890123456789" ;
void delay2ms()
{
	Delay1ms() ;
	Delay1ms() ;
}
void delay5ms()
{
	delay2ms() ;
	delay2ms() ;
	Delay1ms() ;
}
void delay40us()
{
	int i ;
	for(i=0 ; i < 5 ;i++) ;
}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ;
	delay40us() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ;
	delay40us() ;
}
main()
{
	char code1 ;
	char i ;
	char code *pp=mes1 ;

	delay5ms() ;            // wait for LCD Power-on Ready
	Command(0x3f) ;         // 8 bits data bus/2 lines/5*10 dots
	Command(0xe) ;          // display ON
	Command(0x1) ;          // clear display
	delay2ms() ;
	Command(0x80) ;         // DD RAM address=0
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	Command(0xC0) ;   // DD RAM address=40H(line 2)
	pp=mes2 ;
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	for(;;){
	    Command(0x18) ;// 0x18---left shift/0x1c----right shift
	    Delay1s() ;
	}
}
%}

%{lcd7.a51
;
;   Test Text LCD in single-line shift the left(right) mode
;
E	REGEQU	P1.2
RW	REGEQU	P1.1
RS	REGEQU	P1.0

START:
	ACALL	DELAY5MS     ; wait for LCD Power-on Ready
	MOV	A,#0110111B  ; 8 bits data bus/1 line/5*10 dots
	ACALL	COMMAND
	MOV	A,#01110B    ; display ON
	ACALL	COMMAND
	MOV	A,#1     ;clear display
	ACALL	COMMAND
	ACALL	DELAY2MS
	MOV	A,#010000000B   ;DD RAM address =0
	ACALL	COMMAND
	MOV	DPTR,#MES1
LOOP1:
	CLR	A
	MOVC	A,@A+DPTR
	JZ	ENDMES1
	ACALL	SDATA
	INC	DPTR
	SJMP	LOOP1
ENDMES1:
LOOP3:
	MOV	A,#18H     ;18H---left shift/1CH---right shift
	ACALL	COMMAND
	LCALL	Delay1s
	SJMP	LOOP3
COMMAND:
	MOV	P0,A
	SETB	E
	CLR	RW
	CLR	RS
	CLR	E
	ACALL	DELAY40US
	RET
SDATA:
	MOV	P0,A
	SETB	E
	CLR	RW
	SETB	RS
	CLR	E
DELAY40US:
	MOV	R1,#20
	DJNZ	R1,$
	RET

DELAY5MS:
 	ACALL	DELAY1MS
	ACALL	DELAY2MS
	ACALL	DELAY2MS
	RET
DELAY2MS:
	ACALL	DELAY1MS
	ACALL	DELAY1MS
	RET

%0,2 	include delay.inc
%1 	$include (delay.inc)

MES1:	DB	"0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ",0
	END
%}


@1
%{lcd7.c
//
//   Test Text LCD in single-line shift the left(right) mode
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
sbit RS=P1 ^0 ;
sbit RW=P1 ^1 ;
sbit E=P1 ^2 ;
char code mes1[]="0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 " ;
void delay2ms()
{
	Delay1ms() ;
	Delay1ms() ;
}
void delay5ms()
{
	delay2ms() ;
	delay2ms() ;
	Delay1ms() ;
}
void delay40us()
{
	int i ;
	for(i=0 ; i < 5 ;i++) ;
}
void Command(cmd){
	P0=cmd ;
	RS=0 ; RW=0 ; E=1;E=0 ;
	delay40us() ;
}
void Data(char data1){
	P0=data1;
	RS=1 ;RW=0;E=1;E=0 ;
	delay40us() ;
}
main()
{
	char code1 ;
	char i ;
	char code *pp=mes1 ;

	delay5ms() ;            // wait for LCD Power-on Ready
	Command(0x37) ;         // 8 bits data bus/1 lines/5*10 dots
	Command(0xe) ;          // display ON
	Command(0x1) ;          // clear display
	delay2ms() ;
	Command(0x80) ;         // DD RAM address=0
	for(; *pp !=0 ;){
	    Data(*pp++);
	}
	for(;;){
	    Command(0x18) ;// 0x18---left shift/0x1c----right shift
	    Delay1s() ;
	}
}
%}



%{led321.a51
;
;    8 pieces of LED in P0  change state by  binary counter;
;    8 pieces of LED in P1 interchange state between 
;      OFF-ON-OFF-ON-OFF-ON-OFF-ON and ON-OFF-ON-OFF-ON-OFF-ON-OFF  ;
;    8 pieces of LED in P2(only 1 piece of LED is ON)change state by ON-LED to rotate left;
;    8 pieces of LED in P3(only 1 piece of LED is ON)change state  by ON-LED to rotate right;
;
START:
	MOV	P0,#0
	MOV	P1,#55H
	MOV	P2,#1
	MOV	P3,#1
LOOP:
	INC	P0          ; P0 binary counter

	MOV	A,P1        ; P1 0x55/0xaa interchange
	CJNE	A,#55H,FILL55H
	MOV	P1,#0AAH
	AJMP	NEXT1
FILL55H:
	MOV	P1,#055H
NEXT1:

	MOV	A,P2        ;P2  left rotate
	RL	A
	MOV	P2,A

	MOV	A,P3        ;P3 right rotate
	RR	A
	MOV	P3,A

	ACALL	DELAY100MS
	SJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


@1
%{led321.c
//
//    8 pieces of LED in P0  change state by  binary counter;
//    8 pieces of LED in P1 interchange state between 
//       OFF-ON-OFF-ON-OFF-ON-OFF-ON and ON-OFF-ON-OFF-ON-OFF-ON-OFF
//    8 pieces of LED in P2(only 1 piece of LED is ON)change state by ON-LED to rotate left;
//    8 pieces of LED in P3(only 1 piece of LED is ON)change state  by ON-LED to rotate right 
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"
main()
{
	char i ;
	int j ;

	P0=0 ;
	P1=0x55 ;
	P2=P3=0x1 ;
	for(;;) {
	    Delay100ms() ;
	    P0++ ;        // P0 binary counter
	    P1=(P1== 0x55)? 0xaa : 0x55 ; //P1 0x55/0xaa interchange
	    if(P2 ==0x80){  //P2 left rotate
		P2= 0x1 ;
	    }
	    else{
		P2 <<=1 ;
	    }
	    if(P3== 0x1){      //P3 right rotate
		P3= 0x80 ;
	    }
	    else{
		P3 >>=1  ;
	    }
	}
}
%}


%{led81.a51
;
;     ON-LED  rotate  right
;

	MOV	A,#11000000B
START:
	MOV	P0,A

	ACALL	DELAY100MS
	RR	A
	SJMP	START

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


@1
%{led81.c
//
//       ON-LED  rotate  right
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"

main()
{
	P0 =0xc0;
	for(;;) {
	    Delay100ms() ;
	    if(P0&0x01){                 //P0 rotate right 1 bit
		P0 >>=1 ;
		P0 |=0x80 ;
	    }
	    else{
		P0 >>= 1 ;
	    }
	}
}
%}


%{led82a.a51
;
;   1. When the most left  LED is OFF ====>OFF-LED rotate right
;   2. When the most right LED is OFF ====>OFF-LED rotate  left
;
	MOV	P0,#01111111B
RIGHT:
	JNB	P0.0,LEFT
	ACALL	DELAY100MS
	MOV	A,P0
	RR	A
	MOV	P0,A
	SJMP	RIGHT
LEFT:
	ACALL	DELAY100MS
	JNB	P0.7,RIGHT
	MOV	A,P0
	RL	A
	MOV	P0,A
	SJMP	LEFT

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


%{led82b.a51
;
; 1. When the most left  LED is OFF ====>OFF-LED rotate right
; 2. When the most right LED is OFF ====>OFF-LED rotate  left
;
START:
	MOV	DPTR,#TBL1
	MOV	R2,#14
LOOP:
	MOV	A,#0
	MOVC	A,@A+DPTR
	INC	DPTR
	MOV	P0,A
	ACALL	DELAY100MS
	DJNZ	R2,LOOP
	LJMP	START

%0,2 	include delay.inc
%1 	$include (delay.inc)

TBL1:
	DB	01111111B
	DB	10111111B
	DB	11011111B
	DB	11101111B
	DB	11110111B
	DB	11111011B
	DB	11111101B
	DB	11111110B
	DB	11111101B
	DB	11111011B
	DB	11110111B
	DB	11101111B
	DB	11011111B
	DB	10111111B
	END
%}


@1
%{led82a.c
//
//      1. When the most left  LED is OFF ====>OFF-LED rotate right
//      2. When the most right LED is OFF ====>OFF-LED rotate  left
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"
enum {LEFT,RIGHT} ;
main()
{
	char State ;
	P0 =0x7f;
	State=RIGHT ;
	for(;;) {
	    Delay100ms() ;
	    if(State == RIGHT){
		P0 >>= 1;
		P0 |=0x80 ;
	    }
	    if(State == LEFT){
		P0 <<= 1;
		P0 ++ ;
	    }
	    if((P0&0x1)==0){
		State= LEFT ;
	    }
	    if((P0&0x80)==0){
		State= RIGHT ;
	    }
	}
}
%}


@1
%{led82b.c
//
//   1. When the most left  LED is OFF ====>OFF-LED rotate right
//   2. When the most right LED is OFF ====>OFF-LED rotate  left 
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"
code tbl1[]= { 0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf } ;
main()
{
	char i ;
	for(;;) {
	    for(i = 0 ; i < 14 ; i++ ){
		P0=tbl1[i] ;
		Delay100ms() ;
	    }
	}
}
%}


@1
%{mkdisasm.c
//
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>

char p[]={
	'M','U','L',' ','A','B',0,
	'X','C','H',' ','A',',','@','R','0',0,
	'X','C','H',' ','A',',','T','C','O','N',0
};

void main ()
{
	unsigned char c, i, j;
	int len;

	P2=0xff;
	for(;;){
	    // trigger input
	    P2 = P2|0x01;
	    P2 = P2&0xfe;
	    // read MACHINE CODE
	    c = P0;

	    // ending  all data when 0xa5
	    if( c == 0xa5 ){
		for(i=0;i<28;i++){
		    // write ASCII CODE
		    P1 = p[i];
		    // trigger output
		    P2 = P2|0x02;
		    P2 = P2&0xfd;
		}

		// stop operation
		P2 = P2&0xfb;
		break;
	    }
	    else{
		// process data
	    }
	}
	for(;;);
}
%}


@1
%{mklinasm.c
//
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>

unsigned char code tt[]={0xa4, 0xa5, 0xc6, 0xa5, 0xc5, 0x88, 0xa5};

void main ()
{
	unsigned char c, flag=0;
	int j=0;

	P2=0xff;
	for(;;){
	    // trigger input
	    P2 = P2|0x01;
	    P2 = P2&0xfe;
	    // read ASCII CODE
	    c = P0;

	    if( c==0 ){
		if(flag==1 ){
		    for(j=0; j < 7; j++){
			// write MACHINE CODE
			P1=tt[j];
			// trigger output
			P2 = P2|0x02;
			P2 = P2&0xfd;
		    }
		    // stop
		    P2 = P2&0xfb;
		    break;
		}
		else{
		    flag=1;
		}
	    }
	    else{
		flag = 0;
	    }
	}
	for(;;);
}
%}


@1
%{ptr1.c
//
//  The typed pointer to internal data memory can be stored using 1 byte
//  typed pointer to program memory can be stored using 2 bytes
//  untyped pointers are always stored using 3 bytes
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
char data *pd ;
char code *pc ;
char *pp ;
void main()
{
char s1,s2,s3 ;
s1 = sizeof(pd) ;
s2 =  sizeof(pc) ;
s3 = sizeof(pp) ;
}
%}


@1
%{ptr2a.c
//
// Demonstrate the access of char data *pd
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
char data *pd ;
void main()
{
	char v1,v2,v3;
	char i ;
	v1=*pd ;
	v2=*(pd+1) ;
	v3=*(pd+i) ;
}
%}


@1
%{ptr2b.c
//
// Demonstrate the access of char data *pd
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
char data *pd ;
void main()
{
	char v1,v2,v3;
	char i ;
	v1=pd[0] ;
	v2=pd[1] ;
	v3=pd[i] ;
}
%}


@1
%{ptr3a.c
//
//    Demonstrate the access of int data *pd
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
int data *pd ;
void main()
{
	int v1,v2,v3;
	char i ;
	v1=*pd ;
	v2=*(pd+1) ;
	v3=*(pd+i) ;
}
%}


@1
%{ptr3b.c
//
//    Demonstrate the access of int data *pd
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
int data *pd ;
void main()
{
	int v1,v2,v3;
	char i ;
	v1=pd[0] ;
	v2=pd[1] ;
	v3=pd[i] ;
}
%}


@1
%{ptr4a.c
//
//    Demonstrate the access of long data *pd
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
long data *pd ;
void main()
{
	long v1,v2,v3;
	char i ;
	v1=*pd ;
	v2=*(pd+1) ;
	v3=*(pd+i) ;
}
%}


@1
%{ptr4b.c
//
//    Demonstrate the access of long data *pd
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
long data *pd ;
void main()
{
	long v1,v2,v3;
	char i ;
	v1=pd[0] ;
	v2=pd[1] ;
	v3=pd[i] ;
}
%}


@1
%{rs2321.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
code char mes[]="Hello!!" ;
main()
{
	char *s ;
	SM0=0 ;
	SM1=1 ; // Serial port in  Mode 1
	TMOD=0x20 ; // Timer1 in Mode 2
	TH1=TL1= 0xfd  ; // 0xfd:baud rate 9600/0xfa:4800
	TR1=1 ; // Enable timer 
	for(s=mes;*s != '\0' ;){
	    SBUF=*s++ ;
	    while(TI==0) ;
	    TI=0 ;
	}
	for(;;) ;
}
%}


@1
%{rs2322.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char buf[10] ;
char idx ;
main()
{
	idx=0 ;
	SM0=0 ;
	SM1=1 ; // Serial port in  Mode 1
	TMOD=0x20 ; // Timer1 in Mode 2
	TH1=TL1= 0xfd  ; // 0xfd:baud rate 9600/0xfa:4800
	TR1=1 ; // Enable timer
	REN=1 ;
	for(;;){
	    while(RI==0) ;
	    RI=0 ;
 	    buf[idx++]=SBUF ;
	}
}
%}


@1
%{rs2323.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char buf[10] ;
char idx ;
main()
{
	idx=0 ;
	SM0=0 ;
	SM1=1 ; // Serial port in  Mode 1
	TMOD=0x20 ; // Timer1 in Mode 2
	TH1=TL1= 0xfd  ; // 0xfd:baud rate 9600/0xfa:4800
	TR1=1 ; // Enable timer
	REN=1 ;
	for(;;){
	    while(RI==0) ;
	    RI=0 ;
 	    c=SBUF ;
	    SBUF=c ;
	    while(TI==0) ;
	    TI=0 ;
	}
}
%}


%{ssled1.a51
;
;  Sequence ON a-segment, b-segment, c-segment, d-segment, e-segment, f-segment, g-segment , and dot-segment on Seven-Segment LED
;
START:
	MOV	P0,#0FEH
LOOP:
	ACALL	DELAY100MS
	MOV	A,P0
	RL	A
	MOV	P0,A
	AJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


@1
%{ssled1.c
//
//    Sequence ON a-segment, b-segment, c-segment, d-segment, e-segment, f-segment, g-segment , and dot-segment on Seven-Segment LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
main()
{
	P0=0xfe ;
	for(;;){
	    Delay100ms() ;
	    P0 <<=1 ;
	    P0 +=1 ;
	    if(P0 ==0xff){
		P0=0xfe ;
	    }
	}
}
%}


%{ssled2a.a51
;
;  Sequence display number 0,1,2,3,4,5,6,7,8,9 on Seven-Segment LED
;
START:
	MOV	R2,#0
LOOP:
	MOV	A,R2
	MOV	DPTR,#SSTBL
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R2
	CJNE	R2,#10,NEXT1
	MOV	R2,#0
NEXT1:
	ACALL	DELAY100MS
	AJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

SSTBL:
	DB	0C0H
	DB	0F9H
	DB	0A4H,0B0H,099H
	DB	092H,082H,0F8H,080H,090H

	END
%}


%{ssled2b.a51
;
;  Sequence display number 0,1,2,3,4,5,6,7,8,9 on Seven-Segment LED
;
START:
	MOV	R2,#0
	MOV	DPTR,#SSTBL   ; 
LOOP:
	MOV	A,R2
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R2
	CJNE	R2,#10,NEXT1
	MOV	R2,#0
NEXT1:
	ACALL	DELAY100MS
	AJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

SSTBL:
	DB	0C0H
	DB	0F9H
	DB	0A4H,0B0H,099H
	DB	092H,082H,0F8H,080H,090H

	END
%}


@1
%{ssled2.c
//
//     Sequence display number 0,1,2,3,4,5,6,7,8,9 on Seven-Segment LED
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code sstbl[]= { 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90} ;
main()
{
	char i ;
	i=0 ;
	for( ; ;){
	    P0=sstbl[i++] ;
	    if(i >=10){
		i=0 ;
	    }
	    Delay100ms() ;
	}
}
%}


%{ssled3.a51
;
;  Display number string "1234" on 4 pieces of Seven-Segment LED; the scanning interval is 100ms
;
START:
	MOV	R2,#0
LOOP:
	MOV	P1,#0FFH   ;  close common anode

 	MOV	A,R2
	INC	A
	MOV	DPTR,#SSTBL
	MOVC	A,@A+DPTR
	MOV	P0,A

	MOV	A,R2
	MOV	DPTR,#LOC
	MOVC	A,@A+DPTR
	MOV	P1,A

	INC	R2
	CJNE	R2,#4,NEXT1
	MOV	R2,#0
NEXT1:
	ACALL	DELAY100MS
	AJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

SSTBL:
	DB	0C0H
	DB	0F9H
	DB	0A4H,0B0H,099H
	DB	092H,082H,0F8H,080H,090H
LOC:
	DB	0F7H,0FBH,0FDH,0FEH
	END
%}


@1
%{ssled3.c
//
//    Display number string "1234" on 4 pieces of Seven-Segment LED; the scanning interval is 100ms
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code sstbl[]= { 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90} ;
unsigned char code loc[]={ 0xf7,0xfb,0xfd,0xfe} ;
main()
{
	char i ;
	i=0 ;
	for( ; ;){
	    P1=0xff ;     //close common anode
	    P0=sstbl[i+1] ;
	    P1=loc[i++] ;
	    if(i >=4){
		i=0 ;
	    }
	    Delay100ms() ;
	}
}
%}


%{ssled4.a51
;
;  Display number string "1234" on 4 pieces of Seven-Segment LED; the scanning interval is 1ms
;
START:
	MOV	R2,#0
LOOP:
	MOV	P1,#0FFH   ;  close common anode

	MOV	A,R2
	INC	A
	MOV	DPTR,#SSTBL
	MOVC	A,@A+DPTR
	MOV	P0,A

	MOV	A,R2
	MOV	DPTR,#LOC
	MOVC	A,@A+DPTR
	MOV	P1,A

	INC	R2
	CJNE	R2,#4,NEXT1
	MOV	R2,#0
NEXT1:
	ACALL	DELAY1MS
	AJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

SSTBL:
	DB	0C0H
	DB	0F9H
	DB	0A4H,0B0H,099H
	DB	092H,082H,0F8H,080H,090H
LOC:
	DB	0F7H,0FBH,0FDH,0FEH
	END
%}


@1
%{ssled4.c
//
//    Display number string "1234" on 4 pieces of Seven-Segment LED; the scanning interval is 1ms
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code sstbl[]= { 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90} ;
unsigned char code loc[]={ 0xf7,0xfb,0xfd,0xfe} ;
main()
{
	char i ;
	i=0 ;
	for( ; ;){
	    P1=0xff ;     // close common anode
	    P0=sstbl[i+1] ;
	    P1=loc[i++] ;
	    if(i >=4){
		i=0 ;
	    }
	    Delay1ms() ;
	}
}
%}


%{ssled5.a51
;
;   Display number string "1234" on 4 pieces of Seven-Segment LED;
;     the scanning interval is 1ms * DIP Switch setting (on P2)
;
START:
	MOV	R2,#0
LOOP:
	MOV	P1,#0FFH   ;  close common anode

	MOV	A,R2
	INC	A
	MOV	DPTR,#SSTBL
	MOVC	A,@A+DPTR
	MOV	P0,A

	MOV	A,R2
	MOV	DPTR,#LOC
	MOVC	A,@A+DPTR
	MOV	P1,A

	INC	R2
	CJNE	R2,#4,NEXT1
	MOV	R2,#0
NEXT1:
	MOV	A,P2
	CPL	A
	JZ	NEXT3
	MOV	R3,A

NEXT2:
	ACALL	DELAY1MS
	DJNZ	R3,NEXT2
NEXT3:
	AJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

SSTBL:
	DB	0C0H
	DB	0F9H
	DB	0A4H,0B0H,099H
	DB	092H,082H,0F8H,080H,090H
LOC:
	DB	0F7H,0FBH,0FDH,0FEH
	END
%}


@1
%{ssled5.c
//
//    Display number string "1234" on 4 pieces of Seven-Segment LED;
//    the scanning interval is 1ms * DIP Switch setting (on P2)
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code sstbl[]= { 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90} ;
unsigned char code loc[]={ 0xf7,0xfb,0xfd,0xfe} ;
main()
{
	char i ;
	unsigned char j;
	i=0 ;
	for( ; ;){
	    P1=0xff ;     //close common anode
	    P0=sstbl[i+1] ;
	    P1=loc[i++] ;
	    if(i >=4){
		i=0 ;
	    }
	    for(j=0 ; j < ~P2;j++){
 		Delay1ms() ;
	    }
	}
}
%}


%{ssled6.a51
;
;   Display number(DIP Switch setting (onP2/P3)) on 4 pieces of Seven-Segment LED;
;   the scanning interval is 7ms
;
START:
	MOV	R2,#0
	MOV	DPTR,#SSTBL
LOOP:
	MOV	P1,#0FFH   ;  close common anode

	CJNE	R2,#0,LOC1
	INC	R2
	MOV	A,P2
	CPL	A
	SWAP	A
	ANL	A,#0FH
	MOVC	A,@A+DPTR
	MOV	P0,A
	MOV	P1,#0F7H
	SJMP	DELAY
LOC1:
	CJNE	R2,#1,LOC2
	INC	R2
	MOV	A,P2
	CPL	A
	ANL	A,#0FH
	MOVC	A,@A+DPTR
	MOV	P0,A
	MOV	P1,#0FBH
	SJMP	DELAY
LOC2:
	CJNE	R2,#2,LOC3
	INC	R2
	MOV	A,P3
	CPL	A
	SWAP	A
	ANL	A,#0FH
	MOVC	A,@A+DPTR
	MOV	P0,A
	MOV	P1,#0FDH
	SJMP	DELAY
LOC3:
	MOV	R2,#0
	MOV	A,P3
	CPL	A
	ANL	A,#0FH
	MOVC	A,@A+DPTR
	MOV	P0,A
	MOV	P1,#0FEH
	SJMP	DELAY
DELAY:

	MOV	R3,#7
NEXT2:
	ACALL	DELAY1MS
	DJNZ	R3,NEXT2

	AJMP	LOOP

%0,2 	include delay.inc
%1 	$include (delay.inc)

SSTBL:
	DB	0C0H,0F9H,0A4H,0B0H,099H
	DB	092H,082H,0F8H,080H,090H
	END
%}


@1
%{ssled6.c
//
//   Display number(DIP Switch setting (onP2/P3)) on 4 pieces of Seven-Segment LED
//   the scanning interval is 7ms
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
unsigned char code sstbl[]= { 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e} ;
delay7ms()
{
	char i ;
	for(i=0;i < 7 ;i++){
	    Delay1ms() ;
	}
}
main()
{
	char i ;
	i=0 ;
	for( ; ;){
	    P1=0xff ;  // OFF all LED
	    switch(i){
		case 0:
		    P0 = sstbl[~P2 >> 4] ;
		    P1= 0xf7 ;
		    i++ ;
		    break ;
		case 1:
		    P0 = sstbl[~P2&0xf] ;
		    P1= 0xfb ;
		    i++ ;
 		    break ;
		case 2:
		    P0= sstbl[~P3 >> 4] ;
		    P1=0xfd ;
		    i++ ;
		    break ;
		case 3:
		    P0= sstbl[~P3&0xf] ;
		    P1=0xfe ;
		    i=0 ;
		    break ;
	    }
	    delay7ms() ;
	}
}
%}

%{stepm1a.A51
;
;    Let Stepping Motor clockwise to rotate n steps ,using single-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#00000001B
LOOP:
	MOV	P0,R1
	MOV	A,R1
	RL	A
	CJNE	A,#00010000B,NEXT1
	MOV	A,#00000001B
NEXT1:
	MOV	R1,A
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}


%{stepm1b.A51
;
;   Let Stepping Motor clockwise to rotate n steps ,using single-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#00010001B
LOOP:
	MOV	P0,R1
	MOV	A,R1
	RL	A
	MOV	R1,A
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}

%{stepm2a.A51
;
;    Let Stepping Motor counterclockwise to rotate n steps ,using single-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#00001000B
LOOP:
	MOV	P0,R1
	MOV	A,R1
	RR	A
	CJNE	A,#10000000B,NEXT1
	MOV	A,#00001000B
NEXT1:
	MOV	R1,A
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}


%{stepm2b.A51
;
;   Let Stepping Motor counterclockwise to rotate n steps ,using single-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#00010001B
LOOP:
	MOV	P0,R1
	MOV	A,R1
	RR	A
	MOV	R1,A
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}

%{stepm3a.A51
;
;    Let Stepping Motor clockwise to rotate n steps ,using two-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#0
	MOV	DPTR,#PP
LOOP:
	MOV	A,R1
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R1
	CJNE	R1,#4,NEXT1
	MOV	R1,#0
NEXT1:
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
PP:	
	DB	03H,06H,0CH,09H
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}

%{stepm3b.A51
;
;    Let Stepping Motor clockwise to rotate n steps ,using two-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#00110011B
LOOP:
	MOV	P0,R1
	MOV	A,R1
	RL	A
	MOV	R1,A
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}


%{stepm4a.A51
;
;    Let Stepping Motor counterclockwise to rotate n steps ,using two-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#0
	MOV	DPTR,#PP
LOOP:
	MOV	A,R1
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R1
	CJNE	R1,#4,NEXT1
	MOV	R1,#0
NEXT1:
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
PP:	
	DB	03H,09H,0CH,06H
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}

%{stepm4b.A51
;
;    Let Stepping Motor counterclockwise to rotate n steps ,using two-phase pulse method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#00110011B
LOOP:
	MOV	P0,R1
	MOV	A,R1
	RR	A
	MOV	R1,A
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N+1,LOOP
	AJMP	$
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}


%{stepm5.A51
;
;    Let Stepping Motor clockwise to rotate n steps ,using half-step method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#0
	MOV	DPTR,#PP
LOOP:
	MOV	A,R1
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R1
	CJNE	R1,#8,NEXT1
	MOV	R1,#0
NEXT1:
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N*2+1,LOOP
	AJMP	$
PP:	
	DB	01H,03H,02H,06H,04H,0CH,08H,09H
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}


%{stepm6.A51
;
;    Let Stepping Motor counterclockwise to rotate n steps ,using half-step method
;
N	EQU	10
START:
	MOV	R0,#0
	MOV	R1,#0
	MOV	DPTR,#PP
LOOP:
	MOV	A,R1
	MOVC	A,@A+DPTR
	MOV	P0,A
	INC	R1
	CJNE	R1,#8,NEXT1
	MOV	R1,#0
NEXT1:
	ACALL	DELAY10MS
	INC	R0
	CJNE	R0,#N*2+1,LOOP
	AJMP	$
PP:	
	DB	01H,09H,08H,0CH,04H,06H,02H,03H
%0,2 	include delay.inc
%1 	$include (delay.inc)
	END
%}


@1
%{stepm1a.c
//
//    Let Stepping Motor clockwise to rotate n steps ,using single-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
main()
{
	unsigned char pp=0x1 ;
	int Step ;

	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp ;
	    pp <<=1 ;
	    if(pp == 0x10){
		pp=0x1 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}


@1
%{stepm1b.c
//
//   Let Stepping Motor clockwise to rotate n steps ,using single-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"
#define n   10
main()
{
	unsigned char pp=0x11 ;
	int Step ;

	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp ;
	    // pp rotate left
	    if(pp &0x80){
		pp <<=1 ;
		pp+=1 ;
	    }
	    else{
		pp <<=1 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}


@1
%{stepm2a.c
//
//    Let Stepping Motor counterclockwise to rotate n steps ,using single-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
main()
{
	unsigned char pp=0x8 ;
	int Step ;

	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp ;
	    pp >>=1 ;
	    if(pp == 0x00){
		pp=0x8 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}

@1
%{stepm2b.c
//
//    Let Stepping Motor counterclockwise to rotate n steps ,using single-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
main()
{
	unsigned char pp=0x88 ;
	int Step ;

	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp ;
	    // pp rotate right 
	    if(pp&0x1){
		pp >>=1 ;
		pp+=0x80 ;
	    }
	    else{
		pp >>=1 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}


@1
%{stepm3a.c
//
//    Let Stepping Motor clockwise to rotate n steps ,using two-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
char code pp[]={
	0x3 ,
	0x6 ,
	0xC ,
	0x9 
} ;
main()
{
	int Step ;
	char idx_pp=0 ;
	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp[idx_pp++] ;
	    if(idx_pp == 4){
		idx_pp=0 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}


@1
%{stepm3b.c
//
//    Let Stepping Motor clockwise to rotate n steps ,using two-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
main()
{
	unsigned char pp=0x33 ;
	int Step ;

	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp ;
	    // pp rotate left
	    if(pp &0x80){
		pp <<=1 ;
		pp+=1 ;
	    }
	    else{
		pp <<=1 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}


@1
%{stepm4a.c
//
//    Let Stepping Motor counterclockwise to rotate n steps ,using two-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
char code pp[]={
	0x3 ,
	0x9 ,
	0xC ,
	0x6 
} ;
main()
{
	int Step ;
	char idx_pp=0 ;
	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp[idx_pp++] ;
	    if(idx_pp == 4){
		idx_pp=0 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}

@1
%{stepm4b.c
//
//    Let Stepping Motor counterclockwise to rotate n steps ,using two-phase pulse method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
main()
{
	unsigned char pp=0x33 ;
	int Step ;

	for(Step=0 ;Step < (n+1) ; Step++){
	    P0=pp ;
	    // pp rotate right
	    if(pp&0x1){
		pp >>=1 ;
		pp+=0x80 ;
	    }
	    else{
		pp >>=1 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}


@1
%{stepm5.c
//
//    Let Stepping Motor clockwise to rotate n steps ,using half-step method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
char code pp[]={
	0x1 ,
	0x3 ,
	0x2 ,
	0x6 ,
	0x4 ,
	0xC ,
	0x8 ,
	0x9 
} ;
main()
{
	int Step ;
	char idx_pp=0 ;
	for(Step=0 ;Step < (n*2+1) ; Step++){
	    P0=pp[idx_pp++] ;
	    if(idx_pp == 8){
		idx_pp=0 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}


%{stepm6.c
//
//    Let Stepping Motor counterclockwise to rotate n steps ,using half-step method
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include	"Delay.h"
#define n   10
char code pp[]={
	0x1 ,
	0x9 ,
	0x8 ,
	0xC ,
	0x4 ,
	0x6 ,
	0x2 ,
	0x3 
} ;
main()
{
	int Step ;
	char idx_pp=0 ;
	for(Step=0 ;Step < (n*2+1) ; Step++){
	    P0=pp[idx_pp++] ;
	    if(idx_pp == 8){
		idx_pp=0 ;
	    }
	    Delay10ms() ;
	}
	for(;;) ;
}
%}

@1
%{tc.c
//
//   P0.0~P0.7 and P1.0~P1.3 control 4 pieces of Seven-Segment LED,
//   P2.0 select timer mode/counter mode;ON is timer mode, OFF is counter mode
//   P2.1 to start/stop timer/counter ;On is to start timer/counter , OFF is to stop timer/counter
//   P2.2 is counter pulse input
//
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>

unsigned char code sstbl[]={
	0xc0,0xf9,0xa4,0xb0,
	0x99,0x92,0x82,0xf8,
	0x80,0x90,0x88,0x83,
	0xc6,0xa1,0x86,0x8e
} ;
void delay1ms()
{
	int i ;
	char  j;
	for(i=0 ; i < 124 ;i++) ;
	j++ ;
}

char Count=0;

main()
{
	char Lt=1, Time=1;
	char i, s=0, ch[4]={0,0,0,0};

	TMOD =0x01;
	TH0= (0xffff-50000)/256 ;
	TL0= (0xffff-50000)%256 ;
	EA=1;
	ET0=1 ;
	TR0=1 ;

	for(i=0; ;i++){
	   if(~P2&0x02 ){
		if(~P2&0x01 ){ //­p®É
		    if(Time == 0){
			Time=1;
			ch[0]=0;
			ch[1]=0;
			ch[2]=0;
			ch[3]=0;
			s = 0;
			Count = 0;
		    }
		    if(Count>=20){
			Count -= 20;
			s++;
			if( s>=60 ){
			    s=0;
			    ch[3]++;
			    if(ch[3]>9){
				ch[3]=0;
				ch[2]++;
				if(ch[2]>=6){
				    ch[2]=0;
				    ch[1]++;
				    if(ch[1]>9){
					ch[1]=0;
					ch[0]++;
					if(ch[0]>9){
					    ch[0]=0;
					}
				    }	
				}
			    }
			}
		    }
		}
		else{          // counter mode
		    if(Time == 1){
			Time=0;
			ch[0]=0;
			ch[1]=0;
			ch[2]=0;
			ch[3]=0;
			s = 0;
		    }
		    if( Lt==1 ){
			if((~P2&0x04)==0 ){
			    Lt=0;
			    ch[3]++;
			    if( ch[3]>9 ){
				ch[3]=0;
				ch[2]++;
				if(ch[2]>9){
				    ch[2]=0;
				    ch[1]++;
				    if(ch[1]>9){
					ch[1]=0;
					ch[0]++;
					if(ch[0]>9){
					    ch[0]=0;
					}
				    }
				}
			    }
			}
		    }
		    else{
			if(~P2&0x04){
			    Lt=1;
			}
		    }
		}
	    }
  	    i &= 3;	
	    P1=0xff ;  // OFF all LED
	    P0 = sstbl[ch[i]];
	    if(s&1) P0&=0x7f;
	    else    P0|=0x80;		
	    P1 = ~(1<<i);
	    delay1ms();
	}
}

void timer0(void ) interrupt 1
{
	Count++;
	TH0= (0xffff-50000)/256 ;
	TL0=(0xffff-50000)%256 ;

}
%}


@1
%{testgate.c
//
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
#include "Delay.h"

struct tt{
	char in1,in2,out;
};

struct tt code Tbl[7][4]=
{
    {{0,0,0}, {0,1,0}, {1,0,0}, {1,1,1}},
    {{0,0,0}, {0,1,1}, {1,0,1}, {1,1,1}},
    {{0,0,0}, {0,1,1}, {1,0,1}, {1,1,0}},
    {{0,0,1}, {0,1,1}, {1,0,1}, {1,1,0}},
    {{0,0,1}, {0,1,0}, {1,0,0}, {1,1,0}},
    {{0,0,1}, {0,1,0}, {1,0,0}, {1,1,1}},
    {{0,0,1}, {0,1,1}, {1,0,0}, {1,1,0}}, 
};

void delay20ms()
{
	Delay10ms();
	Delay10ms();
}

void main ()
{
	unsigned char i, j, k, t;

	P0 = 0;
	for(;;){
	    if( (P2&0x01) == 1 ){
		delay20ms() ;
		delay20ms() ;
		while((P2&0x01) == 1);
		for( i=0; i < 7; i++ ){
		    t = 0x01<<i;
		    if( (P1&t) != 0 ){
			k=0;
			for(j=0;j<4;j++){
			    if( Tbl[i][j].in1 ) P0 |= 1;
			    else  P0 &= 0xfe;
			    if( Tbl[i][j].in2 ) P0 |= 2;
			    else	  P0 &= 0xfd;
			    t = P2>>1;
			    if( (t&0x01) != Tbl[i][j].out ){
				k=1;
			    }
			}
			P0&=0xf3;
			if( k==1){
			    P0 |=0x08;
			}
			else{
			    P0 |=0x04;
			}	
			break;
		    }
		}
	    }
	}
}
%}


@1
%{timer0a.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char Count ;
main()
{
	P0=Count=0 ;
	TMOD =0x10 ;
	TH0= (0xffff-10000)/256 ;
	TL0=(0xffff-10000)%256 ;
	EA=1;
	ET0=1 ;
	TR0=1 ;
	for(;;) ;
}
void timer0(void ) interrupt 1
{
	Count++ ;
	P0=Count ;
	TH0= (0xffff-10000)/256 ;
	TL0=(0xffff-10000)%256 ;
}
%}


@1
%{timer0b.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
main()
{
	TMOD =0x50 ; // counter mode 
	TR0=1 ;
	for(;;) {
	    P0=TL0 ;
	}
}
%}


@1
%{timer0c.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
main()
{
	TMOD =0xd0 ; // counter mode 
	TR0=1 ;
	for(;;) {
	    P0=TL0 ;
	}
}
%}


@1
%{traffic.c
//
//   P0.0~P0.5 control 4 couple of traffic light(initial state:all OFF),
//   Change form:
//        The same direction traffic lights have the same operation ,
//      green light ON 3 sec, yellow light flash 3 sec, red light ON 3 sec
//
#pragma oe db pw(80) SM SB CD
#include <reg51.h>
#include "Delay.h"

main()
{
	int i;

	for(;;) {
	    P0 = 0xde;
	    for(i=0;i<1;i++) {
		Delay100ms() ;
	    }

	    for(i=0;i<4;i++){
		if((i&1)==1){
		    P0 = 0xfe;
		}
		else{
		    P0 = 0xee;
		}
		Delay100ms() ;
	    }

	    P0 = 0xf3;
	    for(i=0;i<1;i++) {
		Delay100ms() ;
	    }

	    for(i=0;i<4;i++){
		if((i&1)==1) P0 = 0xf7;
		else 	 P0 = 0xf5;
		Delay100ms() ;
	    }
	}
}
%}


@1
%{sdelay.h
//  delay routine dedicate to Simulator

#ifndef SIMULATOR_DELAY_ROUTINE
#define SIMULATOR_DELAY_ROUTINE
#ifdef DUMMY_DELAY
void Delay100us (void)
{
	ACC = 1;
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

void Delay1ms (void)
{
	ACC = 2;
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

void Delay10ms (void)
{
	ACC = 3;
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

void Delay100ms (void)
{
	ACC = 4;
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

void Delay1s (void)
{
	ACC = 5;
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

void Delay10s (void)
{
	ACC = 6;
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

void Delay100s (void)
{
	ACC = 7;
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

void Delay100usP(unsigned char cnt)
{
	F0  = 1;
	F0  = 1;
	F0  = 1;
}

#else
void Delay100us (void)
{
	char i;
	for(i=0; i<31; i++);
	i++;	
}

void Delay1ms (void)
{
	int i ;
	char  j;
	for(i=0 ; i < 124 ;i++) ;
	j++ ;
}

void Delay10ms (void)
{
	char i;
	for(i=0; i < 10; i++){
	    Delay1ms();
	}
}

void Delay100ms (void)
{
	long i ;
	char j ;
	for(i=0 ; i < 709 ; i++) ;  
	for(j=0 ; j < 5 ;j++) ;
	j++ ;
	j++ ;
}

void Delay1s (void)
{
	char i;
	for(i=0; i < 10; i++){
	    Delay100ms();
	}
}

void Delay10s (void)
{
	char i;
	for(i=0; i < 10; i++){
	    Delay1s();
	}
}

void Delay100s (void)
{
	char i;
	for(i=0; i < 10; i++){
	    Delay10s();
	}
}

void Delay100usP(unsigned char cnt)
{
	char i;

	while( cnt != 0 ){
	    for(i=0; i<31; i++);
	    i++;
	    cnt--;
	}
}
#endif
#endif
%}


%{rdelay.inc
; delay routine dedicate to Simulator 
; using R0, R1, R2, R3

DELAY100US:
	PUSH	ACC
	MOV	A,R1
	PUSH	ACC
	MOV	R1,#44
	DJNZ	R1,$
	POP	ACC
	MOV	R1,A
	POP	ACC
	RET
;
DELAY1MS:
	PUSH	ACC
	MOV	A,R1
	PUSH	ACC
	MOV	R1,#255
	DJNZ	R1,$
	MOV	R1,#236
	DJNZ	R1,$
	POP	ACC
	MOV	R1,A
	POP	ACC
	RET
;
DELAY10MS:
	PUSH	ACC
	MOV	A,R0
	PUSH	ACC
	MOV	A,R1
	PUSH	ACC
	MOV	R0,#19
DELAY10ms_1:
	MOV	R1,#255
	DJNZ	R1,$
	DJNZ	R0,DELAY10ms_1
	MOV	R1,#113
	DJNZ	R1,$
	NOP
	POP	ACC
	MOV	R1,A
	POP	ACC
	MOV	R0,A
	POP	ACC
	RET
;
DELAY100MS:
	PUSH	ACC
	MOV	A,R0
	PUSH	ACC
	MOV	A,R1
	PUSH	ACC
	MOV	R0,#194
DELAY100ms_1:
	MOV	R1,#255
	DJNZ	R1,$
	DJNZ	R0,DELAY100ms_1
	POP	ACC
	MOV	R1,A
	POP	ACC
	MOV	R0,A
	POP	ACC
        RET
;
DELAY1S:
	PUSH	ACC
	MOV	A,R2
	PUSH	ACC
	MOV	R2,#10
DELAY1s_1:
	LCALL	DELAY100MS
	DJNZ	R2,DELAY1s_1
	POP	ACC
	MOV	R2,A
	POP	ACC
	RET
;
DELAY10S:
	PUSH	ACC
	MOV	A,R2
	PUSH	ACC
	MOV	R2,#100
DELAY10s_1:
	LCALL	DELAY100MS
 	DJNZ	R2,DELAY10s_1
	POP	ACC
	MOV	R2,A
	POP	ACC
	RET
;
DELAY100S:
	PUSH	ACC
	MOV	A,R3
	PUSH	ACC
	MOV	R3,#10
DELAY100s_1:
	LCALL	DELAY10S
	DJNZ	R3,DELAY100s_1
	POP	ACC
	MOV	R2,A
	POP	ACC
	RET
;
DELAY100USP:
	PUSH	ACC
	MOV	A,R1
	PUSH	ACC
	MOV	A, R7
DELAY100usP_1:
	MOV	R1,#44
	DJNZ	R1,$
	DJNZ	ACC,DELAY100usP_1    
	POP	ACC
	MOV	R1,A
	POP	ACC
	RET
;
%}


%{sdelay.inc
; delay routine dedicate to Simulator
DELAY100US:
	MOV	A,#01;
	SETB	F0
	SETB	F0
	SETB	F0
	RET
DELAY1MS:
	MOV	A,#02;
	SETB	F0
	SETB	F0
	SETB	F0
	RET
DELAY10MS:
	MOV	A,#03;
	SETB	F0
	SETB	F0
	SETB	F0
	RET
DELAY100MS:
	MOV	A,#04;
	SETB	F0
	SETB	F0
	SETB	F0
	RET
DELAY1S:
	MOV	A,#05;
	SETB	F0
	SETB	F0
	SETB	F0
	RET
DELAY10S:
	MOV	A,#06;
	SETB	F0
	SETB	F0
	SETB	F0
	RET
DELAY100S:
	MOV	A,#07;
	SETB	F0
	SETB	F0
	SETB	F0
	RET
DELAY100USP:
	SETB	F0
	SETB	F0
	SETB	F0
	RET
%}


@1
%{struct1.c
#pragma oe db pw(80) SM SB CD
struct{
	char year ;
	char month ;
	char day ;
	int temp ;
	int pressure;
	long acc_no ;
} tt ;
main()
{
	int i ;
//	char c;
//	c= tt.year ;
//	c=tt.month ;
//	c= tt.day ;
	i=tt.temp ;
	i=tt.pressure ;
}
%}


@1
%{struct2.c
#pragma oe db pw(80) SM SB CD
struct{
	char year ;
	char month ;
	char day ;
	int temp ;
	int pressure;
	long acc_no ;
} tt[10] ;
main()
{
	int i ;
	char c;
//	c= tt[2].year ;
//	c=tt[3].month ;
//	c= tt[4].day ;
	i=tt[2].temp ;
//	i=tt[c].pressure ;
}
%}


@1
%{timer0.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char Count ;
main()
{
	P0=Count=0 ;
	TMOD =0x10 ;
	TH0= (0xffff-10000)/256 ;
	TL0=(0xffff-10000)%256 ;
	EA=1;
	ET0=1 ;
	TR0=1 ;
	for(;;) ;
}
void timer0(void ) interrupt 1
{
	Count++ ;
	P0=Count ;
	TH0= (0xffff-10000)/256 ;
	TL0=(0xffff-10000)%256 ;
}
%}


%{bug1.a51
;
; °t¦X"4*5Áä½L¹ê²ßªO"
;   Â²³æÁä½L±½ºË³]­p
;
VAL1	EQU	0
VAL2	EQU	1
VAL3	EQU	2
START:
	MOV	VAL1,#1
	SETB	F0

	MOV	B,#0FFH
	SETB	F0
	MOV	A,#1
	SETB	F0
	CJNE	A,VAL1,ADDR1
	MOV	B,#1
	SETB	F0
	JMP	ADDR2
ADDR1:	MOV	B,#0
ADDR2:	SETB	F0
	JMP	$

	END
%}


%{sswich81.a51
LOOP:
	MOV	P0,P1
	AJMP	LOOP
	END
%}


%{test.a51
LOOP:
	MOV	P0,P1
	AJMP	LOOP
	END
%}


%{tled8.a51
;
; °t¦X"8­ÓLED¹ê²ßªO"
;   P0©Ò±µªº8­ÓLED¦³¤G¬Û¾FªºLED«GµÛ,¨Ã¶i¦æ¥k±ÛªºÅÜ¤Æ
;
	MOV	A,#01111111B
right:
	jnb	p0.0,left
	ACALL	DELAY100MS
	RR	A
	MOV	P0,A
	SJMP	right
left:
	jnb	p0.7,right
	acall	delay100ms
	rl	a
	MOV	P0,A
	sjmp	left

%0,2 	include delay.inc
%1 	$include (delay.inc)

	END
%}


%{tt.a51
;
;   ¦UºØ²ÕÄ¶«ü¤Þ(Directive)
;    °t¦XDSEG,DS©ÎEQU,¥Ü½d¤º³¡¸ê®Æ°O¾ÐÅéªº¦w¸m¤Î¦ì§}³]©w
;
%0,2 di:	EQU	30H
%0,2 dd:	EQU	di+2
%1 	DSEG	AT 30H
%1 di:	DS	2
%1 dd:	DS	1
%1 	CSEG
	MOV	A,dd
	RLC	A
	SUBB	A,ACC
	MOV	di,A
	MOV	di+01H,dd
	END
%}


%{tt-1.a51
;
;   ¦s¨ú¤º³¡¸ê®Æ°O¾ÐÅé(¦ì§}¬°0,8,40h,90h)ªº¦UºØ¤èªk
;
;
;   ±N¤º³¡°O¾ÐÅé¦ì§}0¸ü¤J¨ìACC(¤TºØ)
	MOV	A,R0
	CLR	A

	MOV	A,00
	CLR	A

	MOV	R1,#00
	MOV	A,@R1

;     ±N¤º³¡°O¾ÐÅé¦ì§}8¸ü¤J¨ìACC(¤TºØ)
	SETB	RS0
	MOV	A,R0
	CLR	RS0
	CLR	A

	MOV	A,08
	CLR	A

	MOV	R1,#08
	MOV	A,@R1
	CLR	A

;     ±N¤º³¡°O¾ÐÅé¦ì§}40h¸ü¤J¨ìACC(¤GºØ)

	MOV	A,40h
	CLR	A

	MOV	R1,#40h
	MOV	A,@R1
	CLR	A

;     ±N¤º³¡°O¾ÐÅé¦ì§}40h¸ü¤J¨ìACC(¤@ºØ)

	MOV	A,90h     ; ¿ù»~µ²ªG(¦s¨ú¨ì¯S®í¼È¦s¾¹)
	CLR	A

	MOV	R1,#90h
	MOV	A,@R1
	CLR	A

	END
%}


@1
%{dotmatrix1.c
#pragma   sm  sb cd
#include	<reg51.h>
unsigned char code dai[]= { 0xfe,0xdd,0xdb,0x0f,0xd7,0xdb,0xdd,0xfe} ;
delay()
{
	long i ;
	for(i=0;i < 100L ;i++) ;
}
main()
{
	char i ;
	char com ;
	i=0 ;
	com=0x80 ;
	for( ; ;){
	    P1=0 ;
	    P0=dai[i++] ;
	    P1=com ;
	    com >>=1 ;
	    if(i >=8){
		i=0 ;
		com=0x80 ;
	    }
	    delay() ;
	}
}
%}


@1
%{dotmtx1.c
//
//  °t¦X"8*8³æ¦âÂI¯x°}LED¹ê²ßªO"
//   ¦b8*8³æ¦âÂI¯x°}LED¤WÅã¥Ü¤¤¤å¦r---"¤j"
//
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
unsigned char code dai[]= { 0xfd,0xdb,0xd7,0x0f,0xd7,0xdb,0xdd,0xff} ;
void delay1ms()
{
	int i ;
	char  j;
	for(i=0 ; i < 124 ;i++) ;
	j++ ;
}
delay3ms()
{
	delay1ms() ;
	delay1ms() ;
	delay1ms() ;
}
main()
{
	unsigned char com ,idx;

	com=0x80 ;
	idx=0 ;
	for( ;;){
	    P1=0xff ;
	    P0=dai[idx++] ;
	    P1=~com ;
	    com >>=1 ;
	    if(idx==8){
		idx=0;
		com=0x80 ;
	    }
	    delay3ms() ;
	}
}
%}


@1
%{dtype1.c
#pragma oe db pw(80) SM SB CD
#include	<reg51.h>
char val1,val2,res,i;
char data *pcd ;
char code *pcc ;
int ival1,ival2,ires;
int data *pid ;
long lval1,lval2,lres;
long data *pld ;
main()
{
	pcd= &val1 ;
	val1= *pcd ;
	val2= pcd[1] ;
	val1= pcd[i] ;
	ival1= *pid ;
	ival2= pid[1] ;
	ival1= pid[i] ;
	lval1= *pld ;
	lval2= pld[1] ;
	lval1= pld[i] ;

	res=val1+val2 ;
	for(;;);
}
%}

1


15


